// Generated by jextract

package com.silong.foundation.utilities.whispercpp.generated;

import static java.lang.foreign.ValueLayout.*;

import java.lang.foreign.*;
import java.lang.invoke.*;
import java.util.*;
import java.util.stream.*;

public class WhisperCpp_1 {

    WhisperCpp_1() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.loaderLookup()
            .or(Linker.nativeLinker().defaultLookup());

    public static final OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final OfInt C_INT = ValueLayout.JAVA_INT;
    public static final OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, JAVA_BYTE));
    public static final OfInt C_LONG = ValueLayout.JAVA_INT;
    public static final OfDouble C_LONG_DOUBLE = ValueLayout.JAVA_DOUBLE;
    private static final int true_ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define true 1
     * }
     */
    public static int true_() {
        return true_;
    }
    private static final int false_ = (int)0L;
    /**
     * {@snippet lang=c :
     * #define false 0
     * }
     */
    public static int false_() {
        return false_;
    }
    private static final int __bool_true_false_are_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __bool_true_false_are_defined 1
     * }
     */
    public static int __bool_true_false_are_defined() {
        return __bool_true_false_are_defined;
    }
    private static final int _VCRT_COMPILER_PREPROCESSOR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _VCRT_COMPILER_PREPROCESSOR 1
     * }
     */
    public static int _VCRT_COMPILER_PREPROCESSOR() {
        return _VCRT_COMPILER_PREPROCESSOR;
    }
    private static final int _SAL_VERSION = (int)20L;
    /**
     * {@snippet lang=c :
     * #define _SAL_VERSION 20
     * }
     */
    public static int _SAL_VERSION() {
        return _SAL_VERSION;
    }
    private static final int __SAL_H_VERSION = (int)180000000L;
    /**
     * {@snippet lang=c :
     * #define __SAL_H_VERSION 180000000
     * }
     */
    public static int __SAL_H_VERSION() {
        return __SAL_H_VERSION;
    }
    private static final int _USE_DECLSPECS_FOR_SAL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _USE_DECLSPECS_FOR_SAL 0
     * }
     */
    public static int _USE_DECLSPECS_FOR_SAL() {
        return _USE_DECLSPECS_FOR_SAL;
    }
    private static final int _USE_ATTRIBUTES_FOR_SAL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _USE_ATTRIBUTES_FOR_SAL 0
     * }
     */
    public static int _USE_ATTRIBUTES_FOR_SAL() {
        return _USE_ATTRIBUTES_FOR_SAL;
    }
    private static final int _CRT_PACKING = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _CRT_PACKING 8
     * }
     */
    public static int _CRT_PACKING() {
        return _CRT_PACKING;
    }
    private static final int _HAS_EXCEPTIONS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _HAS_EXCEPTIONS 1
     * }
     */
    public static int _HAS_EXCEPTIONS() {
        return _HAS_EXCEPTIONS;
    }
    private static final int _HAS_CXX17 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _HAS_CXX17 0
     * }
     */
    public static int _HAS_CXX17() {
        return _HAS_CXX17;
    }
    private static final int _HAS_CXX20 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _HAS_CXX20 0
     * }
     */
    public static int _HAS_CXX20() {
        return _HAS_CXX20;
    }
    private static final int _HAS_CXX23 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _HAS_CXX23 0
     * }
     */
    public static int _HAS_CXX23() {
        return _HAS_CXX23;
    }
    private static final int _HAS_NODISCARD = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _HAS_NODISCARD 0
     * }
     */
    public static int _HAS_NODISCARD() {
        return _HAS_NODISCARD;
    }
    private static final int WCHAR_MIN = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MIN 0
     * }
     */
    public static int WCHAR_MIN() {
        return WCHAR_MIN;
    }
    private static final int WCHAR_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MAX 65535
     * }
     */
    public static int WCHAR_MAX() {
        return WCHAR_MAX;
    }
    private static final int WINT_MIN = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINT_MIN 0
     * }
     */
    public static int WINT_MIN() {
        return WINT_MIN;
    }
    private static final int WINT_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define WINT_MAX 65535
     * }
     */
    public static int WINT_MAX() {
        return WINT_MAX;
    }
    private static final int _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE 1
     * }
     */
    public static int _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE() {
        return _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE;
    }
    private static final int _CRT_BUILD_DESKTOP_APP = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_BUILD_DESKTOP_APP 1
     * }
     */
    public static int _CRT_BUILD_DESKTOP_APP() {
        return _CRT_BUILD_DESKTOP_APP;
    }
    private static final int _ARGMAX = (int)100L;
    /**
     * {@snippet lang=c :
     * #define _ARGMAX 100
     * }
     */
    public static int _ARGMAX() {
        return _ARGMAX;
    }
    private static final int _CRT_INT_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INT_MAX 2147483647
     * }
     */
    public static int _CRT_INT_MAX() {
        return _CRT_INT_MAX;
    }
    private static final int _CRT_FUNCTIONS_REQUIRED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_FUNCTIONS_REQUIRED 1
     * }
     */
    public static int _CRT_FUNCTIONS_REQUIRED() {
        return _CRT_FUNCTIONS_REQUIRED;
    }
    private static final int _CRT_HAS_CXX17 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _CRT_HAS_CXX17 0
     * }
     */
    public static int _CRT_HAS_CXX17() {
        return _CRT_HAS_CXX17;
    }
    private static final int _CRT_HAS_C11 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_HAS_C11 1
     * }
     */
    public static int _CRT_HAS_C11() {
        return _CRT_HAS_C11;
    }
    private static final int _CRT_INTERNAL_NONSTDC_NAMES = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_INTERNAL_NONSTDC_NAMES 1
     * }
     */
    public static int _CRT_INTERNAL_NONSTDC_NAMES() {
        return _CRT_INTERNAL_NONSTDC_NAMES;
    }
    private static final int __STDC_WANT_SECURE_LIB__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_WANT_SECURE_LIB__ 1
     * }
     */
    public static int __STDC_WANT_SECURE_LIB__() {
        return __STDC_WANT_SECURE_LIB__;
    }
    private static final int _SECURECRT_FILL_BUFFER_PATTERN = (int)254L;
    /**
     * {@snippet lang=c :
     * #define _SECURECRT_FILL_BUFFER_PATTERN 254
     * }
     */
    public static int _SECURECRT_FILL_BUFFER_PATTERN() {
        return _SECURECRT_FILL_BUFFER_PATTERN;
    }
    private static final int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 0
     * }
     */
    public static int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES() {
        return _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES;
    }
    private static final int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT 0
     * }
     */
    public static int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT() {
        return _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT;
    }
    private static final int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES 1
     * }
     */
    public static int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES() {
        return _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES;
    }
    private static final int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY 0
     * }
     */
    public static int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY() {
        return _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY;
    }
    private static final int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY 0
     * }
     */
    public static int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY() {
        return _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY;
    }
    private static final int BUFSIZ = (int)512L;
    /**
     * {@snippet lang=c :
     * #define BUFSIZ 512
     * }
     */
    public static int BUFSIZ() {
        return BUFSIZ;
    }
    private static final int _NSTREAM_ = (int)512L;
    /**
     * {@snippet lang=c :
     * #define _NSTREAM_ 512
     * }
     */
    public static int _NSTREAM_() {
        return _NSTREAM_;
    }
    private static final int _IOB_ENTRIES = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _IOB_ENTRIES 3
     * }
     */
    public static int _IOB_ENTRIES() {
        return _IOB_ENTRIES;
    }
    private static final int _IOFBF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _IOFBF 0
     * }
     */
    public static int _IOFBF() {
        return _IOFBF;
    }
    private static final int _IOLBF = (int)64L;
    /**
     * {@snippet lang=c :
     * #define _IOLBF 64
     * }
     */
    public static int _IOLBF() {
        return _IOLBF;
    }
    private static final int _IONBF = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _IONBF 4
     * }
     */
    public static int _IONBF() {
        return _IONBF;
    }
    private static final int L_tmpnam = (int)260L;
    /**
     * {@snippet lang=c :
     * #define L_tmpnam 260
     * }
     */
    public static int L_tmpnam() {
        return L_tmpnam;
    }
    private static final int SEEK_CUR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SEEK_CUR 1
     * }
     */
    public static int SEEK_CUR() {
        return SEEK_CUR;
    }
    private static final int SEEK_END = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SEEK_END 2
     * }
     */
    public static int SEEK_END() {
        return SEEK_END;
    }
    private static final int SEEK_SET = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SEEK_SET 0
     * }
     */
    public static int SEEK_SET() {
        return SEEK_SET;
    }
    private static final int FILENAME_MAX = (int)260L;
    /**
     * {@snippet lang=c :
     * #define FILENAME_MAX 260
     * }
     */
    public static int FILENAME_MAX() {
        return FILENAME_MAX;
    }
    private static final int FOPEN_MAX = (int)20L;
    /**
     * {@snippet lang=c :
     * #define FOPEN_MAX 20
     * }
     */
    public static int FOPEN_MAX() {
        return FOPEN_MAX;
    }
    private static final int _SYS_OPEN = (int)20L;
    /**
     * {@snippet lang=c :
     * #define _SYS_OPEN 20
     * }
     */
    public static int _SYS_OPEN() {
        return _SYS_OPEN;
    }
    private static final int GGML_FILE_MAGIC = (int)1734831468L;
    /**
     * {@snippet lang=c :
     * #define GGML_FILE_MAGIC 1734831468
     * }
     */
    public static int GGML_FILE_MAGIC() {
        return GGML_FILE_MAGIC;
    }
    private static final int GGML_FILE_VERSION = (int)2L;
    /**
     * {@snippet lang=c :
     * #define GGML_FILE_VERSION 2
     * }
     */
    public static int GGML_FILE_VERSION() {
        return GGML_FILE_VERSION;
    }
    private static final int GGML_QNT_VERSION = (int)2L;
    /**
     * {@snippet lang=c :
     * #define GGML_QNT_VERSION 2
     * }
     */
    public static int GGML_QNT_VERSION() {
        return GGML_QNT_VERSION;
    }
    private static final int GGML_QNT_VERSION_FACTOR = (int)1000L;
    /**
     * {@snippet lang=c :
     * #define GGML_QNT_VERSION_FACTOR 1000
     * }
     */
    public static int GGML_QNT_VERSION_FACTOR() {
        return GGML_QNT_VERSION_FACTOR;
    }
    private static final int GGML_MAX_DIMS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define GGML_MAX_DIMS 4
     * }
     */
    public static int GGML_MAX_DIMS() {
        return GGML_MAX_DIMS;
    }
    private static final int GGML_MAX_PARAMS = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define GGML_MAX_PARAMS 2048
     * }
     */
    public static int GGML_MAX_PARAMS() {
        return GGML_MAX_PARAMS;
    }
    private static final int GGML_MAX_SRC = (int)10L;
    /**
     * {@snippet lang=c :
     * #define GGML_MAX_SRC 10
     * }
     */
    public static int GGML_MAX_SRC() {
        return GGML_MAX_SRC;
    }
    private static final int GGML_MAX_N_THREADS = (int)512L;
    /**
     * {@snippet lang=c :
     * #define GGML_MAX_N_THREADS 512
     * }
     */
    public static int GGML_MAX_N_THREADS() {
        return GGML_MAX_N_THREADS;
    }
    private static final int GGML_MAX_OP_PARAMS = (int)64L;
    /**
     * {@snippet lang=c :
     * #define GGML_MAX_OP_PARAMS 64
     * }
     */
    public static int GGML_MAX_OP_PARAMS() {
        return GGML_MAX_OP_PARAMS;
    }
    private static final int GGML_MAX_NAME = (int)64L;
    /**
     * {@snippet lang=c :
     * #define GGML_MAX_NAME 64
     * }
     */
    public static int GGML_MAX_NAME() {
        return GGML_MAX_NAME;
    }
    private static final int GGML_DEFAULT_N_THREADS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define GGML_DEFAULT_N_THREADS 4
     * }
     */
    public static int GGML_DEFAULT_N_THREADS() {
        return GGML_DEFAULT_N_THREADS;
    }
    private static final int GGML_DEFAULT_GRAPH_SIZE = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define GGML_DEFAULT_GRAPH_SIZE 2048
     * }
     */
    public static int GGML_DEFAULT_GRAPH_SIZE() {
        return GGML_DEFAULT_GRAPH_SIZE;
    }
    private static final int GGML_MEM_ALIGN = (int)16L;
    /**
     * {@snippet lang=c :
     * #define GGML_MEM_ALIGN 16
     * }
     */
    public static int GGML_MEM_ALIGN() {
        return GGML_MEM_ALIGN;
    }
    private static final int GGML_EXIT_SUCCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define GGML_EXIT_SUCCESS 0
     * }
     */
    public static int GGML_EXIT_SUCCESS() {
        return GGML_EXIT_SUCCESS;
    }
    private static final int GGML_EXIT_ABORTED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GGML_EXIT_ABORTED 1
     * }
     */
    public static int GGML_EXIT_ABORTED() {
        return GGML_EXIT_ABORTED;
    }
    private static final int GGML_ROPE_TYPE_NEOX = (int)2L;
    /**
     * {@snippet lang=c :
     * #define GGML_ROPE_TYPE_NEOX 2
     * }
     */
    public static int GGML_ROPE_TYPE_NEOX() {
        return GGML_ROPE_TYPE_NEOX;
    }
    private static final int GGML_ROPE_TYPE_MROPE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define GGML_ROPE_TYPE_MROPE 8
     * }
     */
    public static int GGML_ROPE_TYPE_MROPE() {
        return GGML_ROPE_TYPE_MROPE;
    }
    private static final int GGML_ROPE_TYPE_VISION = (int)24L;
    /**
     * {@snippet lang=c :
     * #define GGML_ROPE_TYPE_VISION 24
     * }
     */
    public static int GGML_ROPE_TYPE_VISION() {
        return GGML_ROPE_TYPE_VISION;
    }
    private static final int GGML_KQ_MASK_PAD = (int)64L;
    /**
     * {@snippet lang=c :
     * #define GGML_KQ_MASK_PAD 64
     * }
     */
    public static int GGML_KQ_MASK_PAD() {
        return GGML_KQ_MASK_PAD;
    }
    private static final int WHISPER_SAMPLE_RATE = (int)16000L;
    /**
     * {@snippet lang=c :
     * #define WHISPER_SAMPLE_RATE 16000
     * }
     */
    public static int WHISPER_SAMPLE_RATE() {
        return WHISPER_SAMPLE_RATE;
    }
    private static final int WHISPER_N_FFT = (int)400L;
    /**
     * {@snippet lang=c :
     * #define WHISPER_N_FFT 400
     * }
     */
    public static int WHISPER_N_FFT() {
        return WHISPER_N_FFT;
    }
    private static final int WHISPER_HOP_LENGTH = (int)160L;
    /**
     * {@snippet lang=c :
     * #define WHISPER_HOP_LENGTH 160
     * }
     */
    public static int WHISPER_HOP_LENGTH() {
        return WHISPER_HOP_LENGTH;
    }
    private static final int WHISPER_CHUNK_SIZE = (int)30L;
    /**
     * {@snippet lang=c :
     * #define WHISPER_CHUNK_SIZE 30
     * }
     */
    public static int WHISPER_CHUNK_SIZE() {
        return WHISPER_CHUNK_SIZE;
    }
    /**
     * {@snippet lang=c :
     * typedef long long ptrdiff_t
     * }
     */
    public static final OfLong ptrdiff_t = WhisperCpp.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long size_t
     * }
     */
    public static final OfLong size_t = WhisperCpp.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned short wchar_t
     * }
     */
    public static final OfShort wchar_t = WhisperCpp.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef double max_align_t
     * }
     */
    public static final OfDouble max_align_t = WhisperCpp.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = WhisperCpp.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef char *va_list
     * }
     */
    public static final AddressLayout va_list = WhisperCpp.C_POINTER;

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void __va_start(va_list *, ...)
     * }
     */
    public static class __va_start {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                WhisperCpp.C_POINTER
            );
        private static final MemorySegment ADDR = WhisperCpp.findOrThrow("__va_start");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __va_start(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void __va_start(va_list *, ...)
         * }
         */
        public static __va_start makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __va_start(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__va_start", x0, x1);
                }
                 spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long long intptr_t
     * }
     */
    public static final OfLong intptr_t = WhisperCpp.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef bool __vcrt_bool
     * }
     */
    public static final OfBoolean __vcrt_bool = WhisperCpp.C_BOOL;

    private static class __security_init_cookie {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("__security_init_cookie");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __security_init_cookie()
     * }
     */
    public static FunctionDescriptor __security_init_cookie$descriptor() {
        return __security_init_cookie.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __security_init_cookie()
     * }
     */
    public static MethodHandle __security_init_cookie$handle() {
        return __security_init_cookie.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __security_init_cookie()
     * }
     */
    public static MemorySegment __security_init_cookie$address() {
        return __security_init_cookie.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __security_init_cookie()
     * }
     */
    public static void __security_init_cookie() {
        var mh$ = __security_init_cookie.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__security_init_cookie");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __security_check_cookie {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("__security_check_cookie");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __security_check_cookie(uintptr_t _StackCookie)
     * }
     */
    public static FunctionDescriptor __security_check_cookie$descriptor() {
        return __security_check_cookie.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __security_check_cookie(uintptr_t _StackCookie)
     * }
     */
    public static MethodHandle __security_check_cookie$handle() {
        return __security_check_cookie.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __security_check_cookie(uintptr_t _StackCookie)
     * }
     */
    public static MemorySegment __security_check_cookie$address() {
        return __security_check_cookie.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __security_check_cookie(uintptr_t _StackCookie)
     * }
     */
    public static void __security_check_cookie(long _StackCookie) {
        var mh$ = __security_check_cookie.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__security_check_cookie", _StackCookie);
            }
            mh$.invokeExact(_StackCookie);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __report_gsfailure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("__report_gsfailure");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __report_gsfailure(uintptr_t _StackCookie)
     * }
     */
    public static FunctionDescriptor __report_gsfailure$descriptor() {
        return __report_gsfailure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __report_gsfailure(uintptr_t _StackCookie)
     * }
     */
    public static MethodHandle __report_gsfailure$handle() {
        return __report_gsfailure.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __report_gsfailure(uintptr_t _StackCookie)
     * }
     */
    public static MemorySegment __report_gsfailure$address() {
        return __report_gsfailure.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __report_gsfailure(uintptr_t _StackCookie)
     * }
     */
    public static void __report_gsfailure(long _StackCookie) {
        var mh$ = __report_gsfailure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__report_gsfailure", _StackCookie);
            }
            mh$.invokeExact(_StackCookie);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __security_cookie$constants {
        public static final OfLong LAYOUT = WhisperCpp.C_LONG_LONG;
        public static final MemorySegment SEGMENT = WhisperCpp.findOrThrow("__security_cookie").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern uintptr_t __security_cookie
     * }
     */
    public static OfLong __security_cookie$layout() {
        return __security_cookie$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern uintptr_t __security_cookie
     * }
     */
    public static MemorySegment __security_cookie$segment() {
        return __security_cookie$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern uintptr_t __security_cookie
     * }
     */
    public static long __security_cookie() {
        return __security_cookie$constants.SEGMENT.get(__security_cookie$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern uintptr_t __security_cookie
     * }
     */
    public static void __security_cookie(long varValue) {
        __security_cookie$constants.SEGMENT.set(__security_cookie$constants.LAYOUT, 0L, varValue);
    }
    /**
     * {@snippet lang=c :
     * typedef signed char int8_t
     * }
     */
    public static final OfByte int8_t = WhisperCpp.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short int16_t
     * }
     */
    public static final OfShort int16_t = WhisperCpp.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int int32_t
     * }
     */
    public static final OfInt int32_t = WhisperCpp.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long int64_t
     * }
     */
    public static final OfLong int64_t = WhisperCpp.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint8_t
     * }
     */
    public static final OfByte uint8_t = WhisperCpp.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short uint16_t
     * }
     */
    public static final OfShort uint16_t = WhisperCpp.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint32_t
     * }
     */
    public static final OfInt uint32_t = WhisperCpp.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uint64_t
     * }
     */
    public static final OfLong uint64_t = WhisperCpp.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char int_least8_t
     * }
     */
    public static final OfByte int_least8_t = WhisperCpp.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short int_least16_t
     * }
     */
    public static final OfShort int_least16_t = WhisperCpp.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int int_least32_t
     * }
     */
    public static final OfInt int_least32_t = WhisperCpp.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long int_least64_t
     * }
     */
    public static final OfLong int_least64_t = WhisperCpp.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = WhisperCpp.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = WhisperCpp.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = WhisperCpp.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = WhisperCpp.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = WhisperCpp.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int int_fast16_t
     * }
     */
    public static final OfInt int_fast16_t = WhisperCpp.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int int_fast32_t
     * }
     */
    public static final OfInt int_fast32_t = WhisperCpp.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = WhisperCpp.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = WhisperCpp.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint_fast16_t
     * }
     */
    public static final OfInt uint_fast16_t = WhisperCpp.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint_fast32_t
     * }
     */
    public static final OfInt uint_fast32_t = WhisperCpp.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = WhisperCpp.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long intmax_t
     * }
     */
    public static final OfLong intmax_t = WhisperCpp.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uintmax_t
     * }
     */
    public static final OfLong uintmax_t = WhisperCpp.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef bool __crt_bool
     * }
     */
    public static final OfBoolean __crt_bool = WhisperCpp.C_BOOL;

    private static class _invalid_parameter_noinfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_invalid_parameter_noinfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo()
     * }
     */
    public static FunctionDescriptor _invalid_parameter_noinfo$descriptor() {
        return _invalid_parameter_noinfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo()
     * }
     */
    public static MethodHandle _invalid_parameter_noinfo$handle() {
        return _invalid_parameter_noinfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo()
     * }
     */
    public static MemorySegment _invalid_parameter_noinfo$address() {
        return _invalid_parameter_noinfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo()
     * }
     */
    public static void _invalid_parameter_noinfo() {
        var mh$ = _invalid_parameter_noinfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_invalid_parameter_noinfo");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _invalid_parameter_noinfo_noreturn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_invalid_parameter_noinfo_noreturn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo_noreturn()
     * }
     */
    public static FunctionDescriptor _invalid_parameter_noinfo_noreturn$descriptor() {
        return _invalid_parameter_noinfo_noreturn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo_noreturn()
     * }
     */
    public static MethodHandle _invalid_parameter_noinfo_noreturn$handle() {
        return _invalid_parameter_noinfo_noreturn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo_noreturn()
     * }
     */
    public static MemorySegment _invalid_parameter_noinfo_noreturn$address() {
        return _invalid_parameter_noinfo_noreturn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo_noreturn()
     * }
     */
    public static void _invalid_parameter_noinfo_noreturn() {
        var mh$ = _invalid_parameter_noinfo_noreturn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_invalid_parameter_noinfo_noreturn");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _invoke_watson {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_invoke_watson");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _invoke_watson(const wchar_t *_Expression, const wchar_t *_FunctionName, const wchar_t *_FileName, unsigned int _LineNo, uintptr_t _Reserved)
     * }
     */
    public static FunctionDescriptor _invoke_watson$descriptor() {
        return _invoke_watson.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _invoke_watson(const wchar_t *_Expression, const wchar_t *_FunctionName, const wchar_t *_FileName, unsigned int _LineNo, uintptr_t _Reserved)
     * }
     */
    public static MethodHandle _invoke_watson$handle() {
        return _invoke_watson.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _invoke_watson(const wchar_t *_Expression, const wchar_t *_FunctionName, const wchar_t *_FileName, unsigned int _LineNo, uintptr_t _Reserved)
     * }
     */
    public static MemorySegment _invoke_watson$address() {
        return _invoke_watson.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _invoke_watson(const wchar_t *_Expression, const wchar_t *_FunctionName, const wchar_t *_FileName, unsigned int _LineNo, uintptr_t _Reserved)
     * }
     */
    public static void _invoke_watson(MemorySegment _Expression, MemorySegment _FunctionName, MemorySegment _FileName, int _LineNo, long _Reserved) {
        var mh$ = _invoke_watson.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_invoke_watson", _Expression, _FunctionName, _FileName, _LineNo, _Reserved);
            }
            mh$.invokeExact(_Expression, _FunctionName, _FileName, _LineNo, _Reserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int errno_t
     * }
     */
    public static final OfInt errno_t = WhisperCpp.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short wint_t
     * }
     */
    public static final OfShort wint_t = WhisperCpp.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short wctype_t
     * }
     */
    public static final OfShort wctype_t = WhisperCpp.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef long __time32_t
     * }
     */
    public static final OfInt __time32_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long __time64_t
     * }
     */
    public static final OfLong __time64_t = WhisperCpp.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __crt_locale_pointers *_locale_t
     * }
     */
    public static final AddressLayout _locale_t = WhisperCpp.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __time64_t time_t
     * }
     */
    public static final OfLong time_t = WhisperCpp.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef size_t rsize_t
     * }
     */
    public static final OfLong rsize_t = WhisperCpp.C_LONG_LONG;

    private static class __acrt_iob_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("__acrt_iob_func");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *__acrt_iob_func(unsigned int _Ix)
     * }
     */
    public static FunctionDescriptor __acrt_iob_func$descriptor() {
        return __acrt_iob_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *__acrt_iob_func(unsigned int _Ix)
     * }
     */
    public static MethodHandle __acrt_iob_func$handle() {
        return __acrt_iob_func.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *__acrt_iob_func(unsigned int _Ix)
     * }
     */
    public static MemorySegment __acrt_iob_func$address() {
        return __acrt_iob_func.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *__acrt_iob_func(unsigned int _Ix)
     * }
     */
    public static MemorySegment __acrt_iob_func(int _Ix) {
        var mh$ = __acrt_iob_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__acrt_iob_func", _Ix);
            }
            return (MemorySegment)mh$.invokeExact(_Ix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetwc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_SHORT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fgetwc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t fgetwc(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fgetwc$descriptor() {
        return fgetwc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t fgetwc(FILE *_Stream)
     * }
     */
    public static MethodHandle fgetwc$handle() {
        return fgetwc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t fgetwc(FILE *_Stream)
     * }
     */
    public static MemorySegment fgetwc$address() {
        return fgetwc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t fgetwc(FILE *_Stream)
     * }
     */
    public static short fgetwc(MemorySegment _Stream) {
        var mh$ = fgetwc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetwc", _Stream);
            }
            return (short)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fgetwchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_SHORT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_fgetwchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _fgetwchar()
     * }
     */
    public static FunctionDescriptor _fgetwchar$descriptor() {
        return _fgetwchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _fgetwchar()
     * }
     */
    public static MethodHandle _fgetwchar$handle() {
        return _fgetwchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _fgetwchar()
     * }
     */
    public static MemorySegment _fgetwchar$address() {
        return _fgetwchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _fgetwchar()
     * }
     */
    public static short _fgetwchar() {
        var mh$ = _fgetwchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fgetwchar");
            }
            return (short)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputwc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_SHORT,
            WhisperCpp.C_SHORT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fputwc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t fputwc(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fputwc$descriptor() {
        return fputwc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t fputwc(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle fputwc$handle() {
        return fputwc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t fputwc(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment fputwc$address() {
        return fputwc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t fputwc(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static short fputwc(short _Character, MemorySegment _Stream) {
        var mh$ = fputwc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputwc", _Character, _Stream);
            }
            return (short)mh$.invokeExact(_Character, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fputwchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_SHORT,
            WhisperCpp.C_SHORT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_fputwchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _fputwchar(wchar_t _Character)
     * }
     */
    public static FunctionDescriptor _fputwchar$descriptor() {
        return _fputwchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _fputwchar(wchar_t _Character)
     * }
     */
    public static MethodHandle _fputwchar$handle() {
        return _fputwchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _fputwchar(wchar_t _Character)
     * }
     */
    public static MemorySegment _fputwchar$address() {
        return _fputwchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _fputwchar(wchar_t _Character)
     * }
     */
    public static short _fputwchar(short _Character) {
        var mh$ = _fputwchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fputwchar", _Character);
            }
            return (short)mh$.invokeExact(_Character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getwc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_SHORT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("getwc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t getwc(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor getwc$descriptor() {
        return getwc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t getwc(FILE *_Stream)
     * }
     */
    public static MethodHandle getwc$handle() {
        return getwc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t getwc(FILE *_Stream)
     * }
     */
    public static MemorySegment getwc$address() {
        return getwc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t getwc(FILE *_Stream)
     * }
     */
    public static short getwc(MemorySegment _Stream) {
        var mh$ = getwc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getwc", _Stream);
            }
            return (short)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getwchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_SHORT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("getwchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t getwchar()
     * }
     */
    public static FunctionDescriptor getwchar$descriptor() {
        return getwchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t getwchar()
     * }
     */
    public static MethodHandle getwchar$handle() {
        return getwchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t getwchar()
     * }
     */
    public static MemorySegment getwchar$address() {
        return getwchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t getwchar()
     * }
     */
    public static short getwchar() {
        var mh$ = getwchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getwchar");
            }
            return (short)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetws {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fgetws");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *fgetws(wchar_t *_Buffer, int _BufferCount, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fgetws$descriptor() {
        return fgetws.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *fgetws(wchar_t *_Buffer, int _BufferCount, FILE *_Stream)
     * }
     */
    public static MethodHandle fgetws$handle() {
        return fgetws.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *fgetws(wchar_t *_Buffer, int _BufferCount, FILE *_Stream)
     * }
     */
    public static MemorySegment fgetws$address() {
        return fgetws.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *fgetws(wchar_t *_Buffer, int _BufferCount, FILE *_Stream)
     * }
     */
    public static MemorySegment fgetws(MemorySegment _Buffer, int _BufferCount, MemorySegment _Stream) {
        var mh$ = fgetws.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetws", _Buffer, _BufferCount, _Stream);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer, _BufferCount, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputws {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fputws");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fputws(const wchar_t *_Buffer, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fputws$descriptor() {
        return fputws.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fputws(const wchar_t *_Buffer, FILE *_Stream)
     * }
     */
    public static MethodHandle fputws$handle() {
        return fputws.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fputws(const wchar_t *_Buffer, FILE *_Stream)
     * }
     */
    public static MemorySegment fputws$address() {
        return fputws.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fputws(const wchar_t *_Buffer, FILE *_Stream)
     * }
     */
    public static int fputws(MemorySegment _Buffer, MemorySegment _Stream) {
        var mh$ = fputws.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputws", _Buffer, _Stream);
            }
            return (int)mh$.invokeExact(_Buffer, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _getws_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_getws_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_getws_s(wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static FunctionDescriptor _getws_s$descriptor() {
        return _getws_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_getws_s(wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static MethodHandle _getws_s$handle() {
        return _getws_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_getws_s(wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static MemorySegment _getws_s$address() {
        return _getws_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_getws_s(wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static MemorySegment _getws_s(MemorySegment _Buffer, long _BufferCount) {
        var mh$ = _getws_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_getws_s", _Buffer, _BufferCount);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer, _BufferCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putwc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_SHORT,
            WhisperCpp.C_SHORT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("putwc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t putwc(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor putwc$descriptor() {
        return putwc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t putwc(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle putwc$handle() {
        return putwc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t putwc(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment putwc$address() {
        return putwc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t putwc(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static short putwc(short _Character, MemorySegment _Stream) {
        var mh$ = putwc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putwc", _Character, _Stream);
            }
            return (short)mh$.invokeExact(_Character, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putwchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_SHORT,
            WhisperCpp.C_SHORT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("putwchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t putwchar(wchar_t _Character)
     * }
     */
    public static FunctionDescriptor putwchar$descriptor() {
        return putwchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t putwchar(wchar_t _Character)
     * }
     */
    public static MethodHandle putwchar$handle() {
        return putwchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t putwchar(wchar_t _Character)
     * }
     */
    public static MemorySegment putwchar$address() {
        return putwchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t putwchar(wchar_t _Character)
     * }
     */
    public static short putwchar(short _Character) {
        var mh$ = putwchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putwchar", _Character);
            }
            return (short)mh$.invokeExact(_Character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _putws {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_putws");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _putws(const wchar_t *_Buffer)
     * }
     */
    public static FunctionDescriptor _putws$descriptor() {
        return _putws.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _putws(const wchar_t *_Buffer)
     * }
     */
    public static MethodHandle _putws$handle() {
        return _putws.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _putws(const wchar_t *_Buffer)
     * }
     */
    public static MemorySegment _putws$address() {
        return _putws.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _putws(const wchar_t *_Buffer)
     * }
     */
    public static int _putws(MemorySegment _Buffer) {
        var mh$ = _putws.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_putws", _Buffer);
            }
            return (int)mh$.invokeExact(_Buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ungetwc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_SHORT,
            WhisperCpp.C_SHORT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ungetwc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t ungetwc(wint_t _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor ungetwc$descriptor() {
        return ungetwc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t ungetwc(wint_t _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle ungetwc$handle() {
        return ungetwc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t ungetwc(wint_t _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment ungetwc$address() {
        return ungetwc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t ungetwc(wint_t _Character, FILE *_Stream)
     * }
     */
    public static short ungetwc(short _Character, MemorySegment _Stream) {
        var mh$ = ungetwc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ungetwc", _Character, _Stream);
            }
            return (short)mh$.invokeExact(_Character, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfdopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_wfdopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *_wfdopen(int _FileHandle, const wchar_t *_Mode)
     * }
     */
    public static FunctionDescriptor _wfdopen$descriptor() {
        return _wfdopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *_wfdopen(int _FileHandle, const wchar_t *_Mode)
     * }
     */
    public static MethodHandle _wfdopen$handle() {
        return _wfdopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *_wfdopen(int _FileHandle, const wchar_t *_Mode)
     * }
     */
    public static MemorySegment _wfdopen$address() {
        return _wfdopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *_wfdopen(int _FileHandle, const wchar_t *_Mode)
     * }
     */
    public static MemorySegment _wfdopen(int _FileHandle, MemorySegment _Mode) {
        var mh$ = _wfdopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfdopen", _FileHandle, _Mode);
            }
            return (MemorySegment)mh$.invokeExact(_FileHandle, _Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_wfopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *_wfopen(const wchar_t *_FileName, const wchar_t *_Mode)
     * }
     */
    public static FunctionDescriptor _wfopen$descriptor() {
        return _wfopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *_wfopen(const wchar_t *_FileName, const wchar_t *_Mode)
     * }
     */
    public static MethodHandle _wfopen$handle() {
        return _wfopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *_wfopen(const wchar_t *_FileName, const wchar_t *_Mode)
     * }
     */
    public static MemorySegment _wfopen$address() {
        return _wfopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *_wfopen(const wchar_t *_FileName, const wchar_t *_Mode)
     * }
     */
    public static MemorySegment _wfopen(MemorySegment _FileName, MemorySegment _Mode) {
        var mh$ = _wfopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfopen", _FileName, _Mode);
            }
            return (MemorySegment)mh$.invokeExact(_FileName, _Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfopen_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_wfopen_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wfopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode)
     * }
     */
    public static FunctionDescriptor _wfopen_s$descriptor() {
        return _wfopen_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wfopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode)
     * }
     */
    public static MethodHandle _wfopen_s$handle() {
        return _wfopen_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wfopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode)
     * }
     */
    public static MemorySegment _wfopen_s$address() {
        return _wfopen_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wfopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode)
     * }
     */
    public static int _wfopen_s(MemorySegment _Stream, MemorySegment _FileName, MemorySegment _Mode) {
        var mh$ = _wfopen_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfopen_s", _Stream, _FileName, _Mode);
            }
            return (int)mh$.invokeExact(_Stream, _FileName, _Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfreopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_wfreopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *_wfreopen(const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream)
     * }
     */
    public static FunctionDescriptor _wfreopen$descriptor() {
        return _wfreopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *_wfreopen(const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream)
     * }
     */
    public static MethodHandle _wfreopen$handle() {
        return _wfreopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *_wfreopen(const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream)
     * }
     */
    public static MemorySegment _wfreopen$address() {
        return _wfreopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *_wfreopen(const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream)
     * }
     */
    public static MemorySegment _wfreopen(MemorySegment _FileName, MemorySegment _Mode, MemorySegment _OldStream) {
        var mh$ = _wfreopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfreopen", _FileName, _Mode, _OldStream);
            }
            return (MemorySegment)mh$.invokeExact(_FileName, _Mode, _OldStream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfreopen_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_wfreopen_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wfreopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream)
     * }
     */
    public static FunctionDescriptor _wfreopen_s$descriptor() {
        return _wfreopen_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wfreopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream)
     * }
     */
    public static MethodHandle _wfreopen_s$handle() {
        return _wfreopen_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wfreopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream)
     * }
     */
    public static MemorySegment _wfreopen_s$address() {
        return _wfreopen_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wfreopen_s(FILE **_Stream, const wchar_t *_FileName, const wchar_t *_Mode, FILE *_OldStream)
     * }
     */
    public static int _wfreopen_s(MemorySegment _Stream, MemorySegment _FileName, MemorySegment _Mode, MemorySegment _OldStream) {
        var mh$ = _wfreopen_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfreopen_s", _Stream, _FileName, _Mode, _OldStream);
            }
            return (int)mh$.invokeExact(_Stream, _FileName, _Mode, _OldStream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfsopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_wfsopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *_wfsopen(const wchar_t *_FileName, const wchar_t *_Mode, int _ShFlag)
     * }
     */
    public static FunctionDescriptor _wfsopen$descriptor() {
        return _wfsopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *_wfsopen(const wchar_t *_FileName, const wchar_t *_Mode, int _ShFlag)
     * }
     */
    public static MethodHandle _wfsopen$handle() {
        return _wfsopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *_wfsopen(const wchar_t *_FileName, const wchar_t *_Mode, int _ShFlag)
     * }
     */
    public static MemorySegment _wfsopen$address() {
        return _wfsopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *_wfsopen(const wchar_t *_FileName, const wchar_t *_Mode, int _ShFlag)
     * }
     */
    public static MemorySegment _wfsopen(MemorySegment _FileName, MemorySegment _Mode, int _ShFlag) {
        var mh$ = _wfsopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfsopen", _FileName, _Mode, _ShFlag);
            }
            return (MemorySegment)mh$.invokeExact(_FileName, _Mode, _ShFlag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wperror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_wperror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _wperror(const wchar_t *_ErrorMessage)
     * }
     */
    public static FunctionDescriptor _wperror$descriptor() {
        return _wperror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _wperror(const wchar_t *_ErrorMessage)
     * }
     */
    public static MethodHandle _wperror$handle() {
        return _wperror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _wperror(const wchar_t *_ErrorMessage)
     * }
     */
    public static MemorySegment _wperror$address() {
        return _wperror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _wperror(const wchar_t *_ErrorMessage)
     * }
     */
    public static void _wperror(MemorySegment _ErrorMessage) {
        var mh$ = _wperror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wperror", _ErrorMessage);
            }
            mh$.invokeExact(_ErrorMessage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wpopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_wpopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *_wpopen(const wchar_t *_Command, const wchar_t *_Mode)
     * }
     */
    public static FunctionDescriptor _wpopen$descriptor() {
        return _wpopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *_wpopen(const wchar_t *_Command, const wchar_t *_Mode)
     * }
     */
    public static MethodHandle _wpopen$handle() {
        return _wpopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *_wpopen(const wchar_t *_Command, const wchar_t *_Mode)
     * }
     */
    public static MemorySegment _wpopen$address() {
        return _wpopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *_wpopen(const wchar_t *_Command, const wchar_t *_Mode)
     * }
     */
    public static MemorySegment _wpopen(MemorySegment _Command, MemorySegment _Mode) {
        var mh$ = _wpopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wpopen", _Command, _Mode);
            }
            return (MemorySegment)mh$.invokeExact(_Command, _Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wremove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_wremove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wremove(const wchar_t *_FileName)
     * }
     */
    public static FunctionDescriptor _wremove$descriptor() {
        return _wremove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wremove(const wchar_t *_FileName)
     * }
     */
    public static MethodHandle _wremove$handle() {
        return _wremove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _wremove(const wchar_t *_FileName)
     * }
     */
    public static MemorySegment _wremove$address() {
        return _wremove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _wremove(const wchar_t *_FileName)
     * }
     */
    public static int _wremove(MemorySegment _FileName) {
        var mh$ = _wremove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wremove", _FileName);
            }
            return (int)mh$.invokeExact(_FileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtempnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_wtempnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wtempnam(const wchar_t *_Directory, const wchar_t *_FilePrefix)
     * }
     */
    public static FunctionDescriptor _wtempnam$descriptor() {
        return _wtempnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wtempnam(const wchar_t *_Directory, const wchar_t *_FilePrefix)
     * }
     */
    public static MethodHandle _wtempnam$handle() {
        return _wtempnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wtempnam(const wchar_t *_Directory, const wchar_t *_FilePrefix)
     * }
     */
    public static MemorySegment _wtempnam$address() {
        return _wtempnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wtempnam(const wchar_t *_Directory, const wchar_t *_FilePrefix)
     * }
     */
    public static MemorySegment _wtempnam(MemorySegment _Directory, MemorySegment _FilePrefix) {
        var mh$ = _wtempnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtempnam", _Directory, _FilePrefix);
            }
            return (MemorySegment)mh$.invokeExact(_Directory, _FilePrefix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtmpnam_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_wtmpnam_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wtmpnam_s(wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static FunctionDescriptor _wtmpnam_s$descriptor() {
        return _wtmpnam_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wtmpnam_s(wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static MethodHandle _wtmpnam_s$handle() {
        return _wtmpnam_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _wtmpnam_s(wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static MemorySegment _wtmpnam_s$address() {
        return _wtmpnam_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _wtmpnam_s(wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static int _wtmpnam_s(MemorySegment _Buffer, long _BufferCount) {
        var mh$ = _wtmpnam_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtmpnam_s", _Buffer, _BufferCount);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtmpnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_wtmpnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wtmpnam(wchar_t *_Buffer)
     * }
     */
    public static FunctionDescriptor _wtmpnam$descriptor() {
        return _wtmpnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wtmpnam(wchar_t *_Buffer)
     * }
     */
    public static MethodHandle _wtmpnam$handle() {
        return _wtmpnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *_wtmpnam(wchar_t *_Buffer)
     * }
     */
    public static MemorySegment _wtmpnam$address() {
        return _wtmpnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *_wtmpnam(wchar_t *_Buffer)
     * }
     */
    public static MemorySegment _wtmpnam(MemorySegment _Buffer) {
        var mh$ = _wtmpnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtmpnam", _Buffer);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fgetwc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_SHORT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_fgetwc_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _fgetwc_nolock(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fgetwc_nolock$descriptor() {
        return _fgetwc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _fgetwc_nolock(FILE *_Stream)
     * }
     */
    public static MethodHandle _fgetwc_nolock$handle() {
        return _fgetwc_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _fgetwc_nolock(FILE *_Stream)
     * }
     */
    public static MemorySegment _fgetwc_nolock$address() {
        return _fgetwc_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _fgetwc_nolock(FILE *_Stream)
     * }
     */
    public static short _fgetwc_nolock(MemorySegment _Stream) {
        var mh$ = _fgetwc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fgetwc_nolock", _Stream);
            }
            return (short)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fputwc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_SHORT,
            WhisperCpp.C_SHORT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_fputwc_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _fputwc_nolock(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fputwc_nolock$descriptor() {
        return _fputwc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _fputwc_nolock(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle _fputwc_nolock$handle() {
        return _fputwc_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _fputwc_nolock(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment _fputwc_nolock$address() {
        return _fputwc_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _fputwc_nolock(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static short _fputwc_nolock(short _Character, MemorySegment _Stream) {
        var mh$ = _fputwc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fputwc_nolock", _Character, _Stream);
            }
            return (short)mh$.invokeExact(_Character, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _getwc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_SHORT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_getwc_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _getwc_nolock(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _getwc_nolock$descriptor() {
        return _getwc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _getwc_nolock(FILE *_Stream)
     * }
     */
    public static MethodHandle _getwc_nolock$handle() {
        return _getwc_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _getwc_nolock(FILE *_Stream)
     * }
     */
    public static MemorySegment _getwc_nolock$address() {
        return _getwc_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _getwc_nolock(FILE *_Stream)
     * }
     */
    public static short _getwc_nolock(MemorySegment _Stream) {
        var mh$ = _getwc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_getwc_nolock", _Stream);
            }
            return (short)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _putwc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_SHORT,
            WhisperCpp.C_SHORT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_putwc_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _putwc_nolock(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _putwc_nolock$descriptor() {
        return _putwc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _putwc_nolock(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle _putwc_nolock$handle() {
        return _putwc_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _putwc_nolock(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment _putwc_nolock$address() {
        return _putwc_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _putwc_nolock(wchar_t _Character, FILE *_Stream)
     * }
     */
    public static short _putwc_nolock(short _Character, MemorySegment _Stream) {
        var mh$ = _putwc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_putwc_nolock", _Character, _Stream);
            }
            return (short)mh$.invokeExact(_Character, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ungetwc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_SHORT,
            WhisperCpp.C_SHORT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_ungetwc_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wint_t _ungetwc_nolock(wint_t _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _ungetwc_nolock$descriptor() {
        return _ungetwc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wint_t _ungetwc_nolock(wint_t _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle _ungetwc_nolock$handle() {
        return _ungetwc_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wint_t _ungetwc_nolock(wint_t _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment _ungetwc_nolock$address() {
        return _ungetwc_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wint_t _ungetwc_nolock(wint_t _Character, FILE *_Stream)
     * }
     */
    public static short _ungetwc_nolock(short _Character, MemorySegment _Stream) {
        var mh$ = _ungetwc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ungetwc_nolock", _Character, _Stream);
            }
            return (short)mh$.invokeExact(_Character, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vfwprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("__stdio_common_vfwprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vfwprintf$descriptor() {
        return __stdio_common_vfwprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vfwprintf$handle() {
        return __stdio_common_vfwprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vfwprintf$address() {
        return __stdio_common_vfwprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vfwprintf(long _Options, MemorySegment _Stream, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vfwprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vfwprintf", _Options, _Stream, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Stream, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vfwprintf_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("__stdio_common_vfwprintf_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf_s(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vfwprintf_s$descriptor() {
        return __stdio_common_vfwprintf_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf_s(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vfwprintf_s$handle() {
        return __stdio_common_vfwprintf_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf_s(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vfwprintf_s$address() {
        return __stdio_common_vfwprintf_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf_s(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vfwprintf_s(long _Options, MemorySegment _Stream, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vfwprintf_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vfwprintf_s", _Options, _Stream, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Stream, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vfwprintf_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("__stdio_common_vfwprintf_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf_p(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vfwprintf_p$descriptor() {
        return __stdio_common_vfwprintf_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf_p(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vfwprintf_p$handle() {
        return __stdio_common_vfwprintf_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf_p(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vfwprintf_p$address() {
        return __stdio_common_vfwprintf_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vfwprintf_p(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vfwprintf_p(long _Options, MemorySegment _Stream, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vfwprintf_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vfwprintf_p", _Options, _Stream, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Stream, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vfwscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("__stdio_common_vfwscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vfwscanf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vfwscanf$descriptor() {
        return __stdio_common_vfwscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vfwscanf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vfwscanf$handle() {
        return __stdio_common_vfwscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vfwscanf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vfwscanf$address() {
        return __stdio_common_vfwscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vfwscanf(unsigned long long _Options, FILE *_Stream, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vfwscanf(long _Options, MemorySegment _Stream, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vfwscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vfwscanf", _Options, _Stream, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Stream, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vswprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("__stdio_common_vswprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vswprintf(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vswprintf$descriptor() {
        return __stdio_common_vswprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vswprintf(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vswprintf$handle() {
        return __stdio_common_vswprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vswprintf(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vswprintf$address() {
        return __stdio_common_vswprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vswprintf(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vswprintf(long _Options, MemorySegment _Buffer, long _BufferCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vswprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vswprintf", _Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vswprintf_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("__stdio_common_vswprintf_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vswprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vswprintf_s$descriptor() {
        return __stdio_common_vswprintf_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vswprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vswprintf_s$handle() {
        return __stdio_common_vswprintf_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vswprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vswprintf_s$address() {
        return __stdio_common_vswprintf_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vswprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vswprintf_s(long _Options, MemorySegment _Buffer, long _BufferCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vswprintf_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vswprintf_s", _Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vsnwprintf_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("__stdio_common_vsnwprintf_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vsnwprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vsnwprintf_s$descriptor() {
        return __stdio_common_vsnwprintf_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vsnwprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vsnwprintf_s$handle() {
        return __stdio_common_vsnwprintf_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vsnwprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vsnwprintf_s$address() {
        return __stdio_common_vsnwprintf_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vsnwprintf_s(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vsnwprintf_s(long _Options, MemorySegment _Buffer, long _BufferCount, long _MaxCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vsnwprintf_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vsnwprintf_s", _Options, _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vswprintf_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("__stdio_common_vswprintf_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vswprintf_p(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vswprintf_p$descriptor() {
        return __stdio_common_vswprintf_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vswprintf_p(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vswprintf_p$handle() {
        return __stdio_common_vswprintf_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vswprintf_p(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vswprintf_p$address() {
        return __stdio_common_vswprintf_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vswprintf_p(unsigned long long _Options, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vswprintf_p(long _Options, MemorySegment _Buffer, long _BufferCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vswprintf_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vswprintf_p", _Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vswscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("__stdio_common_vswscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vswscanf(unsigned long long _Options, const wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vswscanf$descriptor() {
        return __stdio_common_vswscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vswscanf(unsigned long long _Options, const wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vswscanf$handle() {
        return __stdio_common_vswscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vswscanf(unsigned long long _Options, const wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vswscanf$address() {
        return __stdio_common_vswscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vswscanf(unsigned long long _Options, const wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vswscanf(long _Options, MemorySegment _Buffer, long _BufferCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vswscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vswscanf", _Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long long fpos_t
     * }
     */
    public static final OfLong fpos_t = WhisperCpp.C_LONG_LONG;

    private static class _get_stream_buffer_pointers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_get_stream_buffer_pointers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_stream_buffer_pointers(FILE *_Stream, char ***_Base, char ***_Pointer, int **_Count)
     * }
     */
    public static FunctionDescriptor _get_stream_buffer_pointers$descriptor() {
        return _get_stream_buffer_pointers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_stream_buffer_pointers(FILE *_Stream, char ***_Base, char ***_Pointer, int **_Count)
     * }
     */
    public static MethodHandle _get_stream_buffer_pointers$handle() {
        return _get_stream_buffer_pointers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t _get_stream_buffer_pointers(FILE *_Stream, char ***_Base, char ***_Pointer, int **_Count)
     * }
     */
    public static MemorySegment _get_stream_buffer_pointers$address() {
        return _get_stream_buffer_pointers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t _get_stream_buffer_pointers(FILE *_Stream, char ***_Base, char ***_Pointer, int **_Count)
     * }
     */
    public static int _get_stream_buffer_pointers(MemorySegment _Stream, MemorySegment _Base, MemorySegment _Pointer, MemorySegment _Count) {
        var mh$ = _get_stream_buffer_pointers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_stream_buffer_pointers", _Stream, _Base, _Pointer, _Count);
            }
            return (int)mh$.invokeExact(_Stream, _Base, _Pointer, _Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearerr_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("clearerr_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t clearerr_s(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor clearerr_s$descriptor() {
        return clearerr_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t clearerr_s(FILE *_Stream)
     * }
     */
    public static MethodHandle clearerr_s$handle() {
        return clearerr_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t clearerr_s(FILE *_Stream)
     * }
     */
    public static MemorySegment clearerr_s$address() {
        return clearerr_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t clearerr_s(FILE *_Stream)
     * }
     */
    public static int clearerr_s(MemorySegment _Stream) {
        var mh$ = clearerr_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr_s", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fopen_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fopen_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t fopen_s(FILE **_Stream, const char *_FileName, const char *_Mode)
     * }
     */
    public static FunctionDescriptor fopen_s$descriptor() {
        return fopen_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t fopen_s(FILE **_Stream, const char *_FileName, const char *_Mode)
     * }
     */
    public static MethodHandle fopen_s$handle() {
        return fopen_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t fopen_s(FILE **_Stream, const char *_FileName, const char *_Mode)
     * }
     */
    public static MemorySegment fopen_s$address() {
        return fopen_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t fopen_s(FILE **_Stream, const char *_FileName, const char *_Mode)
     * }
     */
    public static int fopen_s(MemorySegment _Stream, MemorySegment _FileName, MemorySegment _Mode) {
        var mh$ = fopen_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fopen_s", _Stream, _FileName, _Mode);
            }
            return (int)mh$.invokeExact(_Stream, _FileName, _Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fread_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t fread_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fread_s$descriptor() {
        return fread_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t fread_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MethodHandle fread_s$handle() {
        return fread_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t fread_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MemorySegment fread_s$address() {
        return fread_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t fread_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static long fread_s(MemorySegment _Buffer, long _BufferSize, long _ElementSize, long _ElementCount, MemorySegment _Stream) {
        var mh$ = fread_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread_s", _Buffer, _BufferSize, _ElementSize, _ElementCount, _Stream);
            }
            return (long)mh$.invokeExact(_Buffer, _BufferSize, _ElementSize, _ElementCount, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class freopen_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("freopen_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t freopen_s(FILE **_Stream, const char *_FileName, const char *_Mode, FILE *_OldStream)
     * }
     */
    public static FunctionDescriptor freopen_s$descriptor() {
        return freopen_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t freopen_s(FILE **_Stream, const char *_FileName, const char *_Mode, FILE *_OldStream)
     * }
     */
    public static MethodHandle freopen_s$handle() {
        return freopen_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t freopen_s(FILE **_Stream, const char *_FileName, const char *_Mode, FILE *_OldStream)
     * }
     */
    public static MemorySegment freopen_s$address() {
        return freopen_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t freopen_s(FILE **_Stream, const char *_FileName, const char *_Mode, FILE *_OldStream)
     * }
     */
    public static int freopen_s(MemorySegment _Stream, MemorySegment _FileName, MemorySegment _Mode, MemorySegment _OldStream) {
        var mh$ = freopen_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("freopen_s", _Stream, _FileName, _Mode, _OldStream);
            }
            return (int)mh$.invokeExact(_Stream, _FileName, _Mode, _OldStream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gets_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("gets_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *gets_s(char *_Buffer, rsize_t _Size)
     * }
     */
    public static FunctionDescriptor gets_s$descriptor() {
        return gets_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *gets_s(char *_Buffer, rsize_t _Size)
     * }
     */
    public static MethodHandle gets_s$handle() {
        return gets_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *gets_s(char *_Buffer, rsize_t _Size)
     * }
     */
    public static MemorySegment gets_s$address() {
        return gets_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *gets_s(char *_Buffer, rsize_t _Size)
     * }
     */
    public static MemorySegment gets_s(MemorySegment _Buffer, long _Size) {
        var mh$ = gets_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gets_s", _Buffer, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpfile_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("tmpfile_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t tmpfile_s(FILE **_Stream)
     * }
     */
    public static FunctionDescriptor tmpfile_s$descriptor() {
        return tmpfile_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t tmpfile_s(FILE **_Stream)
     * }
     */
    public static MethodHandle tmpfile_s$handle() {
        return tmpfile_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t tmpfile_s(FILE **_Stream)
     * }
     */
    public static MemorySegment tmpfile_s$address() {
        return tmpfile_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t tmpfile_s(FILE **_Stream)
     * }
     */
    public static int tmpfile_s(MemorySegment _Stream) {
        var mh$ = tmpfile_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpfile_s", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("tmpnam_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t tmpnam_s(char *_Buffer, rsize_t _Size)
     * }
     */
    public static FunctionDescriptor tmpnam_s$descriptor() {
        return tmpnam_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t tmpnam_s(char *_Buffer, rsize_t _Size)
     * }
     */
    public static MethodHandle tmpnam_s$handle() {
        return tmpnam_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t tmpnam_s(char *_Buffer, rsize_t _Size)
     * }
     */
    public static MemorySegment tmpnam_s$address() {
        return tmpnam_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t tmpnam_s(char *_Buffer, rsize_t _Size)
     * }
     */
    public static int tmpnam_s(MemorySegment _Buffer, long _Size) {
        var mh$ = tmpnam_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam_s", _Buffer, _Size);
            }
            return (int)mh$.invokeExact(_Buffer, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearerr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("clearerr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clearerr(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor clearerr$descriptor() {
        return clearerr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clearerr(FILE *_Stream)
     * }
     */
    public static MethodHandle clearerr$handle() {
        return clearerr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clearerr(FILE *_Stream)
     * }
     */
    public static MemorySegment clearerr$address() {
        return clearerr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clearerr(FILE *_Stream)
     * }
     */
    public static void clearerr(MemorySegment _Stream) {
        var mh$ = clearerr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr", _Stream);
            }
            mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fclose(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fclose$descriptor() {
        return fclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fclose(FILE *_Stream)
     * }
     */
    public static MethodHandle fclose$handle() {
        return fclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fclose(FILE *_Stream)
     * }
     */
    public static MemorySegment fclose$address() {
        return fclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fclose(FILE *_Stream)
     * }
     */
    public static int fclose(MemorySegment _Stream) {
        var mh$ = fclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fclose", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fcloseall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_fcloseall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fcloseall()
     * }
     */
    public static FunctionDescriptor _fcloseall$descriptor() {
        return _fcloseall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fcloseall()
     * }
     */
    public static MethodHandle _fcloseall$handle() {
        return _fcloseall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fcloseall()
     * }
     */
    public static MemorySegment _fcloseall$address() {
        return _fcloseall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fcloseall()
     * }
     */
    public static int _fcloseall() {
        var mh$ = _fcloseall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fcloseall");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fdopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_fdopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *_fdopen(int _FileHandle, const char *_Mode)
     * }
     */
    public static FunctionDescriptor _fdopen$descriptor() {
        return _fdopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *_fdopen(int _FileHandle, const char *_Mode)
     * }
     */
    public static MethodHandle _fdopen$handle() {
        return _fdopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *_fdopen(int _FileHandle, const char *_Mode)
     * }
     */
    public static MemorySegment _fdopen$address() {
        return _fdopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *_fdopen(int _FileHandle, const char *_Mode)
     * }
     */
    public static MemorySegment _fdopen(int _FileHandle, MemorySegment _Mode) {
        var mh$ = _fdopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fdopen", _FileHandle, _Mode);
            }
            return (MemorySegment)mh$.invokeExact(_FileHandle, _Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("feof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int feof(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor feof$descriptor() {
        return feof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int feof(FILE *_Stream)
     * }
     */
    public static MethodHandle feof$handle() {
        return feof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int feof(FILE *_Stream)
     * }
     */
    public static MemorySegment feof$address() {
        return feof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int feof(FILE *_Stream)
     * }
     */
    public static int feof(MemorySegment _Stream) {
        var mh$ = feof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ferror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ferror(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor ferror$descriptor() {
        return ferror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ferror(FILE *_Stream)
     * }
     */
    public static MethodHandle ferror$handle() {
        return ferror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ferror(FILE *_Stream)
     * }
     */
    public static MemorySegment ferror$address() {
        return ferror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ferror(FILE *_Stream)
     * }
     */
    public static int ferror(MemorySegment _Stream) {
        var mh$ = ferror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fflush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fflush(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fflush$descriptor() {
        return fflush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fflush(FILE *_Stream)
     * }
     */
    public static MethodHandle fflush$handle() {
        return fflush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fflush(FILE *_Stream)
     * }
     */
    public static MemorySegment fflush$address() {
        return fflush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fflush(FILE *_Stream)
     * }
     */
    public static int fflush(MemorySegment _Stream) {
        var mh$ = fflush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fgetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fgetc(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fgetc$descriptor() {
        return fgetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fgetc(FILE *_Stream)
     * }
     */
    public static MethodHandle fgetc$handle() {
        return fgetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fgetc(FILE *_Stream)
     * }
     */
    public static MemorySegment fgetc$address() {
        return fgetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fgetc(FILE *_Stream)
     * }
     */
    public static int fgetc(MemorySegment _Stream) {
        var mh$ = fgetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fgetchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_fgetchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fgetchar()
     * }
     */
    public static FunctionDescriptor _fgetchar$descriptor() {
        return _fgetchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fgetchar()
     * }
     */
    public static MethodHandle _fgetchar$handle() {
        return _fgetchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fgetchar()
     * }
     */
    public static MemorySegment _fgetchar$address() {
        return _fgetchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fgetchar()
     * }
     */
    public static int _fgetchar() {
        var mh$ = _fgetchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fgetchar");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fgetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fgetpos(FILE *_Stream, fpos_t *_Position)
     * }
     */
    public static FunctionDescriptor fgetpos$descriptor() {
        return fgetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fgetpos(FILE *_Stream, fpos_t *_Position)
     * }
     */
    public static MethodHandle fgetpos$handle() {
        return fgetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fgetpos(FILE *_Stream, fpos_t *_Position)
     * }
     */
    public static MemorySegment fgetpos$address() {
        return fgetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fgetpos(FILE *_Stream, fpos_t *_Position)
     * }
     */
    public static int fgetpos(MemorySegment _Stream, MemorySegment _Position) {
        var mh$ = fgetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetpos", _Stream, _Position);
            }
            return (int)mh$.invokeExact(_Stream, _Position);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fgets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *fgets(char *_Buffer, int _MaxCount, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fgets$descriptor() {
        return fgets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *fgets(char *_Buffer, int _MaxCount, FILE *_Stream)
     * }
     */
    public static MethodHandle fgets$handle() {
        return fgets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *fgets(char *_Buffer, int _MaxCount, FILE *_Stream)
     * }
     */
    public static MemorySegment fgets$address() {
        return fgets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *fgets(char *_Buffer, int _MaxCount, FILE *_Stream)
     * }
     */
    public static MemorySegment fgets(MemorySegment _Buffer, int _MaxCount, MemorySegment _Stream) {
        var mh$ = fgets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgets", _Buffer, _MaxCount, _Stream);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer, _MaxCount, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fileno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_fileno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fileno(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fileno$descriptor() {
        return _fileno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fileno(FILE *_Stream)
     * }
     */
    public static MethodHandle _fileno$handle() {
        return _fileno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fileno(FILE *_Stream)
     * }
     */
    public static MemorySegment _fileno$address() {
        return _fileno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fileno(FILE *_Stream)
     * }
     */
    public static int _fileno(MemorySegment _Stream) {
        var mh$ = _fileno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fileno", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _flushall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_flushall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _flushall()
     * }
     */
    public static FunctionDescriptor _flushall$descriptor() {
        return _flushall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _flushall()
     * }
     */
    public static MethodHandle _flushall$handle() {
        return _flushall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _flushall()
     * }
     */
    public static MemorySegment _flushall$address() {
        return _flushall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _flushall()
     * }
     */
    public static int _flushall() {
        var mh$ = _flushall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_flushall");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *fopen(const char *_FileName, const char *_Mode)
     * }
     */
    public static FunctionDescriptor fopen$descriptor() {
        return fopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *fopen(const char *_FileName, const char *_Mode)
     * }
     */
    public static MethodHandle fopen$handle() {
        return fopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *fopen(const char *_FileName, const char *_Mode)
     * }
     */
    public static MemorySegment fopen$address() {
        return fopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *fopen(const char *_FileName, const char *_Mode)
     * }
     */
    public static MemorySegment fopen(MemorySegment _FileName, MemorySegment _Mode) {
        var mh$ = fopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fopen", _FileName, _Mode);
            }
            return (MemorySegment)mh$.invokeExact(_FileName, _Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fputc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fputc(int _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fputc$descriptor() {
        return fputc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fputc(int _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle fputc$handle() {
        return fputc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fputc(int _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment fputc$address() {
        return fputc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fputc(int _Character, FILE *_Stream)
     * }
     */
    public static int fputc(int _Character, MemorySegment _Stream) {
        var mh$ = fputc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc", _Character, _Stream);
            }
            return (int)mh$.invokeExact(_Character, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fputchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_fputchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fputchar(int _Character)
     * }
     */
    public static FunctionDescriptor _fputchar$descriptor() {
        return _fputchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fputchar(int _Character)
     * }
     */
    public static MethodHandle _fputchar$handle() {
        return _fputchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fputchar(int _Character)
     * }
     */
    public static MemorySegment _fputchar$address() {
        return _fputchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fputchar(int _Character)
     * }
     */
    public static int _fputchar(int _Character) {
        var mh$ = _fputchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fputchar", _Character);
            }
            return (int)mh$.invokeExact(_Character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fputs(const char *_Buffer, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fputs$descriptor() {
        return fputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fputs(const char *_Buffer, FILE *_Stream)
     * }
     */
    public static MethodHandle fputs$handle() {
        return fputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fputs(const char *_Buffer, FILE *_Stream)
     * }
     */
    public static MemorySegment fputs$address() {
        return fputs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fputs(const char *_Buffer, FILE *_Stream)
     * }
     */
    public static int fputs(MemorySegment _Buffer, MemorySegment _Stream) {
        var mh$ = fputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputs", _Buffer, _Stream);
            }
            return (int)mh$.invokeExact(_Buffer, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long fread(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fread$descriptor() {
        return fread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long fread(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MethodHandle fread$handle() {
        return fread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long fread(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MemorySegment fread$address() {
        return fread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long fread(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static long fread(MemorySegment _Buffer, long _ElementSize, long _ElementCount, MemorySegment _Stream) {
        var mh$ = fread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread", _Buffer, _ElementSize, _ElementCount, _Stream);
            }
            return (long)mh$.invokeExact(_Buffer, _ElementSize, _ElementCount, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class freopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("freopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *freopen(const char *_FileName, const char *_Mode, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor freopen$descriptor() {
        return freopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *freopen(const char *_FileName, const char *_Mode, FILE *_Stream)
     * }
     */
    public static MethodHandle freopen$handle() {
        return freopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *freopen(const char *_FileName, const char *_Mode, FILE *_Stream)
     * }
     */
    public static MemorySegment freopen$address() {
        return freopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *freopen(const char *_FileName, const char *_Mode, FILE *_Stream)
     * }
     */
    public static MemorySegment freopen(MemorySegment _FileName, MemorySegment _Mode, MemorySegment _Stream) {
        var mh$ = freopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("freopen", _FileName, _Mode, _Stream);
            }
            return (MemorySegment)mh$.invokeExact(_FileName, _Mode, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fsopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_fsopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *_fsopen(const char *_FileName, const char *_Mode, int _ShFlag)
     * }
     */
    public static FunctionDescriptor _fsopen$descriptor() {
        return _fsopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *_fsopen(const char *_FileName, const char *_Mode, int _ShFlag)
     * }
     */
    public static MethodHandle _fsopen$handle() {
        return _fsopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *_fsopen(const char *_FileName, const char *_Mode, int _ShFlag)
     * }
     */
    public static MemorySegment _fsopen$address() {
        return _fsopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *_fsopen(const char *_FileName, const char *_Mode, int _ShFlag)
     * }
     */
    public static MemorySegment _fsopen(MemorySegment _FileName, MemorySegment _Mode, int _ShFlag) {
        var mh$ = _fsopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fsopen", _FileName, _Mode, _ShFlag);
            }
            return (MemorySegment)mh$.invokeExact(_FileName, _Mode, _ShFlag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fsetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fsetpos(FILE *_Stream, const fpos_t *_Position)
     * }
     */
    public static FunctionDescriptor fsetpos$descriptor() {
        return fsetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fsetpos(FILE *_Stream, const fpos_t *_Position)
     * }
     */
    public static MethodHandle fsetpos$handle() {
        return fsetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fsetpos(FILE *_Stream, const fpos_t *_Position)
     * }
     */
    public static MemorySegment fsetpos$address() {
        return fsetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fsetpos(FILE *_Stream, const fpos_t *_Position)
     * }
     */
    public static int fsetpos(MemorySegment _Stream, MemorySegment _Position) {
        var mh$ = fsetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsetpos", _Stream, _Position);
            }
            return (int)mh$.invokeExact(_Stream, _Position);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fseek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fseek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fseek(FILE *_Stream, long _Offset, int _Origin)
     * }
     */
    public static FunctionDescriptor fseek$descriptor() {
        return fseek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fseek(FILE *_Stream, long _Offset, int _Origin)
     * }
     */
    public static MethodHandle fseek$handle() {
        return fseek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fseek(FILE *_Stream, long _Offset, int _Origin)
     * }
     */
    public static MemorySegment fseek$address() {
        return fseek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fseek(FILE *_Stream, long _Offset, int _Origin)
     * }
     */
    public static int fseek(MemorySegment _Stream, int _Offset, int _Origin) {
        var mh$ = fseek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseek", _Stream, _Offset, _Origin);
            }
            return (int)mh$.invokeExact(_Stream, _Offset, _Origin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fseeki64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_fseeki64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fseeki64(FILE *_Stream, long long _Offset, int _Origin)
     * }
     */
    public static FunctionDescriptor _fseeki64$descriptor() {
        return _fseeki64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fseeki64(FILE *_Stream, long long _Offset, int _Origin)
     * }
     */
    public static MethodHandle _fseeki64$handle() {
        return _fseeki64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fseeki64(FILE *_Stream, long long _Offset, int _Origin)
     * }
     */
    public static MemorySegment _fseeki64$address() {
        return _fseeki64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fseeki64(FILE *_Stream, long long _Offset, int _Origin)
     * }
     */
    public static int _fseeki64(MemorySegment _Stream, long _Offset, int _Origin) {
        var mh$ = _fseeki64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fseeki64", _Stream, _Offset, _Origin);
            }
            return (int)mh$.invokeExact(_Stream, _Offset, _Origin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ftell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long ftell(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor ftell$descriptor() {
        return ftell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long ftell(FILE *_Stream)
     * }
     */
    public static MethodHandle ftell$handle() {
        return ftell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long ftell(FILE *_Stream)
     * }
     */
    public static MemorySegment ftell$address() {
        return ftell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long ftell(FILE *_Stream)
     * }
     */
    public static int ftell(MemorySegment _Stream) {
        var mh$ = ftell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftell", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ftelli64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_ftelli64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _ftelli64(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _ftelli64$descriptor() {
        return _ftelli64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _ftelli64(FILE *_Stream)
     * }
     */
    public static MethodHandle _ftelli64$handle() {
        return _ftelli64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _ftelli64(FILE *_Stream)
     * }
     */
    public static MemorySegment _ftelli64$address() {
        return _ftelli64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _ftelli64(FILE *_Stream)
     * }
     */
    public static long _ftelli64(MemorySegment _Stream) {
        var mh$ = _ftelli64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ftelli64", _Stream);
            }
            return (long)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fwrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long fwrite(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fwrite$descriptor() {
        return fwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long fwrite(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MethodHandle fwrite$handle() {
        return fwrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long fwrite(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MemorySegment fwrite$address() {
        return fwrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long fwrite(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static long fwrite(MemorySegment _Buffer, long _ElementSize, long _ElementCount, MemorySegment _Stream) {
        var mh$ = fwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite", _Buffer, _ElementSize, _ElementCount, _Stream);
            }
            return (long)mh$.invokeExact(_Buffer, _ElementSize, _ElementCount, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("getc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getc(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor getc$descriptor() {
        return getc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getc(FILE *_Stream)
     * }
     */
    public static MethodHandle getc$handle() {
        return getc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getc(FILE *_Stream)
     * }
     */
    public static MemorySegment getc$address() {
        return getc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getc(FILE *_Stream)
     * }
     */
    public static int getc(MemorySegment _Stream) {
        var mh$ = getc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("getchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getchar()
     * }
     */
    public static FunctionDescriptor getchar$descriptor() {
        return getchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getchar()
     * }
     */
    public static MethodHandle getchar$handle() {
        return getchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getchar()
     * }
     */
    public static MemorySegment getchar$address() {
        return getchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getchar()
     * }
     */
    public static int getchar() {
        var mh$ = getchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _getmaxstdio {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_getmaxstdio");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _getmaxstdio()
     * }
     */
    public static FunctionDescriptor _getmaxstdio$descriptor() {
        return _getmaxstdio.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _getmaxstdio()
     * }
     */
    public static MethodHandle _getmaxstdio$handle() {
        return _getmaxstdio.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _getmaxstdio()
     * }
     */
    public static MemorySegment _getmaxstdio$address() {
        return _getmaxstdio.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _getmaxstdio()
     * }
     */
    public static int _getmaxstdio() {
        var mh$ = _getmaxstdio.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_getmaxstdio");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _getw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_getw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _getw(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _getw$descriptor() {
        return _getw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _getw(FILE *_Stream)
     * }
     */
    public static MethodHandle _getw$handle() {
        return _getw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _getw(FILE *_Stream)
     * }
     */
    public static MemorySegment _getw$address() {
        return _getw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _getw(FILE *_Stream)
     * }
     */
    public static int _getw(MemorySegment _Stream) {
        var mh$ = _getw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_getw", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class perror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("perror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void perror(const char *_ErrorMessage)
     * }
     */
    public static FunctionDescriptor perror$descriptor() {
        return perror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void perror(const char *_ErrorMessage)
     * }
     */
    public static MethodHandle perror$handle() {
        return perror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void perror(const char *_ErrorMessage)
     * }
     */
    public static MemorySegment perror$address() {
        return perror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void perror(const char *_ErrorMessage)
     * }
     */
    public static void perror(MemorySegment _ErrorMessage) {
        var mh$ = perror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("perror", _ErrorMessage);
            }
            mh$.invokeExact(_ErrorMessage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _pclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_pclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _pclose(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _pclose$descriptor() {
        return _pclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _pclose(FILE *_Stream)
     * }
     */
    public static MethodHandle _pclose$handle() {
        return _pclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _pclose(FILE *_Stream)
     * }
     */
    public static MemorySegment _pclose$address() {
        return _pclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _pclose(FILE *_Stream)
     * }
     */
    public static int _pclose(MemorySegment _Stream) {
        var mh$ = _pclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_pclose", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _popen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_popen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *_popen(const char *_Command, const char *_Mode)
     * }
     */
    public static FunctionDescriptor _popen$descriptor() {
        return _popen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *_popen(const char *_Command, const char *_Mode)
     * }
     */
    public static MethodHandle _popen$handle() {
        return _popen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *_popen(const char *_Command, const char *_Mode)
     * }
     */
    public static MemorySegment _popen$address() {
        return _popen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *_popen(const char *_Command, const char *_Mode)
     * }
     */
    public static MemorySegment _popen(MemorySegment _Command, MemorySegment _Mode) {
        var mh$ = _popen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_popen", _Command, _Mode);
            }
            return (MemorySegment)mh$.invokeExact(_Command, _Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("putc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putc(int _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor putc$descriptor() {
        return putc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putc(int _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle putc$handle() {
        return putc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putc(int _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment putc$address() {
        return putc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putc(int _Character, FILE *_Stream)
     * }
     */
    public static int putc(int _Character, MemorySegment _Stream) {
        var mh$ = putc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc", _Character, _Stream);
            }
            return (int)mh$.invokeExact(_Character, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("putchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putchar(int _Character)
     * }
     */
    public static FunctionDescriptor putchar$descriptor() {
        return putchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putchar(int _Character)
     * }
     */
    public static MethodHandle putchar$handle() {
        return putchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putchar(int _Character)
     * }
     */
    public static MemorySegment putchar$address() {
        return putchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putchar(int _Character)
     * }
     */
    public static int putchar(int _Character) {
        var mh$ = putchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar", _Character);
            }
            return (int)mh$.invokeExact(_Character);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class puts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("puts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int puts(const char *_Buffer)
     * }
     */
    public static FunctionDescriptor puts$descriptor() {
        return puts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int puts(const char *_Buffer)
     * }
     */
    public static MethodHandle puts$handle() {
        return puts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int puts(const char *_Buffer)
     * }
     */
    public static MemorySegment puts$address() {
        return puts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int puts(const char *_Buffer)
     * }
     */
    public static int puts(MemorySegment _Buffer) {
        var mh$ = puts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("puts", _Buffer);
            }
            return (int)mh$.invokeExact(_Buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _putw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_putw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _putw(int _Word, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _putw$descriptor() {
        return _putw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _putw(int _Word, FILE *_Stream)
     * }
     */
    public static MethodHandle _putw$handle() {
        return _putw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _putw(int _Word, FILE *_Stream)
     * }
     */
    public static MemorySegment _putw$address() {
        return _putw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _putw(int _Word, FILE *_Stream)
     * }
     */
    public static int _putw(int _Word, MemorySegment _Stream) {
        var mh$ = _putw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_putw", _Word, _Stream);
            }
            return (int)mh$.invokeExact(_Word, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int remove(const char *_FileName)
     * }
     */
    public static FunctionDescriptor remove$descriptor() {
        return remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int remove(const char *_FileName)
     * }
     */
    public static MethodHandle remove$handle() {
        return remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int remove(const char *_FileName)
     * }
     */
    public static MemorySegment remove$address() {
        return remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int remove(const char *_FileName)
     * }
     */
    public static int remove(MemorySegment _FileName) {
        var mh$ = remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remove", _FileName);
            }
            return (int)mh$.invokeExact(_FileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("rename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rename(const char *_OldFileName, const char *_NewFileName)
     * }
     */
    public static FunctionDescriptor rename$descriptor() {
        return rename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rename(const char *_OldFileName, const char *_NewFileName)
     * }
     */
    public static MethodHandle rename$handle() {
        return rename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rename(const char *_OldFileName, const char *_NewFileName)
     * }
     */
    public static MemorySegment rename$address() {
        return rename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rename(const char *_OldFileName, const char *_NewFileName)
     * }
     */
    public static int rename(MemorySegment _OldFileName, MemorySegment _NewFileName) {
        var mh$ = rename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rename", _OldFileName, _NewFileName);
            }
            return (int)mh$.invokeExact(_OldFileName, _NewFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _unlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_unlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _unlink(const char *_FileName)
     * }
     */
    public static FunctionDescriptor _unlink$descriptor() {
        return _unlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _unlink(const char *_FileName)
     * }
     */
    public static MethodHandle _unlink$handle() {
        return _unlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _unlink(const char *_FileName)
     * }
     */
    public static MemorySegment _unlink$address() {
        return _unlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _unlink(const char *_FileName)
     * }
     */
    public static int _unlink(MemorySegment _FileName) {
        var mh$ = _unlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_unlink", _FileName);
            }
            return (int)mh$.invokeExact(_FileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("unlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unlink(const char *_FileName)
     * }
     */
    public static FunctionDescriptor unlink$descriptor() {
        return unlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unlink(const char *_FileName)
     * }
     */
    public static MethodHandle unlink$handle() {
        return unlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int unlink(const char *_FileName)
     * }
     */
    public static MemorySegment unlink$address() {
        return unlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int unlink(const char *_FileName)
     * }
     */
    public static int unlink(MemorySegment _FileName) {
        var mh$ = unlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unlink", _FileName);
            }
            return (int)mh$.invokeExact(_FileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rewind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("rewind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rewind(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor rewind$descriptor() {
        return rewind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rewind(FILE *_Stream)
     * }
     */
    public static MethodHandle rewind$handle() {
        return rewind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rewind(FILE *_Stream)
     * }
     */
    public static MemorySegment rewind$address() {
        return rewind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rewind(FILE *_Stream)
     * }
     */
    public static void rewind(MemorySegment _Stream) {
        var mh$ = rewind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rewind", _Stream);
            }
            mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _rmtmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_rmtmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _rmtmp()
     * }
     */
    public static FunctionDescriptor _rmtmp$descriptor() {
        return _rmtmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _rmtmp()
     * }
     */
    public static MethodHandle _rmtmp$handle() {
        return _rmtmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _rmtmp()
     * }
     */
    public static MemorySegment _rmtmp$address() {
        return _rmtmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _rmtmp()
     * }
     */
    public static int _rmtmp() {
        var mh$ = _rmtmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_rmtmp");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("setbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setbuf(FILE *_Stream, char *_Buffer)
     * }
     */
    public static FunctionDescriptor setbuf$descriptor() {
        return setbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setbuf(FILE *_Stream, char *_Buffer)
     * }
     */
    public static MethodHandle setbuf$handle() {
        return setbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setbuf(FILE *_Stream, char *_Buffer)
     * }
     */
    public static MemorySegment setbuf$address() {
        return setbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setbuf(FILE *_Stream, char *_Buffer)
     * }
     */
    public static void setbuf(MemorySegment _Stream, MemorySegment _Buffer) {
        var mh$ = setbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuf", _Stream, _Buffer);
            }
            mh$.invokeExact(_Stream, _Buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _setmaxstdio {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_setmaxstdio");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _setmaxstdio(int _Maximum)
     * }
     */
    public static FunctionDescriptor _setmaxstdio$descriptor() {
        return _setmaxstdio.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _setmaxstdio(int _Maximum)
     * }
     */
    public static MethodHandle _setmaxstdio$handle() {
        return _setmaxstdio.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _setmaxstdio(int _Maximum)
     * }
     */
    public static MemorySegment _setmaxstdio$address() {
        return _setmaxstdio.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _setmaxstdio(int _Maximum)
     * }
     */
    public static int _setmaxstdio(int _Maximum) {
        var mh$ = _setmaxstdio.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_setmaxstdio", _Maximum);
            }
            return (int)mh$.invokeExact(_Maximum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setvbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("setvbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setvbuf(FILE *_Stream, char *_Buffer, int _Mode, size_t _Size)
     * }
     */
    public static FunctionDescriptor setvbuf$descriptor() {
        return setvbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setvbuf(FILE *_Stream, char *_Buffer, int _Mode, size_t _Size)
     * }
     */
    public static MethodHandle setvbuf$handle() {
        return setvbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setvbuf(FILE *_Stream, char *_Buffer, int _Mode, size_t _Size)
     * }
     */
    public static MemorySegment setvbuf$address() {
        return setvbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setvbuf(FILE *_Stream, char *_Buffer, int _Mode, size_t _Size)
     * }
     */
    public static int setvbuf(MemorySegment _Stream, MemorySegment _Buffer, int _Mode, long _Size) {
        var mh$ = setvbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setvbuf", _Stream, _Buffer, _Mode, _Size);
            }
            return (int)mh$.invokeExact(_Stream, _Buffer, _Mode, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _tempnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_tempnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_tempnam(const char *_DirectoryName, const char *_FilePrefix)
     * }
     */
    public static FunctionDescriptor _tempnam$descriptor() {
        return _tempnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_tempnam(const char *_DirectoryName, const char *_FilePrefix)
     * }
     */
    public static MethodHandle _tempnam$handle() {
        return _tempnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *_tempnam(const char *_DirectoryName, const char *_FilePrefix)
     * }
     */
    public static MemorySegment _tempnam$address() {
        return _tempnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *_tempnam(const char *_DirectoryName, const char *_FilePrefix)
     * }
     */
    public static MemorySegment _tempnam(MemorySegment _DirectoryName, MemorySegment _FilePrefix) {
        var mh$ = _tempnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_tempnam", _DirectoryName, _FilePrefix);
            }
            return (MemorySegment)mh$.invokeExact(_DirectoryName, _FilePrefix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("tmpfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *tmpfile()
     * }
     */
    public static FunctionDescriptor tmpfile$descriptor() {
        return tmpfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *tmpfile()
     * }
     */
    public static MethodHandle tmpfile$handle() {
        return tmpfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile$address() {
        return tmpfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile() {
        var mh$ = tmpfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpfile");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("tmpnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *tmpnam(char *_Buffer)
     * }
     */
    public static FunctionDescriptor tmpnam$descriptor() {
        return tmpnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *tmpnam(char *_Buffer)
     * }
     */
    public static MethodHandle tmpnam$handle() {
        return tmpnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *tmpnam(char *_Buffer)
     * }
     */
    public static MemorySegment tmpnam$address() {
        return tmpnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *tmpnam(char *_Buffer)
     * }
     */
    public static MemorySegment tmpnam(MemorySegment _Buffer) {
        var mh$ = tmpnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam", _Buffer);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ungetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ungetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ungetc(int _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor ungetc$descriptor() {
        return ungetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ungetc(int _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle ungetc$handle() {
        return ungetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ungetc(int _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment ungetc$address() {
        return ungetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ungetc(int _Character, FILE *_Stream)
     * }
     */
    public static int ungetc(int _Character, MemorySegment _Stream) {
        var mh$ = ungetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ungetc", _Character, _Stream);
            }
            return (int)mh$.invokeExact(_Character, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lock_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_lock_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _lock_file(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _lock_file$descriptor() {
        return _lock_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _lock_file(FILE *_Stream)
     * }
     */
    public static MethodHandle _lock_file$handle() {
        return _lock_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _lock_file(FILE *_Stream)
     * }
     */
    public static MemorySegment _lock_file$address() {
        return _lock_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _lock_file(FILE *_Stream)
     * }
     */
    public static void _lock_file(MemorySegment _Stream) {
        var mh$ = _lock_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lock_file", _Stream);
            }
            mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _unlock_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_unlock_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _unlock_file(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _unlock_file$descriptor() {
        return _unlock_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _unlock_file(FILE *_Stream)
     * }
     */
    public static MethodHandle _unlock_file$handle() {
        return _unlock_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _unlock_file(FILE *_Stream)
     * }
     */
    public static MemorySegment _unlock_file$address() {
        return _unlock_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _unlock_file(FILE *_Stream)
     * }
     */
    public static void _unlock_file(MemorySegment _Stream) {
        var mh$ = _unlock_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_unlock_file", _Stream);
            }
            mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fclose_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_fclose_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fclose_nolock(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fclose_nolock$descriptor() {
        return _fclose_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fclose_nolock(FILE *_Stream)
     * }
     */
    public static MethodHandle _fclose_nolock$handle() {
        return _fclose_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fclose_nolock(FILE *_Stream)
     * }
     */
    public static MemorySegment _fclose_nolock$address() {
        return _fclose_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fclose_nolock(FILE *_Stream)
     * }
     */
    public static int _fclose_nolock(MemorySegment _Stream) {
        var mh$ = _fclose_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fclose_nolock", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fflush_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_fflush_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fflush_nolock(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fflush_nolock$descriptor() {
        return _fflush_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fflush_nolock(FILE *_Stream)
     * }
     */
    public static MethodHandle _fflush_nolock$handle() {
        return _fflush_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fflush_nolock(FILE *_Stream)
     * }
     */
    public static MemorySegment _fflush_nolock$address() {
        return _fflush_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fflush_nolock(FILE *_Stream)
     * }
     */
    public static int _fflush_nolock(MemorySegment _Stream) {
        var mh$ = _fflush_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fflush_nolock", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fgetc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_fgetc_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fgetc_nolock(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fgetc_nolock$descriptor() {
        return _fgetc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fgetc_nolock(FILE *_Stream)
     * }
     */
    public static MethodHandle _fgetc_nolock$handle() {
        return _fgetc_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fgetc_nolock(FILE *_Stream)
     * }
     */
    public static MemorySegment _fgetc_nolock$address() {
        return _fgetc_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fgetc_nolock(FILE *_Stream)
     * }
     */
    public static int _fgetc_nolock(MemorySegment _Stream) {
        var mh$ = _fgetc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fgetc_nolock", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fputc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_fputc_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fputc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fputc_nolock$descriptor() {
        return _fputc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fputc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle _fputc_nolock$handle() {
        return _fputc_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fputc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment _fputc_nolock$address() {
        return _fputc_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fputc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static int _fputc_nolock(int _Character, MemorySegment _Stream) {
        var mh$ = _fputc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fputc_nolock", _Character, _Stream);
            }
            return (int)mh$.invokeExact(_Character, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fread_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_fread_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _fread_nolock(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fread_nolock$descriptor() {
        return _fread_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _fread_nolock(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MethodHandle _fread_nolock$handle() {
        return _fread_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _fread_nolock(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MemorySegment _fread_nolock$address() {
        return _fread_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _fread_nolock(void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static long _fread_nolock(MemorySegment _Buffer, long _ElementSize, long _ElementCount, MemorySegment _Stream) {
        var mh$ = _fread_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fread_nolock", _Buffer, _ElementSize, _ElementCount, _Stream);
            }
            return (long)mh$.invokeExact(_Buffer, _ElementSize, _ElementCount, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fread_nolock_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_fread_nolock_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _fread_nolock_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fread_nolock_s$descriptor() {
        return _fread_nolock_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _fread_nolock_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MethodHandle _fread_nolock_s$handle() {
        return _fread_nolock_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _fread_nolock_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MemorySegment _fread_nolock_s$address() {
        return _fread_nolock_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _fread_nolock_s(void *_Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static long _fread_nolock_s(MemorySegment _Buffer, long _BufferSize, long _ElementSize, long _ElementCount, MemorySegment _Stream) {
        var mh$ = _fread_nolock_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fread_nolock_s", _Buffer, _BufferSize, _ElementSize, _ElementCount, _Stream);
            }
            return (long)mh$.invokeExact(_Buffer, _BufferSize, _ElementSize, _ElementCount, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fseek_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_fseek_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fseek_nolock(FILE *_Stream, long _Offset, int _Origin)
     * }
     */
    public static FunctionDescriptor _fseek_nolock$descriptor() {
        return _fseek_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fseek_nolock(FILE *_Stream, long _Offset, int _Origin)
     * }
     */
    public static MethodHandle _fseek_nolock$handle() {
        return _fseek_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fseek_nolock(FILE *_Stream, long _Offset, int _Origin)
     * }
     */
    public static MemorySegment _fseek_nolock$address() {
        return _fseek_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fseek_nolock(FILE *_Stream, long _Offset, int _Origin)
     * }
     */
    public static int _fseek_nolock(MemorySegment _Stream, int _Offset, int _Origin) {
        var mh$ = _fseek_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fseek_nolock", _Stream, _Offset, _Origin);
            }
            return (int)mh$.invokeExact(_Stream, _Offset, _Origin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fseeki64_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_fseeki64_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _fseeki64_nolock(FILE *_Stream, long long _Offset, int _Origin)
     * }
     */
    public static FunctionDescriptor _fseeki64_nolock$descriptor() {
        return _fseeki64_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _fseeki64_nolock(FILE *_Stream, long long _Offset, int _Origin)
     * }
     */
    public static MethodHandle _fseeki64_nolock$handle() {
        return _fseeki64_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _fseeki64_nolock(FILE *_Stream, long long _Offset, int _Origin)
     * }
     */
    public static MemorySegment _fseeki64_nolock$address() {
        return _fseeki64_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _fseeki64_nolock(FILE *_Stream, long long _Offset, int _Origin)
     * }
     */
    public static int _fseeki64_nolock(MemorySegment _Stream, long _Offset, int _Origin) {
        var mh$ = _fseeki64_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fseeki64_nolock", _Stream, _Offset, _Origin);
            }
            return (int)mh$.invokeExact(_Stream, _Offset, _Origin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ftell_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_ftell_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _ftell_nolock(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _ftell_nolock$descriptor() {
        return _ftell_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _ftell_nolock(FILE *_Stream)
     * }
     */
    public static MethodHandle _ftell_nolock$handle() {
        return _ftell_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long _ftell_nolock(FILE *_Stream)
     * }
     */
    public static MemorySegment _ftell_nolock$address() {
        return _ftell_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long _ftell_nolock(FILE *_Stream)
     * }
     */
    public static int _ftell_nolock(MemorySegment _Stream) {
        var mh$ = _ftell_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ftell_nolock", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ftelli64_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_ftelli64_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _ftelli64_nolock(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _ftelli64_nolock$descriptor() {
        return _ftelli64_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _ftelli64_nolock(FILE *_Stream)
     * }
     */
    public static MethodHandle _ftelli64_nolock$handle() {
        return _ftelli64_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long _ftelli64_nolock(FILE *_Stream)
     * }
     */
    public static MemorySegment _ftelli64_nolock$address() {
        return _ftelli64_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long _ftelli64_nolock(FILE *_Stream)
     * }
     */
    public static long _ftelli64_nolock(MemorySegment _Stream) {
        var mh$ = _ftelli64_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ftelli64_nolock", _Stream);
            }
            return (long)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fwrite_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_fwrite_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _fwrite_nolock(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _fwrite_nolock$descriptor() {
        return _fwrite_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _fwrite_nolock(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MethodHandle _fwrite_nolock$handle() {
        return _fwrite_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t _fwrite_nolock(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static MemorySegment _fwrite_nolock$address() {
        return _fwrite_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t _fwrite_nolock(const void *_Buffer, size_t _ElementSize, size_t _ElementCount, FILE *_Stream)
     * }
     */
    public static long _fwrite_nolock(MemorySegment _Buffer, long _ElementSize, long _ElementCount, MemorySegment _Stream) {
        var mh$ = _fwrite_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fwrite_nolock", _Buffer, _ElementSize, _ElementCount, _Stream);
            }
            return (long)mh$.invokeExact(_Buffer, _ElementSize, _ElementCount, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _getc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_getc_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _getc_nolock(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _getc_nolock$descriptor() {
        return _getc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _getc_nolock(FILE *_Stream)
     * }
     */
    public static MethodHandle _getc_nolock$handle() {
        return _getc_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _getc_nolock(FILE *_Stream)
     * }
     */
    public static MemorySegment _getc_nolock$address() {
        return _getc_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _getc_nolock(FILE *_Stream)
     * }
     */
    public static int _getc_nolock(MemorySegment _Stream) {
        var mh$ = _getc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_getc_nolock", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _putc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_putc_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _putc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _putc_nolock$descriptor() {
        return _putc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _putc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle _putc_nolock$handle() {
        return _putc_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _putc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment _putc_nolock$address() {
        return _putc_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _putc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static int _putc_nolock(int _Character, MemorySegment _Stream) {
        var mh$ = _putc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_putc_nolock", _Character, _Stream);
            }
            return (int)mh$.invokeExact(_Character, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ungetc_nolock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_ungetc_nolock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _ungetc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor _ungetc_nolock$descriptor() {
        return _ungetc_nolock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _ungetc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static MethodHandle _ungetc_nolock$handle() {
        return _ungetc_nolock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _ungetc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static MemorySegment _ungetc_nolock$address() {
        return _ungetc_nolock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _ungetc_nolock(int _Character, FILE *_Stream)
     * }
     */
    public static int _ungetc_nolock(int _Character, MemorySegment _Stream) {
        var mh$ = _ungetc_nolock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ungetc_nolock", _Character, _Stream);
            }
            return (int)mh$.invokeExact(_Character, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p__commode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("__p__commode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *__p__commode()
     * }
     */
    public static FunctionDescriptor __p__commode$descriptor() {
        return __p__commode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *__p__commode()
     * }
     */
    public static MethodHandle __p__commode$handle() {
        return __p__commode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *__p__commode()
     * }
     */
    public static MemorySegment __p__commode$address() {
        return __p__commode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *__p__commode()
     * }
     */
    public static MemorySegment __p__commode() {
        var mh$ = __p__commode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p__commode");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vfprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("__stdio_common_vfprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vfprintf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vfprintf$descriptor() {
        return __stdio_common_vfprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vfprintf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vfprintf$handle() {
        return __stdio_common_vfprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vfprintf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vfprintf$address() {
        return __stdio_common_vfprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vfprintf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vfprintf(long _Options, MemorySegment _Stream, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vfprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vfprintf", _Options, _Stream, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Stream, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vfprintf_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("__stdio_common_vfprintf_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vfprintf_s(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vfprintf_s$descriptor() {
        return __stdio_common_vfprintf_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vfprintf_s(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vfprintf_s$handle() {
        return __stdio_common_vfprintf_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vfprintf_s(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vfprintf_s$address() {
        return __stdio_common_vfprintf_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vfprintf_s(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vfprintf_s(long _Options, MemorySegment _Stream, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vfprintf_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vfprintf_s", _Options, _Stream, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Stream, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vfprintf_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("__stdio_common_vfprintf_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vfprintf_p(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vfprintf_p$descriptor() {
        return __stdio_common_vfprintf_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vfprintf_p(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vfprintf_p$handle() {
        return __stdio_common_vfprintf_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vfprintf_p(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vfprintf_p$address() {
        return __stdio_common_vfprintf_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vfprintf_p(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vfprintf_p(long _Options, MemorySegment _Stream, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vfprintf_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vfprintf_p", _Options, _Stream, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Stream, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_printf_count_output {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_set_printf_count_output");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _set_printf_count_output(int _Value)
     * }
     */
    public static FunctionDescriptor _set_printf_count_output$descriptor() {
        return _set_printf_count_output.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _set_printf_count_output(int _Value)
     * }
     */
    public static MethodHandle _set_printf_count_output$handle() {
        return _set_printf_count_output.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _set_printf_count_output(int _Value)
     * }
     */
    public static MemorySegment _set_printf_count_output$address() {
        return _set_printf_count_output.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _set_printf_count_output(int _Value)
     * }
     */
    public static int _set_printf_count_output(int _Value) {
        var mh$ = _set_printf_count_output.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_printf_count_output", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_printf_count_output {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("_get_printf_count_output");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _get_printf_count_output()
     * }
     */
    public static FunctionDescriptor _get_printf_count_output$descriptor() {
        return _get_printf_count_output.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _get_printf_count_output()
     * }
     */
    public static MethodHandle _get_printf_count_output$handle() {
        return _get_printf_count_output.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int _get_printf_count_output()
     * }
     */
    public static MemorySegment _get_printf_count_output$address() {
        return _get_printf_count_output.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int _get_printf_count_output()
     * }
     */
    public static int _get_printf_count_output() {
        var mh$ = _get_printf_count_output.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_printf_count_output");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vfscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("__stdio_common_vfscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vfscanf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _Arglist)
     * }
     */
    public static FunctionDescriptor __stdio_common_vfscanf$descriptor() {
        return __stdio_common_vfscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vfscanf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _Arglist)
     * }
     */
    public static MethodHandle __stdio_common_vfscanf$handle() {
        return __stdio_common_vfscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vfscanf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _Arglist)
     * }
     */
    public static MemorySegment __stdio_common_vfscanf$address() {
        return __stdio_common_vfscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vfscanf(unsigned long long _Options, FILE *_Stream, const char *_Format, _locale_t _Locale, va_list _Arglist)
     * }
     */
    public static int __stdio_common_vfscanf(long _Options, MemorySegment _Stream, MemorySegment _Format, MemorySegment _Locale, MemorySegment _Arglist) {
        var mh$ = __stdio_common_vfscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vfscanf", _Options, _Stream, _Format, _Locale, _Arglist);
            }
            return (int)mh$.invokeExact(_Options, _Stream, _Format, _Locale, _Arglist);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vsprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("__stdio_common_vsprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vsprintf(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vsprintf$descriptor() {
        return __stdio_common_vsprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vsprintf(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vsprintf$handle() {
        return __stdio_common_vsprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vsprintf(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vsprintf$address() {
        return __stdio_common_vsprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vsprintf(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vsprintf(long _Options, MemorySegment _Buffer, long _BufferCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vsprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vsprintf", _Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vsprintf_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("__stdio_common_vsprintf_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vsprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vsprintf_s$descriptor() {
        return __stdio_common_vsprintf_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vsprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vsprintf_s$handle() {
        return __stdio_common_vsprintf_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vsprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vsprintf_s$address() {
        return __stdio_common_vsprintf_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vsprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vsprintf_s(long _Options, MemorySegment _Buffer, long _BufferCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vsprintf_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vsprintf_s", _Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vsnprintf_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("__stdio_common_vsnprintf_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vsnprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, size_t _MaxCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vsnprintf_s$descriptor() {
        return __stdio_common_vsnprintf_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vsnprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, size_t _MaxCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vsnprintf_s$handle() {
        return __stdio_common_vsnprintf_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vsnprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, size_t _MaxCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vsnprintf_s$address() {
        return __stdio_common_vsnprintf_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vsnprintf_s(unsigned long long _Options, char *_Buffer, size_t _BufferCount, size_t _MaxCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vsnprintf_s(long _Options, MemorySegment _Buffer, long _BufferCount, long _MaxCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vsnprintf_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vsnprintf_s", _Options, _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vsprintf_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("__stdio_common_vsprintf_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vsprintf_p(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vsprintf_p$descriptor() {
        return __stdio_common_vsprintf_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vsprintf_p(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vsprintf_p$handle() {
        return __stdio_common_vsprintf_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vsprintf_p(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vsprintf_p$address() {
        return __stdio_common_vsprintf_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vsprintf_p(unsigned long long _Options, char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vsprintf_p(long _Options, MemorySegment _Buffer, long _BufferCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vsprintf_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vsprintf_p", _Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stdio_common_vsscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("__stdio_common_vsscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __stdio_common_vsscanf(unsigned long long _Options, const char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static FunctionDescriptor __stdio_common_vsscanf$descriptor() {
        return __stdio_common_vsscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __stdio_common_vsscanf(unsigned long long _Options, const char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MethodHandle __stdio_common_vsscanf$handle() {
        return __stdio_common_vsscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __stdio_common_vsscanf(unsigned long long _Options, const char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static MemorySegment __stdio_common_vsscanf$address() {
        return __stdio_common_vsscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __stdio_common_vsscanf(unsigned long long _Options, const char *_Buffer, size_t _BufferCount, const char *_Format, _locale_t _Locale, va_list _ArgList)
     * }
     */
    public static int __stdio_common_vsscanf(long _Options, MemorySegment _Buffer, long _BufferCount, MemorySegment _Format, MemorySegment _Locale, MemorySegment _ArgList) {
        var mh$ = __stdio_common_vsscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stdio_common_vsscanf", _Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
            }
            return (int)mh$.invokeExact(_Options, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tempnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("tempnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *tempnam(const char *_Directory, const char *_FilePrefix)
     * }
     */
    public static FunctionDescriptor tempnam$descriptor() {
        return tempnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *tempnam(const char *_Directory, const char *_FilePrefix)
     * }
     */
    public static MethodHandle tempnam$handle() {
        return tempnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *tempnam(const char *_Directory, const char *_FilePrefix)
     * }
     */
    public static MemorySegment tempnam$address() {
        return tempnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *tempnam(const char *_Directory, const char *_FilePrefix)
     * }
     */
    public static MemorySegment tempnam(MemorySegment _Directory, MemorySegment _FilePrefix) {
        var mh$ = tempnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tempnam", _Directory, _FilePrefix);
            }
            return (MemorySegment)mh$.invokeExact(_Directory, _FilePrefix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcloseall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fcloseall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fcloseall()
     * }
     */
    public static FunctionDescriptor fcloseall$descriptor() {
        return fcloseall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fcloseall()
     * }
     */
    public static MethodHandle fcloseall$handle() {
        return fcloseall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fcloseall()
     * }
     */
    public static MemorySegment fcloseall$address() {
        return fcloseall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fcloseall()
     * }
     */
    public static int fcloseall() {
        var mh$ = fcloseall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcloseall");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fdopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *fdopen(int _FileHandle, const char *_Format)
     * }
     */
    public static FunctionDescriptor fdopen$descriptor() {
        return fdopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *fdopen(int _FileHandle, const char *_Format)
     * }
     */
    public static MethodHandle fdopen$handle() {
        return fdopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *fdopen(int _FileHandle, const char *_Format)
     * }
     */
    public static MemorySegment fdopen$address() {
        return fdopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *fdopen(int _FileHandle, const char *_Format)
     * }
     */
    public static MemorySegment fdopen(int _FileHandle, MemorySegment _Format) {
        var mh$ = fdopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdopen", _FileHandle, _Format);
            }
            return (MemorySegment)mh$.invokeExact(_FileHandle, _Format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fgetchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fgetchar()
     * }
     */
    public static FunctionDescriptor fgetchar$descriptor() {
        return fgetchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fgetchar()
     * }
     */
    public static MethodHandle fgetchar$handle() {
        return fgetchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fgetchar()
     * }
     */
    public static MemorySegment fgetchar$address() {
        return fgetchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fgetchar()
     * }
     */
    public static int fgetchar() {
        var mh$ = fgetchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetchar");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fileno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fileno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fileno(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor fileno$descriptor() {
        return fileno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fileno(FILE *_Stream)
     * }
     */
    public static MethodHandle fileno$handle() {
        return fileno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fileno(FILE *_Stream)
     * }
     */
    public static MemorySegment fileno$address() {
        return fileno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fileno(FILE *_Stream)
     * }
     */
    public static int fileno(MemorySegment _Stream) {
        var mh$ = fileno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flushall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("flushall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int flushall()
     * }
     */
    public static FunctionDescriptor flushall$descriptor() {
        return flushall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int flushall()
     * }
     */
    public static MethodHandle flushall$handle() {
        return flushall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int flushall()
     * }
     */
    public static MemorySegment flushall$address() {
        return flushall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int flushall()
     * }
     */
    public static int flushall() {
        var mh$ = flushall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flushall");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fputchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fputchar(int _Ch)
     * }
     */
    public static FunctionDescriptor fputchar$descriptor() {
        return fputchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fputchar(int _Ch)
     * }
     */
    public static MethodHandle fputchar$handle() {
        return fputchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fputchar(int _Ch)
     * }
     */
    public static MemorySegment fputchar$address() {
        return fputchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fputchar(int _Ch)
     * }
     */
    public static int fputchar(int _Ch) {
        var mh$ = fputchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputchar", _Ch);
            }
            return (int)mh$.invokeExact(_Ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("getw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getw(FILE *_Stream)
     * }
     */
    public static FunctionDescriptor getw$descriptor() {
        return getw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getw(FILE *_Stream)
     * }
     */
    public static MethodHandle getw$handle() {
        return getw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getw(FILE *_Stream)
     * }
     */
    public static MemorySegment getw$address() {
        return getw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getw(FILE *_Stream)
     * }
     */
    public static int getw(MemorySegment _Stream) {
        var mh$ = getw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getw", _Stream);
            }
            return (int)mh$.invokeExact(_Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("putw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putw(int _Ch, FILE *_Stream)
     * }
     */
    public static FunctionDescriptor putw$descriptor() {
        return putw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putw(int _Ch, FILE *_Stream)
     * }
     */
    public static MethodHandle putw$handle() {
        return putw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putw(int _Ch, FILE *_Stream)
     * }
     */
    public static MemorySegment putw$address() {
        return putw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putw(int _Ch, FILE *_Stream)
     * }
     */
    public static int putw(int _Ch, MemorySegment _Stream) {
        var mh$ = putw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putw", _Ch, _Stream);
            }
            return (int)mh$.invokeExact(_Ch, _Stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmtmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("rmtmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rmtmp()
     * }
     */
    public static FunctionDescriptor rmtmp$descriptor() {
        return rmtmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rmtmp()
     * }
     */
    public static MethodHandle rmtmp$handle() {
        return rmtmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rmtmp()
     * }
     */
    public static MemorySegment rmtmp$address() {
        return rmtmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rmtmp()
     * }
     */
    public static int rmtmp() {
        var mh$ = rmtmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmtmp");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_abort_callback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set_abort_callback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_abort_callback_t ggml_set_abort_callback(ggml_abort_callback_t callback)
     * }
     */
    public static FunctionDescriptor ggml_set_abort_callback$descriptor() {
        return ggml_set_abort_callback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_abort_callback_t ggml_set_abort_callback(ggml_abort_callback_t callback)
     * }
     */
    public static MethodHandle ggml_set_abort_callback$handle() {
        return ggml_set_abort_callback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_abort_callback_t ggml_set_abort_callback(ggml_abort_callback_t callback)
     * }
     */
    public static MemorySegment ggml_set_abort_callback$address() {
        return ggml_set_abort_callback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_abort_callback_t ggml_set_abort_callback(ggml_abort_callback_t callback)
     * }
     */
    public static MemorySegment ggml_set_abort_callback(MemorySegment callback) {
        var mh$ = ggml_set_abort_callback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_abort_callback", callback);
            }
            return (MemorySegment)mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern void ggml_abort(const char *file, int line, const char *fmt, ...)
     * }
     */
    public static class ggml_abort {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                WhisperCpp.C_POINTER,
                WhisperCpp.C_INT,
                WhisperCpp.C_POINTER
            );
        private static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_abort");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private ggml_abort(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern void ggml_abort(const char *file, int line, const char *fmt, ...)
         * }
         */
        public static ggml_abort makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new ggml_abort(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment file, int line, MemorySegment fmt, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("ggml_abort", file, line, fmt, x3);
                }
                 spreader.invokeExact(file, line, fmt, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }
    private static final int GGML_STATUS_ALLOC_FAILED = (int)-2L;
    /**
     * {@snippet lang=c :
     * enum ggml_status.GGML_STATUS_ALLOC_FAILED = -2
     * }
     */
    public static int GGML_STATUS_ALLOC_FAILED() {
        return GGML_STATUS_ALLOC_FAILED;
    }
    private static final int GGML_STATUS_FAILED = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum ggml_status.GGML_STATUS_FAILED = -1
     * }
     */
    public static int GGML_STATUS_FAILED() {
        return GGML_STATUS_FAILED;
    }
    private static final int GGML_STATUS_SUCCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ggml_status.GGML_STATUS_SUCCESS = 0
     * }
     */
    public static int GGML_STATUS_SUCCESS() {
        return GGML_STATUS_SUCCESS;
    }
    private static final int GGML_STATUS_ABORTED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ggml_status.GGML_STATUS_ABORTED = 1
     * }
     */
    public static int GGML_STATUS_ABORTED() {
        return GGML_STATUS_ABORTED;
    }

    private static class ggml_status_to_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_status_to_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ggml_status_to_string(enum ggml_status status)
     * }
     */
    public static FunctionDescriptor ggml_status_to_string$descriptor() {
        return ggml_status_to_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ggml_status_to_string(enum ggml_status status)
     * }
     */
    public static MethodHandle ggml_status_to_string$handle() {
        return ggml_status_to_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ggml_status_to_string(enum ggml_status status)
     * }
     */
    public static MemorySegment ggml_status_to_string$address() {
        return ggml_status_to_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ggml_status_to_string(enum ggml_status status)
     * }
     */
    public static MemorySegment ggml_status_to_string(int status) {
        var mh$ = ggml_status_to_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_status_to_string", status);
            }
            return (MemorySegment)mh$.invokeExact(status);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef uint16_t ggml_fp16_t
     * }
     */
    public static final OfShort ggml_fp16_t = WhisperCpp.C_SHORT;

    private static class ggml_fp16_to_fp32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_SHORT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_fp16_to_fp32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float ggml_fp16_to_fp32(ggml_fp16_t)
     * }
     */
    public static FunctionDescriptor ggml_fp16_to_fp32$descriptor() {
        return ggml_fp16_to_fp32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float ggml_fp16_to_fp32(ggml_fp16_t)
     * }
     */
    public static MethodHandle ggml_fp16_to_fp32$handle() {
        return ggml_fp16_to_fp32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float ggml_fp16_to_fp32(ggml_fp16_t)
     * }
     */
    public static MemorySegment ggml_fp16_to_fp32$address() {
        return ggml_fp16_to_fp32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float ggml_fp16_to_fp32(ggml_fp16_t)
     * }
     */
    public static float ggml_fp16_to_fp32(short x0) {
        var mh$ = ggml_fp16_to_fp32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_fp16_to_fp32", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_fp32_to_fp16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_SHORT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_fp32_to_fp16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_fp16_t ggml_fp32_to_fp16(float)
     * }
     */
    public static FunctionDescriptor ggml_fp32_to_fp16$descriptor() {
        return ggml_fp32_to_fp16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_fp16_t ggml_fp32_to_fp16(float)
     * }
     */
    public static MethodHandle ggml_fp32_to_fp16$handle() {
        return ggml_fp32_to_fp16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_fp16_t ggml_fp32_to_fp16(float)
     * }
     */
    public static MemorySegment ggml_fp32_to_fp16$address() {
        return ggml_fp32_to_fp16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_fp16_t ggml_fp32_to_fp16(float)
     * }
     */
    public static short ggml_fp32_to_fp16(float x0) {
        var mh$ = ggml_fp32_to_fp16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_fp32_to_fp16", x0);
            }
            return (short)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_fp16_to_fp32_row {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_fp16_to_fp32_row");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_fp16_to_fp32_row(const ggml_fp16_t *, float *, int64_t)
     * }
     */
    public static FunctionDescriptor ggml_fp16_to_fp32_row$descriptor() {
        return ggml_fp16_to_fp32_row.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_fp16_to_fp32_row(const ggml_fp16_t *, float *, int64_t)
     * }
     */
    public static MethodHandle ggml_fp16_to_fp32_row$handle() {
        return ggml_fp16_to_fp32_row.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_fp16_to_fp32_row(const ggml_fp16_t *, float *, int64_t)
     * }
     */
    public static MemorySegment ggml_fp16_to_fp32_row$address() {
        return ggml_fp16_to_fp32_row.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_fp16_to_fp32_row(const ggml_fp16_t *, float *, int64_t)
     * }
     */
    public static void ggml_fp16_to_fp32_row(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = ggml_fp16_to_fp32_row.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_fp16_to_fp32_row", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_fp32_to_fp16_row {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_fp32_to_fp16_row");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_fp32_to_fp16_row(const float *, ggml_fp16_t *, int64_t)
     * }
     */
    public static FunctionDescriptor ggml_fp32_to_fp16_row$descriptor() {
        return ggml_fp32_to_fp16_row.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_fp32_to_fp16_row(const float *, ggml_fp16_t *, int64_t)
     * }
     */
    public static MethodHandle ggml_fp32_to_fp16_row$handle() {
        return ggml_fp32_to_fp16_row.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_fp32_to_fp16_row(const float *, ggml_fp16_t *, int64_t)
     * }
     */
    public static MemorySegment ggml_fp32_to_fp16_row$address() {
        return ggml_fp32_to_fp16_row.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_fp32_to_fp16_row(const float *, ggml_fp16_t *, int64_t)
     * }
     */
    public static void ggml_fp32_to_fp16_row(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = ggml_fp32_to_fp16_row.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_fp32_to_fp16_row", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_fp32_to_bf16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ggml_bf16_t.layout(),
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_fp32_to_bf16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_bf16_t ggml_fp32_to_bf16(float)
     * }
     */
    public static FunctionDescriptor ggml_fp32_to_bf16$descriptor() {
        return ggml_fp32_to_bf16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_bf16_t ggml_fp32_to_bf16(float)
     * }
     */
    public static MethodHandle ggml_fp32_to_bf16$handle() {
        return ggml_fp32_to_bf16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_bf16_t ggml_fp32_to_bf16(float)
     * }
     */
    public static MemorySegment ggml_fp32_to_bf16$address() {
        return ggml_fp32_to_bf16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_bf16_t ggml_fp32_to_bf16(float)
     * }
     */
    public static MemorySegment ggml_fp32_to_bf16(SegmentAllocator allocator, float x0) {
        var mh$ = ggml_fp32_to_bf16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_fp32_to_bf16", allocator, x0);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_bf16_to_fp32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_FLOAT,
            ggml_bf16_t.layout()
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_bf16_to_fp32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float ggml_bf16_to_fp32(ggml_bf16_t)
     * }
     */
    public static FunctionDescriptor ggml_bf16_to_fp32$descriptor() {
        return ggml_bf16_to_fp32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float ggml_bf16_to_fp32(ggml_bf16_t)
     * }
     */
    public static MethodHandle ggml_bf16_to_fp32$handle() {
        return ggml_bf16_to_fp32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float ggml_bf16_to_fp32(ggml_bf16_t)
     * }
     */
    public static MemorySegment ggml_bf16_to_fp32$address() {
        return ggml_bf16_to_fp32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float ggml_bf16_to_fp32(ggml_bf16_t)
     * }
     */
    public static float ggml_bf16_to_fp32(MemorySegment x0) {
        var mh$ = ggml_bf16_to_fp32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_bf16_to_fp32", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_bf16_to_fp32_row {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_bf16_to_fp32_row");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_bf16_to_fp32_row(const ggml_bf16_t *, float *, int64_t)
     * }
     */
    public static FunctionDescriptor ggml_bf16_to_fp32_row$descriptor() {
        return ggml_bf16_to_fp32_row.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_bf16_to_fp32_row(const ggml_bf16_t *, float *, int64_t)
     * }
     */
    public static MethodHandle ggml_bf16_to_fp32_row$handle() {
        return ggml_bf16_to_fp32_row.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_bf16_to_fp32_row(const ggml_bf16_t *, float *, int64_t)
     * }
     */
    public static MemorySegment ggml_bf16_to_fp32_row$address() {
        return ggml_bf16_to_fp32_row.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_bf16_to_fp32_row(const ggml_bf16_t *, float *, int64_t)
     * }
     */
    public static void ggml_bf16_to_fp32_row(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = ggml_bf16_to_fp32_row.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_bf16_to_fp32_row", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_fp32_to_bf16_row_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_fp32_to_bf16_row_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_fp32_to_bf16_row_ref(const float *, ggml_bf16_t *, int64_t)
     * }
     */
    public static FunctionDescriptor ggml_fp32_to_bf16_row_ref$descriptor() {
        return ggml_fp32_to_bf16_row_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_fp32_to_bf16_row_ref(const float *, ggml_bf16_t *, int64_t)
     * }
     */
    public static MethodHandle ggml_fp32_to_bf16_row_ref$handle() {
        return ggml_fp32_to_bf16_row_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_fp32_to_bf16_row_ref(const float *, ggml_bf16_t *, int64_t)
     * }
     */
    public static MemorySegment ggml_fp32_to_bf16_row_ref$address() {
        return ggml_fp32_to_bf16_row_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_fp32_to_bf16_row_ref(const float *, ggml_bf16_t *, int64_t)
     * }
     */
    public static void ggml_fp32_to_bf16_row_ref(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = ggml_fp32_to_bf16_row_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_fp32_to_bf16_row_ref", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_fp32_to_bf16_row {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_fp32_to_bf16_row");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_fp32_to_bf16_row(const float *, ggml_bf16_t *, int64_t)
     * }
     */
    public static FunctionDescriptor ggml_fp32_to_bf16_row$descriptor() {
        return ggml_fp32_to_bf16_row.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_fp32_to_bf16_row(const float *, ggml_bf16_t *, int64_t)
     * }
     */
    public static MethodHandle ggml_fp32_to_bf16_row$handle() {
        return ggml_fp32_to_bf16_row.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_fp32_to_bf16_row(const float *, ggml_bf16_t *, int64_t)
     * }
     */
    public static MemorySegment ggml_fp32_to_bf16_row$address() {
        return ggml_fp32_to_bf16_row.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_fp32_to_bf16_row(const float *, ggml_bf16_t *, int64_t)
     * }
     */
    public static void ggml_fp32_to_bf16_row(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = ggml_fp32_to_bf16_row.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_fp32_to_bf16_row", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GGML_TYPE_F32 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_F32 = 0
     * }
     */
    public static int GGML_TYPE_F32() {
        return GGML_TYPE_F32;
    }
    private static final int GGML_TYPE_F16 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_F16 = 1
     * }
     */
    public static int GGML_TYPE_F16() {
        return GGML_TYPE_F16;
    }
    private static final int GGML_TYPE_Q4_0 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_Q4_0 = 2
     * }
     */
    public static int GGML_TYPE_Q4_0() {
        return GGML_TYPE_Q4_0;
    }
    private static final int GGML_TYPE_Q4_1 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_Q4_1 = 3
     * }
     */
    public static int GGML_TYPE_Q4_1() {
        return GGML_TYPE_Q4_1;
    }
    private static final int GGML_TYPE_Q5_0 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_Q5_0 = 6
     * }
     */
    public static int GGML_TYPE_Q5_0() {
        return GGML_TYPE_Q5_0;
    }
    private static final int GGML_TYPE_Q5_1 = (int)7L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_Q5_1 = 7
     * }
     */
    public static int GGML_TYPE_Q5_1() {
        return GGML_TYPE_Q5_1;
    }
    private static final int GGML_TYPE_Q8_0 = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_Q8_0 = 8
     * }
     */
    public static int GGML_TYPE_Q8_0() {
        return GGML_TYPE_Q8_0;
    }
    private static final int GGML_TYPE_Q8_1 = (int)9L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_Q8_1 = 9
     * }
     */
    public static int GGML_TYPE_Q8_1() {
        return GGML_TYPE_Q8_1;
    }
    private static final int GGML_TYPE_Q2_K = (int)10L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_Q2_K = 10
     * }
     */
    public static int GGML_TYPE_Q2_K() {
        return GGML_TYPE_Q2_K;
    }
    private static final int GGML_TYPE_Q3_K = (int)11L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_Q3_K = 11
     * }
     */
    public static int GGML_TYPE_Q3_K() {
        return GGML_TYPE_Q3_K;
    }
    private static final int GGML_TYPE_Q4_K = (int)12L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_Q4_K = 12
     * }
     */
    public static int GGML_TYPE_Q4_K() {
        return GGML_TYPE_Q4_K;
    }
    private static final int GGML_TYPE_Q5_K = (int)13L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_Q5_K = 13
     * }
     */
    public static int GGML_TYPE_Q5_K() {
        return GGML_TYPE_Q5_K;
    }
    private static final int GGML_TYPE_Q6_K = (int)14L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_Q6_K = 14
     * }
     */
    public static int GGML_TYPE_Q6_K() {
        return GGML_TYPE_Q6_K;
    }
    private static final int GGML_TYPE_Q8_K = (int)15L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_Q8_K = 15
     * }
     */
    public static int GGML_TYPE_Q8_K() {
        return GGML_TYPE_Q8_K;
    }
    private static final int GGML_TYPE_IQ2_XXS = (int)16L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_IQ2_XXS = 16
     * }
     */
    public static int GGML_TYPE_IQ2_XXS() {
        return GGML_TYPE_IQ2_XXS;
    }
    private static final int GGML_TYPE_IQ2_XS = (int)17L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_IQ2_XS = 17
     * }
     */
    public static int GGML_TYPE_IQ2_XS() {
        return GGML_TYPE_IQ2_XS;
    }
    private static final int GGML_TYPE_IQ3_XXS = (int)18L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_IQ3_XXS = 18
     * }
     */
    public static int GGML_TYPE_IQ3_XXS() {
        return GGML_TYPE_IQ3_XXS;
    }
    private static final int GGML_TYPE_IQ1_S = (int)19L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_IQ1_S = 19
     * }
     */
    public static int GGML_TYPE_IQ1_S() {
        return GGML_TYPE_IQ1_S;
    }
    private static final int GGML_TYPE_IQ4_NL = (int)20L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_IQ4_NL = 20
     * }
     */
    public static int GGML_TYPE_IQ4_NL() {
        return GGML_TYPE_IQ4_NL;
    }
    private static final int GGML_TYPE_IQ3_S = (int)21L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_IQ3_S = 21
     * }
     */
    public static int GGML_TYPE_IQ3_S() {
        return GGML_TYPE_IQ3_S;
    }
    private static final int GGML_TYPE_IQ2_S = (int)22L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_IQ2_S = 22
     * }
     */
    public static int GGML_TYPE_IQ2_S() {
        return GGML_TYPE_IQ2_S;
    }
    private static final int GGML_TYPE_IQ4_XS = (int)23L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_IQ4_XS = 23
     * }
     */
    public static int GGML_TYPE_IQ4_XS() {
        return GGML_TYPE_IQ4_XS;
    }
    private static final int GGML_TYPE_I8 = (int)24L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_I8 = 24
     * }
     */
    public static int GGML_TYPE_I8() {
        return GGML_TYPE_I8;
    }
    private static final int GGML_TYPE_I16 = (int)25L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_I16 = 25
     * }
     */
    public static int GGML_TYPE_I16() {
        return GGML_TYPE_I16;
    }
    private static final int GGML_TYPE_I32 = (int)26L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_I32 = 26
     * }
     */
    public static int GGML_TYPE_I32() {
        return GGML_TYPE_I32;
    }
    private static final int GGML_TYPE_I64 = (int)27L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_I64 = 27
     * }
     */
    public static int GGML_TYPE_I64() {
        return GGML_TYPE_I64;
    }
    private static final int GGML_TYPE_F64 = (int)28L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_F64 = 28
     * }
     */
    public static int GGML_TYPE_F64() {
        return GGML_TYPE_F64;
    }
    private static final int GGML_TYPE_IQ1_M = (int)29L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_IQ1_M = 29
     * }
     */
    public static int GGML_TYPE_IQ1_M() {
        return GGML_TYPE_IQ1_M;
    }
    private static final int GGML_TYPE_BF16 = (int)30L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_BF16 = 30
     * }
     */
    public static int GGML_TYPE_BF16() {
        return GGML_TYPE_BF16;
    }
    private static final int GGML_TYPE_TQ1_0 = (int)34L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_TQ1_0 = 34
     * }
     */
    public static int GGML_TYPE_TQ1_0() {
        return GGML_TYPE_TQ1_0;
    }
    private static final int GGML_TYPE_TQ2_0 = (int)35L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_TQ2_0 = 35
     * }
     */
    public static int GGML_TYPE_TQ2_0() {
        return GGML_TYPE_TQ2_0;
    }
    private static final int GGML_TYPE_COUNT = (int)39L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_COUNT = 39
     * }
     */
    public static int GGML_TYPE_COUNT() {
        return GGML_TYPE_COUNT;
    }
    private static final int GGML_PREC_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ggml_prec.GGML_PREC_DEFAULT = 0
     * }
     */
    public static int GGML_PREC_DEFAULT() {
        return GGML_PREC_DEFAULT;
    }
    private static final int GGML_PREC_F32 = (int)10L;
    /**
     * {@snippet lang=c :
     * enum ggml_prec.GGML_PREC_F32 = 10
     * }
     */
    public static int GGML_PREC_F32() {
        return GGML_PREC_F32;
    }
    private static final int GGML_FTYPE_UNKNOWN = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_UNKNOWN = -1
     * }
     */
    public static int GGML_FTYPE_UNKNOWN() {
        return GGML_FTYPE_UNKNOWN;
    }
    private static final int GGML_FTYPE_ALL_F32 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_ALL_F32 = 0
     * }
     */
    public static int GGML_FTYPE_ALL_F32() {
        return GGML_FTYPE_ALL_F32;
    }
    private static final int GGML_FTYPE_MOSTLY_F16 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_F16 = 1
     * }
     */
    public static int GGML_FTYPE_MOSTLY_F16() {
        return GGML_FTYPE_MOSTLY_F16;
    }
    private static final int GGML_FTYPE_MOSTLY_Q4_0 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_Q4_0 = 2
     * }
     */
    public static int GGML_FTYPE_MOSTLY_Q4_0() {
        return GGML_FTYPE_MOSTLY_Q4_0;
    }
    private static final int GGML_FTYPE_MOSTLY_Q4_1 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_Q4_1 = 3
     * }
     */
    public static int GGML_FTYPE_MOSTLY_Q4_1() {
        return GGML_FTYPE_MOSTLY_Q4_1;
    }
    private static final int GGML_FTYPE_MOSTLY_Q4_1_SOME_F16 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_Q4_1_SOME_F16 = 4
     * }
     */
    public static int GGML_FTYPE_MOSTLY_Q4_1_SOME_F16() {
        return GGML_FTYPE_MOSTLY_Q4_1_SOME_F16;
    }
    private static final int GGML_FTYPE_MOSTLY_Q8_0 = (int)7L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_Q8_0 = 7
     * }
     */
    public static int GGML_FTYPE_MOSTLY_Q8_0() {
        return GGML_FTYPE_MOSTLY_Q8_0;
    }
    private static final int GGML_FTYPE_MOSTLY_Q5_0 = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_Q5_0 = 8
     * }
     */
    public static int GGML_FTYPE_MOSTLY_Q5_0() {
        return GGML_FTYPE_MOSTLY_Q5_0;
    }
    private static final int GGML_FTYPE_MOSTLY_Q5_1 = (int)9L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_Q5_1 = 9
     * }
     */
    public static int GGML_FTYPE_MOSTLY_Q5_1() {
        return GGML_FTYPE_MOSTLY_Q5_1;
    }
    private static final int GGML_FTYPE_MOSTLY_Q2_K = (int)10L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_Q2_K = 10
     * }
     */
    public static int GGML_FTYPE_MOSTLY_Q2_K() {
        return GGML_FTYPE_MOSTLY_Q2_K;
    }
    private static final int GGML_FTYPE_MOSTLY_Q3_K = (int)11L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_Q3_K = 11
     * }
     */
    public static int GGML_FTYPE_MOSTLY_Q3_K() {
        return GGML_FTYPE_MOSTLY_Q3_K;
    }
    private static final int GGML_FTYPE_MOSTLY_Q4_K = (int)12L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_Q4_K = 12
     * }
     */
    public static int GGML_FTYPE_MOSTLY_Q4_K() {
        return GGML_FTYPE_MOSTLY_Q4_K;
    }
    private static final int GGML_FTYPE_MOSTLY_Q5_K = (int)13L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_Q5_K = 13
     * }
     */
    public static int GGML_FTYPE_MOSTLY_Q5_K() {
        return GGML_FTYPE_MOSTLY_Q5_K;
    }
    private static final int GGML_FTYPE_MOSTLY_Q6_K = (int)14L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_Q6_K = 14
     * }
     */
    public static int GGML_FTYPE_MOSTLY_Q6_K() {
        return GGML_FTYPE_MOSTLY_Q6_K;
    }
    private static final int GGML_FTYPE_MOSTLY_IQ2_XXS = (int)15L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_IQ2_XXS = 15
     * }
     */
    public static int GGML_FTYPE_MOSTLY_IQ2_XXS() {
        return GGML_FTYPE_MOSTLY_IQ2_XXS;
    }
    private static final int GGML_FTYPE_MOSTLY_IQ2_XS = (int)16L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_IQ2_XS = 16
     * }
     */
    public static int GGML_FTYPE_MOSTLY_IQ2_XS() {
        return GGML_FTYPE_MOSTLY_IQ2_XS;
    }
    private static final int GGML_FTYPE_MOSTLY_IQ3_XXS = (int)17L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_IQ3_XXS = 17
     * }
     */
    public static int GGML_FTYPE_MOSTLY_IQ3_XXS() {
        return GGML_FTYPE_MOSTLY_IQ3_XXS;
    }
    private static final int GGML_FTYPE_MOSTLY_IQ1_S = (int)18L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_IQ1_S = 18
     * }
     */
    public static int GGML_FTYPE_MOSTLY_IQ1_S() {
        return GGML_FTYPE_MOSTLY_IQ1_S;
    }
    private static final int GGML_FTYPE_MOSTLY_IQ4_NL = (int)19L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_IQ4_NL = 19
     * }
     */
    public static int GGML_FTYPE_MOSTLY_IQ4_NL() {
        return GGML_FTYPE_MOSTLY_IQ4_NL;
    }
    private static final int GGML_FTYPE_MOSTLY_IQ3_S = (int)20L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_IQ3_S = 20
     * }
     */
    public static int GGML_FTYPE_MOSTLY_IQ3_S() {
        return GGML_FTYPE_MOSTLY_IQ3_S;
    }
    private static final int GGML_FTYPE_MOSTLY_IQ2_S = (int)21L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_IQ2_S = 21
     * }
     */
    public static int GGML_FTYPE_MOSTLY_IQ2_S() {
        return GGML_FTYPE_MOSTLY_IQ2_S;
    }
    private static final int GGML_FTYPE_MOSTLY_IQ4_XS = (int)22L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_IQ4_XS = 22
     * }
     */
    public static int GGML_FTYPE_MOSTLY_IQ4_XS() {
        return GGML_FTYPE_MOSTLY_IQ4_XS;
    }
    private static final int GGML_FTYPE_MOSTLY_IQ1_M = (int)23L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_IQ1_M = 23
     * }
     */
    public static int GGML_FTYPE_MOSTLY_IQ1_M() {
        return GGML_FTYPE_MOSTLY_IQ1_M;
    }
    private static final int GGML_FTYPE_MOSTLY_BF16 = (int)24L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_BF16 = 24
     * }
     */
    public static int GGML_FTYPE_MOSTLY_BF16() {
        return GGML_FTYPE_MOSTLY_BF16;
    }
    private static final int GGML_OP_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_NONE = 0
     * }
     */
    public static int GGML_OP_NONE() {
        return GGML_OP_NONE;
    }
    private static final int GGML_OP_DUP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_DUP = 1
     * }
     */
    public static int GGML_OP_DUP() {
        return GGML_OP_DUP;
    }
    private static final int GGML_OP_ADD = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_ADD = 2
     * }
     */
    public static int GGML_OP_ADD() {
        return GGML_OP_ADD;
    }
    private static final int GGML_OP_ADD1 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_ADD1 = 3
     * }
     */
    public static int GGML_OP_ADD1() {
        return GGML_OP_ADD1;
    }
    private static final int GGML_OP_ACC = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_ACC = 4
     * }
     */
    public static int GGML_OP_ACC() {
        return GGML_OP_ACC;
    }
    private static final int GGML_OP_SUB = (int)5L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_SUB = 5
     * }
     */
    public static int GGML_OP_SUB() {
        return GGML_OP_SUB;
    }
    private static final int GGML_OP_MUL = (int)6L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_MUL = 6
     * }
     */
    public static int GGML_OP_MUL() {
        return GGML_OP_MUL;
    }
    private static final int GGML_OP_DIV = (int)7L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_DIV = 7
     * }
     */
    public static int GGML_OP_DIV() {
        return GGML_OP_DIV;
    }
    private static final int GGML_OP_SQR = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_SQR = 8
     * }
     */
    public static int GGML_OP_SQR() {
        return GGML_OP_SQR;
    }
    private static final int GGML_OP_SQRT = (int)9L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_SQRT = 9
     * }
     */
    public static int GGML_OP_SQRT() {
        return GGML_OP_SQRT;
    }
    private static final int GGML_OP_LOG = (int)10L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_LOG = 10
     * }
     */
    public static int GGML_OP_LOG() {
        return GGML_OP_LOG;
    }
    private static final int GGML_OP_SIN = (int)11L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_SIN = 11
     * }
     */
    public static int GGML_OP_SIN() {
        return GGML_OP_SIN;
    }
    private static final int GGML_OP_COS = (int)12L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_COS = 12
     * }
     */
    public static int GGML_OP_COS() {
        return GGML_OP_COS;
    }
    private static final int GGML_OP_SUM = (int)13L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_SUM = 13
     * }
     */
    public static int GGML_OP_SUM() {
        return GGML_OP_SUM;
    }
    private static final int GGML_OP_SUM_ROWS = (int)14L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_SUM_ROWS = 14
     * }
     */
    public static int GGML_OP_SUM_ROWS() {
        return GGML_OP_SUM_ROWS;
    }
    private static final int GGML_OP_MEAN = (int)15L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_MEAN = 15
     * }
     */
    public static int GGML_OP_MEAN() {
        return GGML_OP_MEAN;
    }
    private static final int GGML_OP_ARGMAX = (int)16L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_ARGMAX = 16
     * }
     */
    public static int GGML_OP_ARGMAX() {
        return GGML_OP_ARGMAX;
    }
    private static final int GGML_OP_COUNT_EQUAL = (int)17L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_COUNT_EQUAL = 17
     * }
     */
    public static int GGML_OP_COUNT_EQUAL() {
        return GGML_OP_COUNT_EQUAL;
    }
    private static final int GGML_OP_REPEAT = (int)18L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_REPEAT = 18
     * }
     */
    public static int GGML_OP_REPEAT() {
        return GGML_OP_REPEAT;
    }
    private static final int GGML_OP_REPEAT_BACK = (int)19L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_REPEAT_BACK = 19
     * }
     */
    public static int GGML_OP_REPEAT_BACK() {
        return GGML_OP_REPEAT_BACK;
    }
    private static final int GGML_OP_CONCAT = (int)20L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_CONCAT = 20
     * }
     */
    public static int GGML_OP_CONCAT() {
        return GGML_OP_CONCAT;
    }
    private static final int GGML_OP_SILU_BACK = (int)21L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_SILU_BACK = 21
     * }
     */
    public static int GGML_OP_SILU_BACK() {
        return GGML_OP_SILU_BACK;
    }
    private static final int GGML_OP_NORM = (int)22L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_NORM = 22
     * }
     */
    public static int GGML_OP_NORM() {
        return GGML_OP_NORM;
    }
    private static final int GGML_OP_RMS_NORM = (int)23L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_RMS_NORM = 23
     * }
     */
    public static int GGML_OP_RMS_NORM() {
        return GGML_OP_RMS_NORM;
    }
    private static final int GGML_OP_RMS_NORM_BACK = (int)24L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_RMS_NORM_BACK = 24
     * }
     */
    public static int GGML_OP_RMS_NORM_BACK() {
        return GGML_OP_RMS_NORM_BACK;
    }
    private static final int GGML_OP_GROUP_NORM = (int)25L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_GROUP_NORM = 25
     * }
     */
    public static int GGML_OP_GROUP_NORM() {
        return GGML_OP_GROUP_NORM;
    }
    private static final int GGML_OP_L2_NORM = (int)26L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_L2_NORM = 26
     * }
     */
    public static int GGML_OP_L2_NORM() {
        return GGML_OP_L2_NORM;
    }
    private static final int GGML_OP_MUL_MAT = (int)27L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_MUL_MAT = 27
     * }
     */
    public static int GGML_OP_MUL_MAT() {
        return GGML_OP_MUL_MAT;
    }
    private static final int GGML_OP_MUL_MAT_ID = (int)28L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_MUL_MAT_ID = 28
     * }
     */
    public static int GGML_OP_MUL_MAT_ID() {
        return GGML_OP_MUL_MAT_ID;
    }
    private static final int GGML_OP_OUT_PROD = (int)29L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_OUT_PROD = 29
     * }
     */
    public static int GGML_OP_OUT_PROD() {
        return GGML_OP_OUT_PROD;
    }
    private static final int GGML_OP_SCALE = (int)30L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_SCALE = 30
     * }
     */
    public static int GGML_OP_SCALE() {
        return GGML_OP_SCALE;
    }
    private static final int GGML_OP_SET = (int)31L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_SET = 31
     * }
     */
    public static int GGML_OP_SET() {
        return GGML_OP_SET;
    }
    private static final int GGML_OP_CPY = (int)32L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_CPY = 32
     * }
     */
    public static int GGML_OP_CPY() {
        return GGML_OP_CPY;
    }
    private static final int GGML_OP_CONT = (int)33L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_CONT = 33
     * }
     */
    public static int GGML_OP_CONT() {
        return GGML_OP_CONT;
    }
    private static final int GGML_OP_RESHAPE = (int)34L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_RESHAPE = 34
     * }
     */
    public static int GGML_OP_RESHAPE() {
        return GGML_OP_RESHAPE;
    }
    private static final int GGML_OP_VIEW = (int)35L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_VIEW = 35
     * }
     */
    public static int GGML_OP_VIEW() {
        return GGML_OP_VIEW;
    }
    private static final int GGML_OP_PERMUTE = (int)36L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_PERMUTE = 36
     * }
     */
    public static int GGML_OP_PERMUTE() {
        return GGML_OP_PERMUTE;
    }
    private static final int GGML_OP_TRANSPOSE = (int)37L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_TRANSPOSE = 37
     * }
     */
    public static int GGML_OP_TRANSPOSE() {
        return GGML_OP_TRANSPOSE;
    }
    private static final int GGML_OP_GET_ROWS = (int)38L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_GET_ROWS = 38
     * }
     */
    public static int GGML_OP_GET_ROWS() {
        return GGML_OP_GET_ROWS;
    }
    private static final int GGML_OP_GET_ROWS_BACK = (int)39L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_GET_ROWS_BACK = 39
     * }
     */
    public static int GGML_OP_GET_ROWS_BACK() {
        return GGML_OP_GET_ROWS_BACK;
    }
    private static final int GGML_OP_SET_ROWS = (int)40L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_SET_ROWS = 40
     * }
     */
    public static int GGML_OP_SET_ROWS() {
        return GGML_OP_SET_ROWS;
    }
    private static final int GGML_OP_DIAG = (int)41L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_DIAG = 41
     * }
     */
    public static int GGML_OP_DIAG() {
        return GGML_OP_DIAG;
    }
    private static final int GGML_OP_DIAG_MASK_INF = (int)42L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_DIAG_MASK_INF = 42
     * }
     */
    public static int GGML_OP_DIAG_MASK_INF() {
        return GGML_OP_DIAG_MASK_INF;
    }
    private static final int GGML_OP_DIAG_MASK_ZERO = (int)43L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_DIAG_MASK_ZERO = 43
     * }
     */
    public static int GGML_OP_DIAG_MASK_ZERO() {
        return GGML_OP_DIAG_MASK_ZERO;
    }
    private static final int GGML_OP_SOFT_MAX = (int)44L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_SOFT_MAX = 44
     * }
     */
    public static int GGML_OP_SOFT_MAX() {
        return GGML_OP_SOFT_MAX;
    }
    private static final int GGML_OP_SOFT_MAX_BACK = (int)45L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_SOFT_MAX_BACK = 45
     * }
     */
    public static int GGML_OP_SOFT_MAX_BACK() {
        return GGML_OP_SOFT_MAX_BACK;
    }
    private static final int GGML_OP_ROPE = (int)46L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_ROPE = 46
     * }
     */
    public static int GGML_OP_ROPE() {
        return GGML_OP_ROPE;
    }
    private static final int GGML_OP_ROPE_BACK = (int)47L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_ROPE_BACK = 47
     * }
     */
    public static int GGML_OP_ROPE_BACK() {
        return GGML_OP_ROPE_BACK;
    }
    private static final int GGML_OP_CLAMP = (int)48L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_CLAMP = 48
     * }
     */
    public static int GGML_OP_CLAMP() {
        return GGML_OP_CLAMP;
    }
    private static final int GGML_OP_CONV_TRANSPOSE_1D = (int)49L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_CONV_TRANSPOSE_1D = 49
     * }
     */
    public static int GGML_OP_CONV_TRANSPOSE_1D() {
        return GGML_OP_CONV_TRANSPOSE_1D;
    }
    private static final int GGML_OP_IM2COL = (int)50L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_IM2COL = 50
     * }
     */
    public static int GGML_OP_IM2COL() {
        return GGML_OP_IM2COL;
    }
    private static final int GGML_OP_IM2COL_BACK = (int)51L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_IM2COL_BACK = 51
     * }
     */
    public static int GGML_OP_IM2COL_BACK() {
        return GGML_OP_IM2COL_BACK;
    }
    private static final int GGML_OP_CONV_2D = (int)52L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_CONV_2D = 52
     * }
     */
    public static int GGML_OP_CONV_2D() {
        return GGML_OP_CONV_2D;
    }
    private static final int GGML_OP_CONV_2D_DW = (int)53L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_CONV_2D_DW = 53
     * }
     */
    public static int GGML_OP_CONV_2D_DW() {
        return GGML_OP_CONV_2D_DW;
    }
    private static final int GGML_OP_CONV_TRANSPOSE_2D = (int)54L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_CONV_TRANSPOSE_2D = 54
     * }
     */
    public static int GGML_OP_CONV_TRANSPOSE_2D() {
        return GGML_OP_CONV_TRANSPOSE_2D;
    }
    private static final int GGML_OP_POOL_1D = (int)55L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_POOL_1D = 55
     * }
     */
    public static int GGML_OP_POOL_1D() {
        return GGML_OP_POOL_1D;
    }
    private static final int GGML_OP_POOL_2D = (int)56L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_POOL_2D = 56
     * }
     */
    public static int GGML_OP_POOL_2D() {
        return GGML_OP_POOL_2D;
    }
    private static final int GGML_OP_POOL_2D_BACK = (int)57L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_POOL_2D_BACK = 57
     * }
     */
    public static int GGML_OP_POOL_2D_BACK() {
        return GGML_OP_POOL_2D_BACK;
    }
    private static final int GGML_OP_UPSCALE = (int)58L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_UPSCALE = 58
     * }
     */
    public static int GGML_OP_UPSCALE() {
        return GGML_OP_UPSCALE;
    }
    private static final int GGML_OP_PAD = (int)59L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_PAD = 59
     * }
     */
    public static int GGML_OP_PAD() {
        return GGML_OP_PAD;
    }
    private static final int GGML_OP_PAD_REFLECT_1D = (int)60L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_PAD_REFLECT_1D = 60
     * }
     */
    public static int GGML_OP_PAD_REFLECT_1D() {
        return GGML_OP_PAD_REFLECT_1D;
    }
    private static final int GGML_OP_ROLL = (int)61L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_ROLL = 61
     * }
     */
    public static int GGML_OP_ROLL() {
        return GGML_OP_ROLL;
    }
    private static final int GGML_OP_ARANGE = (int)62L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_ARANGE = 62
     * }
     */
    public static int GGML_OP_ARANGE() {
        return GGML_OP_ARANGE;
    }
    private static final int GGML_OP_TIMESTEP_EMBEDDING = (int)63L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_TIMESTEP_EMBEDDING = 63
     * }
     */
    public static int GGML_OP_TIMESTEP_EMBEDDING() {
        return GGML_OP_TIMESTEP_EMBEDDING;
    }
    private static final int GGML_OP_ARGSORT = (int)64L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_ARGSORT = 64
     * }
     */
    public static int GGML_OP_ARGSORT() {
        return GGML_OP_ARGSORT;
    }
    private static final int GGML_OP_LEAKY_RELU = (int)65L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_LEAKY_RELU = 65
     * }
     */
    public static int GGML_OP_LEAKY_RELU() {
        return GGML_OP_LEAKY_RELU;
    }
    private static final int GGML_OP_FLASH_ATTN_EXT = (int)66L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_FLASH_ATTN_EXT = 66
     * }
     */
    public static int GGML_OP_FLASH_ATTN_EXT() {
        return GGML_OP_FLASH_ATTN_EXT;
    }
    private static final int GGML_OP_FLASH_ATTN_BACK = (int)67L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_FLASH_ATTN_BACK = 67
     * }
     */
    public static int GGML_OP_FLASH_ATTN_BACK() {
        return GGML_OP_FLASH_ATTN_BACK;
    }
    private static final int GGML_OP_SSM_CONV = (int)68L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_SSM_CONV = 68
     * }
     */
    public static int GGML_OP_SSM_CONV() {
        return GGML_OP_SSM_CONV;
    }
    private static final int GGML_OP_SSM_SCAN = (int)69L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_SSM_SCAN = 69
     * }
     */
    public static int GGML_OP_SSM_SCAN() {
        return GGML_OP_SSM_SCAN;
    }
    private static final int GGML_OP_WIN_PART = (int)70L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_WIN_PART = 70
     * }
     */
    public static int GGML_OP_WIN_PART() {
        return GGML_OP_WIN_PART;
    }
    private static final int GGML_OP_WIN_UNPART = (int)71L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_WIN_UNPART = 71
     * }
     */
    public static int GGML_OP_WIN_UNPART() {
        return GGML_OP_WIN_UNPART;
    }
    private static final int GGML_OP_GET_REL_POS = (int)72L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_GET_REL_POS = 72
     * }
     */
    public static int GGML_OP_GET_REL_POS() {
        return GGML_OP_GET_REL_POS;
    }
    private static final int GGML_OP_ADD_REL_POS = (int)73L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_ADD_REL_POS = 73
     * }
     */
    public static int GGML_OP_ADD_REL_POS() {
        return GGML_OP_ADD_REL_POS;
    }
    private static final int GGML_OP_RWKV_WKV6 = (int)74L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_RWKV_WKV6 = 74
     * }
     */
    public static int GGML_OP_RWKV_WKV6() {
        return GGML_OP_RWKV_WKV6;
    }
    private static final int GGML_OP_GATED_LINEAR_ATTN = (int)75L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_GATED_LINEAR_ATTN = 75
     * }
     */
    public static int GGML_OP_GATED_LINEAR_ATTN() {
        return GGML_OP_GATED_LINEAR_ATTN;
    }
    private static final int GGML_OP_RWKV_WKV7 = (int)76L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_RWKV_WKV7 = 76
     * }
     */
    public static int GGML_OP_RWKV_WKV7() {
        return GGML_OP_RWKV_WKV7;
    }
    private static final int GGML_OP_UNARY = (int)77L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_UNARY = 77
     * }
     */
    public static int GGML_OP_UNARY() {
        return GGML_OP_UNARY;
    }
    private static final int GGML_OP_MAP_CUSTOM1 = (int)78L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_MAP_CUSTOM1 = 78
     * }
     */
    public static int GGML_OP_MAP_CUSTOM1() {
        return GGML_OP_MAP_CUSTOM1;
    }
    private static final int GGML_OP_MAP_CUSTOM2 = (int)79L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_MAP_CUSTOM2 = 79
     * }
     */
    public static int GGML_OP_MAP_CUSTOM2() {
        return GGML_OP_MAP_CUSTOM2;
    }
    private static final int GGML_OP_MAP_CUSTOM3 = (int)80L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_MAP_CUSTOM3 = 80
     * }
     */
    public static int GGML_OP_MAP_CUSTOM3() {
        return GGML_OP_MAP_CUSTOM3;
    }
    private static final int GGML_OP_CUSTOM = (int)81L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_CUSTOM = 81
     * }
     */
    public static int GGML_OP_CUSTOM() {
        return GGML_OP_CUSTOM;
    }
    private static final int GGML_OP_CROSS_ENTROPY_LOSS = (int)82L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_CROSS_ENTROPY_LOSS = 82
     * }
     */
    public static int GGML_OP_CROSS_ENTROPY_LOSS() {
        return GGML_OP_CROSS_ENTROPY_LOSS;
    }
    private static final int GGML_OP_CROSS_ENTROPY_LOSS_BACK = (int)83L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_CROSS_ENTROPY_LOSS_BACK = 83
     * }
     */
    public static int GGML_OP_CROSS_ENTROPY_LOSS_BACK() {
        return GGML_OP_CROSS_ENTROPY_LOSS_BACK;
    }
    private static final int GGML_OP_OPT_STEP_ADAMW = (int)84L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_OPT_STEP_ADAMW = 84
     * }
     */
    public static int GGML_OP_OPT_STEP_ADAMW() {
        return GGML_OP_OPT_STEP_ADAMW;
    }
    private static final int GGML_OP_GLU = (int)85L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_GLU = 85
     * }
     */
    public static int GGML_OP_GLU() {
        return GGML_OP_GLU;
    }
    private static final int GGML_OP_COUNT = (int)86L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_COUNT = 86
     * }
     */
    public static int GGML_OP_COUNT() {
        return GGML_OP_COUNT;
    }
    private static final int GGML_UNARY_OP_ABS = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ggml_unary_op.GGML_UNARY_OP_ABS = 0
     * }
     */
    public static int GGML_UNARY_OP_ABS() {
        return GGML_UNARY_OP_ABS;
    }
    private static final int GGML_UNARY_OP_SGN = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ggml_unary_op.GGML_UNARY_OP_SGN = 1
     * }
     */
    public static int GGML_UNARY_OP_SGN() {
        return GGML_UNARY_OP_SGN;
    }
    private static final int GGML_UNARY_OP_NEG = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ggml_unary_op.GGML_UNARY_OP_NEG = 2
     * }
     */
    public static int GGML_UNARY_OP_NEG() {
        return GGML_UNARY_OP_NEG;
    }
    private static final int GGML_UNARY_OP_STEP = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ggml_unary_op.GGML_UNARY_OP_STEP = 3
     * }
     */
    public static int GGML_UNARY_OP_STEP() {
        return GGML_UNARY_OP_STEP;
    }
    private static final int GGML_UNARY_OP_TANH = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ggml_unary_op.GGML_UNARY_OP_TANH = 4
     * }
     */
    public static int GGML_UNARY_OP_TANH() {
        return GGML_UNARY_OP_TANH;
    }
    private static final int GGML_UNARY_OP_ELU = (int)5L;
    /**
     * {@snippet lang=c :
     * enum ggml_unary_op.GGML_UNARY_OP_ELU = 5
     * }
     */
    public static int GGML_UNARY_OP_ELU() {
        return GGML_UNARY_OP_ELU;
    }
    private static final int GGML_UNARY_OP_RELU = (int)6L;
    /**
     * {@snippet lang=c :
     * enum ggml_unary_op.GGML_UNARY_OP_RELU = 6
     * }
     */
    public static int GGML_UNARY_OP_RELU() {
        return GGML_UNARY_OP_RELU;
    }
    private static final int GGML_UNARY_OP_SIGMOID = (int)7L;
    /**
     * {@snippet lang=c :
     * enum ggml_unary_op.GGML_UNARY_OP_SIGMOID = 7
     * }
     */
    public static int GGML_UNARY_OP_SIGMOID() {
        return GGML_UNARY_OP_SIGMOID;
    }
    private static final int GGML_UNARY_OP_GELU = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ggml_unary_op.GGML_UNARY_OP_GELU = 8
     * }
     */
    public static int GGML_UNARY_OP_GELU() {
        return GGML_UNARY_OP_GELU;
    }
    private static final int GGML_UNARY_OP_GELU_QUICK = (int)9L;
    /**
     * {@snippet lang=c :
     * enum ggml_unary_op.GGML_UNARY_OP_GELU_QUICK = 9
     * }
     */
    public static int GGML_UNARY_OP_GELU_QUICK() {
        return GGML_UNARY_OP_GELU_QUICK;
    }
    private static final int GGML_UNARY_OP_SILU = (int)10L;
    /**
     * {@snippet lang=c :
     * enum ggml_unary_op.GGML_UNARY_OP_SILU = 10
     * }
     */
    public static int GGML_UNARY_OP_SILU() {
        return GGML_UNARY_OP_SILU;
    }
    private static final int GGML_UNARY_OP_HARDSWISH = (int)11L;
    /**
     * {@snippet lang=c :
     * enum ggml_unary_op.GGML_UNARY_OP_HARDSWISH = 11
     * }
     */
    public static int GGML_UNARY_OP_HARDSWISH() {
        return GGML_UNARY_OP_HARDSWISH;
    }
    private static final int GGML_UNARY_OP_HARDSIGMOID = (int)12L;
    /**
     * {@snippet lang=c :
     * enum ggml_unary_op.GGML_UNARY_OP_HARDSIGMOID = 12
     * }
     */
    public static int GGML_UNARY_OP_HARDSIGMOID() {
        return GGML_UNARY_OP_HARDSIGMOID;
    }
    private static final int GGML_UNARY_OP_EXP = (int)13L;
    /**
     * {@snippet lang=c :
     * enum ggml_unary_op.GGML_UNARY_OP_EXP = 13
     * }
     */
    public static int GGML_UNARY_OP_EXP() {
        return GGML_UNARY_OP_EXP;
    }
    private static final int GGML_UNARY_OP_GELU_ERF = (int)14L;
    /**
     * {@snippet lang=c :
     * enum ggml_unary_op.GGML_UNARY_OP_GELU_ERF = 14
     * }
     */
    public static int GGML_UNARY_OP_GELU_ERF() {
        return GGML_UNARY_OP_GELU_ERF;
    }
    private static final int GGML_UNARY_OP_COUNT = (int)15L;
    /**
     * {@snippet lang=c :
     * enum ggml_unary_op.GGML_UNARY_OP_COUNT = 15
     * }
     */
    public static int GGML_UNARY_OP_COUNT() {
        return GGML_UNARY_OP_COUNT;
    }
    private static final int GGML_GLU_OP_REGLU = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ggml_glu_op.GGML_GLU_OP_REGLU = 0
     * }
     */
    public static int GGML_GLU_OP_REGLU() {
        return GGML_GLU_OP_REGLU;
    }
    private static final int GGML_GLU_OP_GEGLU = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ggml_glu_op.GGML_GLU_OP_GEGLU = 1
     * }
     */
    public static int GGML_GLU_OP_GEGLU() {
        return GGML_GLU_OP_GEGLU;
    }
    private static final int GGML_GLU_OP_SWIGLU = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ggml_glu_op.GGML_GLU_OP_SWIGLU = 2
     * }
     */
    public static int GGML_GLU_OP_SWIGLU() {
        return GGML_GLU_OP_SWIGLU;
    }
    private static final int GGML_GLU_OP_GEGLU_ERF = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ggml_glu_op.GGML_GLU_OP_GEGLU_ERF = 3
     * }
     */
    public static int GGML_GLU_OP_GEGLU_ERF() {
        return GGML_GLU_OP_GEGLU_ERF;
    }
    private static final int GGML_GLU_OP_GEGLU_QUICK = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ggml_glu_op.GGML_GLU_OP_GEGLU_QUICK = 4
     * }
     */
    public static int GGML_GLU_OP_GEGLU_QUICK() {
        return GGML_GLU_OP_GEGLU_QUICK;
    }
    private static final int GGML_GLU_OP_COUNT = (int)5L;
    /**
     * {@snippet lang=c :
     * enum ggml_glu_op.GGML_GLU_OP_COUNT = 5
     * }
     */
    public static int GGML_GLU_OP_COUNT() {
        return GGML_GLU_OP_COUNT;
    }
    private static final int GGML_OBJECT_TYPE_TENSOR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ggml_object_type.GGML_OBJECT_TYPE_TENSOR = 0
     * }
     */
    public static int GGML_OBJECT_TYPE_TENSOR() {
        return GGML_OBJECT_TYPE_TENSOR;
    }
    private static final int GGML_OBJECT_TYPE_GRAPH = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ggml_object_type.GGML_OBJECT_TYPE_GRAPH = 1
     * }
     */
    public static int GGML_OBJECT_TYPE_GRAPH() {
        return GGML_OBJECT_TYPE_GRAPH;
    }
    private static final int GGML_OBJECT_TYPE_WORK_BUFFER = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ggml_object_type.GGML_OBJECT_TYPE_WORK_BUFFER = 2
     * }
     */
    public static int GGML_OBJECT_TYPE_WORK_BUFFER() {
        return GGML_OBJECT_TYPE_WORK_BUFFER;
    }
    private static final int GGML_LOG_LEVEL_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ggml_log_level.GGML_LOG_LEVEL_NONE = 0
     * }
     */
    public static int GGML_LOG_LEVEL_NONE() {
        return GGML_LOG_LEVEL_NONE;
    }
    private static final int GGML_LOG_LEVEL_DEBUG = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ggml_log_level.GGML_LOG_LEVEL_DEBUG = 1
     * }
     */
    public static int GGML_LOG_LEVEL_DEBUG() {
        return GGML_LOG_LEVEL_DEBUG;
    }
    private static final int GGML_LOG_LEVEL_INFO = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ggml_log_level.GGML_LOG_LEVEL_INFO = 2
     * }
     */
    public static int GGML_LOG_LEVEL_INFO() {
        return GGML_LOG_LEVEL_INFO;
    }
    private static final int GGML_LOG_LEVEL_WARN = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ggml_log_level.GGML_LOG_LEVEL_WARN = 3
     * }
     */
    public static int GGML_LOG_LEVEL_WARN() {
        return GGML_LOG_LEVEL_WARN;
    }
    private static final int GGML_LOG_LEVEL_ERROR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ggml_log_level.GGML_LOG_LEVEL_ERROR = 4
     * }
     */
    public static int GGML_LOG_LEVEL_ERROR() {
        return GGML_LOG_LEVEL_ERROR;
    }
    private static final int GGML_LOG_LEVEL_CONT = (int)5L;
    /**
     * {@snippet lang=c :
     * enum ggml_log_level.GGML_LOG_LEVEL_CONT = 5
     * }
     */
    public static int GGML_LOG_LEVEL_CONT() {
        return GGML_LOG_LEVEL_CONT;
    }
    private static final int GGML_TENSOR_FLAG_INPUT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ggml_tensor_flag.GGML_TENSOR_FLAG_INPUT = 1
     * }
     */
    public static int GGML_TENSOR_FLAG_INPUT() {
        return GGML_TENSOR_FLAG_INPUT;
    }
    private static final int GGML_TENSOR_FLAG_OUTPUT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ggml_tensor_flag.GGML_TENSOR_FLAG_OUTPUT = 2
     * }
     */
    public static int GGML_TENSOR_FLAG_OUTPUT() {
        return GGML_TENSOR_FLAG_OUTPUT;
    }
    private static final int GGML_TENSOR_FLAG_PARAM = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ggml_tensor_flag.GGML_TENSOR_FLAG_PARAM = 4
     * }
     */
    public static int GGML_TENSOR_FLAG_PARAM() {
        return GGML_TENSOR_FLAG_PARAM;
    }
    private static final int GGML_TENSOR_FLAG_LOSS = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ggml_tensor_flag.GGML_TENSOR_FLAG_LOSS = 8
     * }
     */
    public static int GGML_TENSOR_FLAG_LOSS() {
        return GGML_TENSOR_FLAG_LOSS;
    }
    /**
     * {@snippet lang=c :
     * typedef ggml_guid *ggml_guid_t
     * }
     */
    public static final AddressLayout ggml_guid_t = WhisperCpp.C_POINTER;

    private static class ggml_guid_matches {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_guid_matches");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_guid_matches(ggml_guid_t guid_a, ggml_guid_t guid_b)
     * }
     */
    public static FunctionDescriptor ggml_guid_matches$descriptor() {
        return ggml_guid_matches.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_guid_matches(ggml_guid_t guid_a, ggml_guid_t guid_b)
     * }
     */
    public static MethodHandle ggml_guid_matches$handle() {
        return ggml_guid_matches.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_guid_matches(ggml_guid_t guid_a, ggml_guid_t guid_b)
     * }
     */
    public static MemorySegment ggml_guid_matches$address() {
        return ggml_guid_matches.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_guid_matches(ggml_guid_t guid_a, ggml_guid_t guid_b)
     * }
     */
    public static boolean ggml_guid_matches(MemorySegment guid_a, MemorySegment guid_b) {
        var mh$ = ggml_guid_matches.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_guid_matches", guid_a, guid_b);
            }
            return (boolean)mh$.invokeExact(guid_a, guid_b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ggml_version()
     * }
     */
    public static FunctionDescriptor ggml_version$descriptor() {
        return ggml_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ggml_version()
     * }
     */
    public static MethodHandle ggml_version$handle() {
        return ggml_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ggml_version()
     * }
     */
    public static MemorySegment ggml_version$address() {
        return ggml_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ggml_version()
     * }
     */
    public static MemorySegment ggml_version() {
        var mh$ = ggml_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_version");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_commit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_commit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ggml_commit()
     * }
     */
    public static FunctionDescriptor ggml_commit$descriptor() {
        return ggml_commit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ggml_commit()
     * }
     */
    public static MethodHandle ggml_commit$handle() {
        return ggml_commit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ggml_commit()
     * }
     */
    public static MemorySegment ggml_commit$address() {
        return ggml_commit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ggml_commit()
     * }
     */
    public static MemorySegment ggml_commit() {
        var mh$ = ggml_commit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_commit");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_time_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_time_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_time_init()
     * }
     */
    public static FunctionDescriptor ggml_time_init$descriptor() {
        return ggml_time_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_time_init()
     * }
     */
    public static MethodHandle ggml_time_init$handle() {
        return ggml_time_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_time_init()
     * }
     */
    public static MemorySegment ggml_time_init$address() {
        return ggml_time_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_time_init()
     * }
     */
    public static void ggml_time_init() {
        var mh$ = ggml_time_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_time_init");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_time_ms {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_time_ms");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int64_t ggml_time_ms()
     * }
     */
    public static FunctionDescriptor ggml_time_ms$descriptor() {
        return ggml_time_ms.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int64_t ggml_time_ms()
     * }
     */
    public static MethodHandle ggml_time_ms$handle() {
        return ggml_time_ms.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int64_t ggml_time_ms()
     * }
     */
    public static MemorySegment ggml_time_ms$address() {
        return ggml_time_ms.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int64_t ggml_time_ms()
     * }
     */
    public static long ggml_time_ms() {
        var mh$ = ggml_time_ms.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_time_ms");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_time_us {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_time_us");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int64_t ggml_time_us()
     * }
     */
    public static FunctionDescriptor ggml_time_us$descriptor() {
        return ggml_time_us.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int64_t ggml_time_us()
     * }
     */
    public static MethodHandle ggml_time_us$handle() {
        return ggml_time_us.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int64_t ggml_time_us()
     * }
     */
    public static MemorySegment ggml_time_us$address() {
        return ggml_time_us.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int64_t ggml_time_us()
     * }
     */
    public static long ggml_time_us() {
        var mh$ = ggml_time_us.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_time_us");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cycles {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cycles");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int64_t ggml_cycles()
     * }
     */
    public static FunctionDescriptor ggml_cycles$descriptor() {
        return ggml_cycles.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int64_t ggml_cycles()
     * }
     */
    public static MethodHandle ggml_cycles$handle() {
        return ggml_cycles.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int64_t ggml_cycles()
     * }
     */
    public static MemorySegment ggml_cycles$address() {
        return ggml_cycles.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int64_t ggml_cycles()
     * }
     */
    public static long ggml_cycles() {
        var mh$ = ggml_cycles.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cycles");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cycles_per_ms {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cycles_per_ms");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int64_t ggml_cycles_per_ms()
     * }
     */
    public static FunctionDescriptor ggml_cycles_per_ms$descriptor() {
        return ggml_cycles_per_ms.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int64_t ggml_cycles_per_ms()
     * }
     */
    public static MethodHandle ggml_cycles_per_ms$handle() {
        return ggml_cycles_per_ms.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int64_t ggml_cycles_per_ms()
     * }
     */
    public static MemorySegment ggml_cycles_per_ms$address() {
        return ggml_cycles_per_ms.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int64_t ggml_cycles_per_ms()
     * }
     */
    public static long ggml_cycles_per_ms() {
        var mh$ = ggml_cycles_per_ms.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cycles_per_ms");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_fopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_fopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *ggml_fopen(const char *fname, const char *mode)
     * }
     */
    public static FunctionDescriptor ggml_fopen$descriptor() {
        return ggml_fopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *ggml_fopen(const char *fname, const char *mode)
     * }
     */
    public static MethodHandle ggml_fopen$handle() {
        return ggml_fopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *ggml_fopen(const char *fname, const char *mode)
     * }
     */
    public static MemorySegment ggml_fopen$address() {
        return ggml_fopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *ggml_fopen(const char *fname, const char *mode)
     * }
     */
    public static MemorySegment ggml_fopen(MemorySegment fname, MemorySegment mode) {
        var mh$ = ggml_fopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_fopen", fname, mode);
            }
            return (MemorySegment)mh$.invokeExact(fname, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_print_object {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_print_object");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_print_object(const struct ggml_object *obj)
     * }
     */
    public static FunctionDescriptor ggml_print_object$descriptor() {
        return ggml_print_object.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_print_object(const struct ggml_object *obj)
     * }
     */
    public static MethodHandle ggml_print_object$handle() {
        return ggml_print_object.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_print_object(const struct ggml_object *obj)
     * }
     */
    public static MemorySegment ggml_print_object$address() {
        return ggml_print_object.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_print_object(const struct ggml_object *obj)
     * }
     */
    public static void ggml_print_object(MemorySegment obj) {
        var mh$ = ggml_print_object.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_print_object", obj);
            }
            mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_print_objects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_print_objects");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_print_objects(const struct ggml_context *ctx)
     * }
     */
    public static FunctionDescriptor ggml_print_objects$descriptor() {
        return ggml_print_objects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_print_objects(const struct ggml_context *ctx)
     * }
     */
    public static MethodHandle ggml_print_objects$handle() {
        return ggml_print_objects.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_print_objects(const struct ggml_context *ctx)
     * }
     */
    public static MemorySegment ggml_print_objects$address() {
        return ggml_print_objects.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_print_objects(const struct ggml_context *ctx)
     * }
     */
    public static void ggml_print_objects(MemorySegment ctx) {
        var mh$ = ggml_print_objects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_print_objects", ctx);
            }
            mh$.invokeExact(ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_nelements {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_nelements");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int64_t ggml_nelements(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_nelements$descriptor() {
        return ggml_nelements.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int64_t ggml_nelements(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_nelements$handle() {
        return ggml_nelements.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int64_t ggml_nelements(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_nelements$address() {
        return ggml_nelements.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int64_t ggml_nelements(const struct ggml_tensor *tensor)
     * }
     */
    public static long ggml_nelements(MemorySegment tensor) {
        var mh$ = ggml_nelements.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_nelements", tensor);
            }
            return (long)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_nrows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_nrows");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int64_t ggml_nrows(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_nrows$descriptor() {
        return ggml_nrows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int64_t ggml_nrows(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_nrows$handle() {
        return ggml_nrows.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int64_t ggml_nrows(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_nrows$address() {
        return ggml_nrows.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int64_t ggml_nrows(const struct ggml_tensor *tensor)
     * }
     */
    public static long ggml_nrows(MemorySegment tensor) {
        var mh$ = ggml_nrows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_nrows", tensor);
            }
            return (long)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_nbytes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_nbytes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_nbytes(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_nbytes$descriptor() {
        return ggml_nbytes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_nbytes(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_nbytes$handle() {
        return ggml_nbytes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_nbytes(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_nbytes$address() {
        return ggml_nbytes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_nbytes(const struct ggml_tensor *tensor)
     * }
     */
    public static long ggml_nbytes(MemorySegment tensor) {
        var mh$ = ggml_nbytes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_nbytes", tensor);
            }
            return (long)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_nbytes_pad {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_nbytes_pad");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_nbytes_pad(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_nbytes_pad$descriptor() {
        return ggml_nbytes_pad.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_nbytes_pad(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_nbytes_pad$handle() {
        return ggml_nbytes_pad.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_nbytes_pad(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_nbytes_pad$address() {
        return ggml_nbytes_pad.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_nbytes_pad(const struct ggml_tensor *tensor)
     * }
     */
    public static long ggml_nbytes_pad(MemorySegment tensor) {
        var mh$ = ggml_nbytes_pad.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_nbytes_pad", tensor);
            }
            return (long)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_blck_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_blck_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int64_t ggml_blck_size(enum ggml_type type)
     * }
     */
    public static FunctionDescriptor ggml_blck_size$descriptor() {
        return ggml_blck_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int64_t ggml_blck_size(enum ggml_type type)
     * }
     */
    public static MethodHandle ggml_blck_size$handle() {
        return ggml_blck_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int64_t ggml_blck_size(enum ggml_type type)
     * }
     */
    public static MemorySegment ggml_blck_size$address() {
        return ggml_blck_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int64_t ggml_blck_size(enum ggml_type type)
     * }
     */
    public static long ggml_blck_size(int type) {
        var mh$ = ggml_blck_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_blck_size", type);
            }
            return (long)mh$.invokeExact(type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_type_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_type_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_type_size(enum ggml_type type)
     * }
     */
    public static FunctionDescriptor ggml_type_size$descriptor() {
        return ggml_type_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_type_size(enum ggml_type type)
     * }
     */
    public static MethodHandle ggml_type_size$handle() {
        return ggml_type_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_type_size(enum ggml_type type)
     * }
     */
    public static MemorySegment ggml_type_size$address() {
        return ggml_type_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_type_size(enum ggml_type type)
     * }
     */
    public static long ggml_type_size(int type) {
        var mh$ = ggml_type_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_type_size", type);
            }
            return (long)mh$.invokeExact(type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_row_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_INT,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_row_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_row_size(enum ggml_type type, int64_t ne)
     * }
     */
    public static FunctionDescriptor ggml_row_size$descriptor() {
        return ggml_row_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_row_size(enum ggml_type type, int64_t ne)
     * }
     */
    public static MethodHandle ggml_row_size$handle() {
        return ggml_row_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_row_size(enum ggml_type type, int64_t ne)
     * }
     */
    public static MemorySegment ggml_row_size$address() {
        return ggml_row_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_row_size(enum ggml_type type, int64_t ne)
     * }
     */
    public static long ggml_row_size(int type, long ne) {
        var mh$ = ggml_row_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_row_size", type, ne);
            }
            return (long)mh$.invokeExact(type, ne);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_type_sizef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_DOUBLE,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_type_sizef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double ggml_type_sizef(enum ggml_type type)
     * }
     */
    public static FunctionDescriptor ggml_type_sizef$descriptor() {
        return ggml_type_sizef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double ggml_type_sizef(enum ggml_type type)
     * }
     */
    public static MethodHandle ggml_type_sizef$handle() {
        return ggml_type_sizef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double ggml_type_sizef(enum ggml_type type)
     * }
     */
    public static MemorySegment ggml_type_sizef$address() {
        return ggml_type_sizef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double ggml_type_sizef(enum ggml_type type)
     * }
     */
    public static double ggml_type_sizef(int type) {
        var mh$ = ggml_type_sizef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_type_sizef", type);
            }
            return (double)mh$.invokeExact(type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_type_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_type_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ggml_type_name(enum ggml_type type)
     * }
     */
    public static FunctionDescriptor ggml_type_name$descriptor() {
        return ggml_type_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ggml_type_name(enum ggml_type type)
     * }
     */
    public static MethodHandle ggml_type_name$handle() {
        return ggml_type_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ggml_type_name(enum ggml_type type)
     * }
     */
    public static MemorySegment ggml_type_name$address() {
        return ggml_type_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ggml_type_name(enum ggml_type type)
     * }
     */
    public static MemorySegment ggml_type_name(int type) {
        var mh$ = ggml_type_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_type_name", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_op_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_op_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ggml_op_name(enum ggml_op op)
     * }
     */
    public static FunctionDescriptor ggml_op_name$descriptor() {
        return ggml_op_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ggml_op_name(enum ggml_op op)
     * }
     */
    public static MethodHandle ggml_op_name$handle() {
        return ggml_op_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ggml_op_name(enum ggml_op op)
     * }
     */
    public static MemorySegment ggml_op_name$address() {
        return ggml_op_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ggml_op_name(enum ggml_op op)
     * }
     */
    public static MemorySegment ggml_op_name(int op) {
        var mh$ = ggml_op_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_op_name", op);
            }
            return (MemorySegment)mh$.invokeExact(op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_op_symbol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_op_symbol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ggml_op_symbol(enum ggml_op op)
     * }
     */
    public static FunctionDescriptor ggml_op_symbol$descriptor() {
        return ggml_op_symbol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ggml_op_symbol(enum ggml_op op)
     * }
     */
    public static MethodHandle ggml_op_symbol$handle() {
        return ggml_op_symbol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ggml_op_symbol(enum ggml_op op)
     * }
     */
    public static MemorySegment ggml_op_symbol$address() {
        return ggml_op_symbol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ggml_op_symbol(enum ggml_op op)
     * }
     */
    public static MemorySegment ggml_op_symbol(int op) {
        var mh$ = ggml_op_symbol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_op_symbol", op);
            }
            return (MemorySegment)mh$.invokeExact(op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_unary_op_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_unary_op_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ggml_unary_op_name(enum ggml_unary_op op)
     * }
     */
    public static FunctionDescriptor ggml_unary_op_name$descriptor() {
        return ggml_unary_op_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ggml_unary_op_name(enum ggml_unary_op op)
     * }
     */
    public static MethodHandle ggml_unary_op_name$handle() {
        return ggml_unary_op_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ggml_unary_op_name(enum ggml_unary_op op)
     * }
     */
    public static MemorySegment ggml_unary_op_name$address() {
        return ggml_unary_op_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ggml_unary_op_name(enum ggml_unary_op op)
     * }
     */
    public static MemorySegment ggml_unary_op_name(int op) {
        var mh$ = ggml_unary_op_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_unary_op_name", op);
            }
            return (MemorySegment)mh$.invokeExact(op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_glu_op_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_glu_op_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ggml_glu_op_name(enum ggml_glu_op op)
     * }
     */
    public static FunctionDescriptor ggml_glu_op_name$descriptor() {
        return ggml_glu_op_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ggml_glu_op_name(enum ggml_glu_op op)
     * }
     */
    public static MethodHandle ggml_glu_op_name$handle() {
        return ggml_glu_op_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ggml_glu_op_name(enum ggml_glu_op op)
     * }
     */
    public static MemorySegment ggml_glu_op_name$address() {
        return ggml_glu_op_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ggml_glu_op_name(enum ggml_glu_op op)
     * }
     */
    public static MemorySegment ggml_glu_op_name(int op) {
        var mh$ = ggml_glu_op_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_glu_op_name", op);
            }
            return (MemorySegment)mh$.invokeExact(op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_op_desc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_op_desc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ggml_op_desc(const struct ggml_tensor *t)
     * }
     */
    public static FunctionDescriptor ggml_op_desc$descriptor() {
        return ggml_op_desc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ggml_op_desc(const struct ggml_tensor *t)
     * }
     */
    public static MethodHandle ggml_op_desc$handle() {
        return ggml_op_desc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ggml_op_desc(const struct ggml_tensor *t)
     * }
     */
    public static MemorySegment ggml_op_desc$address() {
        return ggml_op_desc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ggml_op_desc(const struct ggml_tensor *t)
     * }
     */
    public static MemorySegment ggml_op_desc(MemorySegment t) {
        var mh$ = ggml_op_desc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_op_desc", t);
            }
            return (MemorySegment)mh$.invokeExact(t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_element_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_element_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_element_size(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_element_size$descriptor() {
        return ggml_element_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_element_size(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_element_size$handle() {
        return ggml_element_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_element_size(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_element_size$address() {
        return ggml_element_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_element_size(const struct ggml_tensor *tensor)
     * }
     */
    public static long ggml_element_size(MemorySegment tensor) {
        var mh$ = ggml_element_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_element_size", tensor);
            }
            return (long)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_is_quantized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_is_quantized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_is_quantized(enum ggml_type type)
     * }
     */
    public static FunctionDescriptor ggml_is_quantized$descriptor() {
        return ggml_is_quantized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_is_quantized(enum ggml_type type)
     * }
     */
    public static MethodHandle ggml_is_quantized$handle() {
        return ggml_is_quantized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_is_quantized(enum ggml_type type)
     * }
     */
    public static MemorySegment ggml_is_quantized$address() {
        return ggml_is_quantized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_is_quantized(enum ggml_type type)
     * }
     */
    public static boolean ggml_is_quantized(int type) {
        var mh$ = ggml_is_quantized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_is_quantized", type);
            }
            return (boolean)mh$.invokeExact(type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_ftype_to_ggml_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_ftype_to_ggml_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_type ggml_ftype_to_ggml_type(enum ggml_ftype ftype)
     * }
     */
    public static FunctionDescriptor ggml_ftype_to_ggml_type$descriptor() {
        return ggml_ftype_to_ggml_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_type ggml_ftype_to_ggml_type(enum ggml_ftype ftype)
     * }
     */
    public static MethodHandle ggml_ftype_to_ggml_type$handle() {
        return ggml_ftype_to_ggml_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_type ggml_ftype_to_ggml_type(enum ggml_ftype ftype)
     * }
     */
    public static MemorySegment ggml_ftype_to_ggml_type$address() {
        return ggml_ftype_to_ggml_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_type ggml_ftype_to_ggml_type(enum ggml_ftype ftype)
     * }
     */
    public static int ggml_ftype_to_ggml_type(int ftype) {
        var mh$ = ggml_ftype_to_ggml_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_ftype_to_ggml_type", ftype);
            }
            return (int)mh$.invokeExact(ftype);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_is_transposed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_is_transposed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_is_transposed(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_is_transposed$descriptor() {
        return ggml_is_transposed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_is_transposed(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_is_transposed$handle() {
        return ggml_is_transposed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_is_transposed(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_is_transposed$address() {
        return ggml_is_transposed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_is_transposed(const struct ggml_tensor *tensor)
     * }
     */
    public static boolean ggml_is_transposed(MemorySegment tensor) {
        var mh$ = ggml_is_transposed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_is_transposed", tensor);
            }
            return (boolean)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_is_permuted {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_is_permuted");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_is_permuted(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_is_permuted$descriptor() {
        return ggml_is_permuted.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_is_permuted(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_is_permuted$handle() {
        return ggml_is_permuted.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_is_permuted(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_is_permuted$address() {
        return ggml_is_permuted.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_is_permuted(const struct ggml_tensor *tensor)
     * }
     */
    public static boolean ggml_is_permuted(MemorySegment tensor) {
        var mh$ = ggml_is_permuted.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_is_permuted", tensor);
            }
            return (boolean)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_is_empty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_is_empty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_is_empty(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_is_empty$descriptor() {
        return ggml_is_empty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_is_empty(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_is_empty$handle() {
        return ggml_is_empty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_is_empty(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_is_empty$address() {
        return ggml_is_empty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_is_empty(const struct ggml_tensor *tensor)
     * }
     */
    public static boolean ggml_is_empty(MemorySegment tensor) {
        var mh$ = ggml_is_empty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_is_empty", tensor);
            }
            return (boolean)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_is_scalar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_is_scalar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_is_scalar(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_is_scalar$descriptor() {
        return ggml_is_scalar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_is_scalar(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_is_scalar$handle() {
        return ggml_is_scalar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_is_scalar(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_is_scalar$address() {
        return ggml_is_scalar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_is_scalar(const struct ggml_tensor *tensor)
     * }
     */
    public static boolean ggml_is_scalar(MemorySegment tensor) {
        var mh$ = ggml_is_scalar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_is_scalar", tensor);
            }
            return (boolean)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_is_vector {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_is_vector");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_is_vector(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_is_vector$descriptor() {
        return ggml_is_vector.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_is_vector(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_is_vector$handle() {
        return ggml_is_vector.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_is_vector(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_is_vector$address() {
        return ggml_is_vector.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_is_vector(const struct ggml_tensor *tensor)
     * }
     */
    public static boolean ggml_is_vector(MemorySegment tensor) {
        var mh$ = ggml_is_vector.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_is_vector", tensor);
            }
            return (boolean)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_is_matrix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_is_matrix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_is_matrix(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_is_matrix$descriptor() {
        return ggml_is_matrix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_is_matrix(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_is_matrix$handle() {
        return ggml_is_matrix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_is_matrix(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_is_matrix$address() {
        return ggml_is_matrix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_is_matrix(const struct ggml_tensor *tensor)
     * }
     */
    public static boolean ggml_is_matrix(MemorySegment tensor) {
        var mh$ = ggml_is_matrix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_is_matrix", tensor);
            }
            return (boolean)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_is_3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_is_3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_is_3d(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_is_3d$descriptor() {
        return ggml_is_3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_is_3d(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_is_3d$handle() {
        return ggml_is_3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_is_3d(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_is_3d$address() {
        return ggml_is_3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_is_3d(const struct ggml_tensor *tensor)
     * }
     */
    public static boolean ggml_is_3d(MemorySegment tensor) {
        var mh$ = ggml_is_3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_is_3d", tensor);
            }
            return (boolean)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_n_dims {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_n_dims");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_n_dims(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_n_dims$descriptor() {
        return ggml_n_dims.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_n_dims(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_n_dims$handle() {
        return ggml_n_dims.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_n_dims(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_n_dims$address() {
        return ggml_n_dims.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_n_dims(const struct ggml_tensor *tensor)
     * }
     */
    public static int ggml_n_dims(MemorySegment tensor) {
        var mh$ = ggml_n_dims.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_n_dims", tensor);
            }
            return (int)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_is_contiguous {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_is_contiguous");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_is_contiguous$descriptor() {
        return ggml_is_contiguous.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_is_contiguous$handle() {
        return ggml_is_contiguous.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_is_contiguous$address() {
        return ggml_is_contiguous.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous(const struct ggml_tensor *tensor)
     * }
     */
    public static boolean ggml_is_contiguous(MemorySegment tensor) {
        var mh$ = ggml_is_contiguous.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_is_contiguous", tensor);
            }
            return (boolean)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_is_contiguous_0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_is_contiguous_0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous_0(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_is_contiguous_0$descriptor() {
        return ggml_is_contiguous_0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous_0(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_is_contiguous_0$handle() {
        return ggml_is_contiguous_0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous_0(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_is_contiguous_0$address() {
        return ggml_is_contiguous_0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous_0(const struct ggml_tensor *tensor)
     * }
     */
    public static boolean ggml_is_contiguous_0(MemorySegment tensor) {
        var mh$ = ggml_is_contiguous_0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_is_contiguous_0", tensor);
            }
            return (boolean)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_is_contiguous_1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_is_contiguous_1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous_1(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_is_contiguous_1$descriptor() {
        return ggml_is_contiguous_1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous_1(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_is_contiguous_1$handle() {
        return ggml_is_contiguous_1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous_1(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_is_contiguous_1$address() {
        return ggml_is_contiguous_1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous_1(const struct ggml_tensor *tensor)
     * }
     */
    public static boolean ggml_is_contiguous_1(MemorySegment tensor) {
        var mh$ = ggml_is_contiguous_1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_is_contiguous_1", tensor);
            }
            return (boolean)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_is_contiguous_2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_is_contiguous_2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous_2(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_is_contiguous_2$descriptor() {
        return ggml_is_contiguous_2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous_2(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_is_contiguous_2$handle() {
        return ggml_is_contiguous_2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous_2(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_is_contiguous_2$address() {
        return ggml_is_contiguous_2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous_2(const struct ggml_tensor *tensor)
     * }
     */
    public static boolean ggml_is_contiguous_2(MemorySegment tensor) {
        var mh$ = ggml_is_contiguous_2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_is_contiguous_2", tensor);
            }
            return (boolean)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_is_contiguously_allocated {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_is_contiguously_allocated");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguously_allocated(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_is_contiguously_allocated$descriptor() {
        return ggml_is_contiguously_allocated.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguously_allocated(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_is_contiguously_allocated$handle() {
        return ggml_is_contiguously_allocated.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguously_allocated(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_is_contiguously_allocated$address() {
        return ggml_is_contiguously_allocated.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_is_contiguously_allocated(const struct ggml_tensor *tensor)
     * }
     */
    public static boolean ggml_is_contiguously_allocated(MemorySegment tensor) {
        var mh$ = ggml_is_contiguously_allocated.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_is_contiguously_allocated", tensor);
            }
            return (boolean)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_is_contiguous_channels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_is_contiguous_channels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous_channels(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_is_contiguous_channels$descriptor() {
        return ggml_is_contiguous_channels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous_channels(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_is_contiguous_channels$handle() {
        return ggml_is_contiguous_channels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous_channels(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_is_contiguous_channels$address() {
        return ggml_is_contiguous_channels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous_channels(const struct ggml_tensor *tensor)
     * }
     */
    public static boolean ggml_is_contiguous_channels(MemorySegment tensor) {
        var mh$ = ggml_is_contiguous_channels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_is_contiguous_channels", tensor);
            }
            return (boolean)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_is_contiguous_rows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_is_contiguous_rows");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous_rows(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_is_contiguous_rows$descriptor() {
        return ggml_is_contiguous_rows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous_rows(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_is_contiguous_rows$handle() {
        return ggml_is_contiguous_rows.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous_rows(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_is_contiguous_rows$address() {
        return ggml_is_contiguous_rows.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous_rows(const struct ggml_tensor *tensor)
     * }
     */
    public static boolean ggml_is_contiguous_rows(MemorySegment tensor) {
        var mh$ = ggml_is_contiguous_rows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_is_contiguous_rows", tensor);
            }
            return (boolean)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_are_same_shape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_are_same_shape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_are_same_shape(const struct ggml_tensor *t0, const struct ggml_tensor *t1)
     * }
     */
    public static FunctionDescriptor ggml_are_same_shape$descriptor() {
        return ggml_are_same_shape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_are_same_shape(const struct ggml_tensor *t0, const struct ggml_tensor *t1)
     * }
     */
    public static MethodHandle ggml_are_same_shape$handle() {
        return ggml_are_same_shape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_are_same_shape(const struct ggml_tensor *t0, const struct ggml_tensor *t1)
     * }
     */
    public static MemorySegment ggml_are_same_shape$address() {
        return ggml_are_same_shape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_are_same_shape(const struct ggml_tensor *t0, const struct ggml_tensor *t1)
     * }
     */
    public static boolean ggml_are_same_shape(MemorySegment t0, MemorySegment t1) {
        var mh$ = ggml_are_same_shape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_are_same_shape", t0, t1);
            }
            return (boolean)mh$.invokeExact(t0, t1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_are_same_stride {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_are_same_stride");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_are_same_stride(const struct ggml_tensor *t0, const struct ggml_tensor *t1)
     * }
     */
    public static FunctionDescriptor ggml_are_same_stride$descriptor() {
        return ggml_are_same_stride.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_are_same_stride(const struct ggml_tensor *t0, const struct ggml_tensor *t1)
     * }
     */
    public static MethodHandle ggml_are_same_stride$handle() {
        return ggml_are_same_stride.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_are_same_stride(const struct ggml_tensor *t0, const struct ggml_tensor *t1)
     * }
     */
    public static MemorySegment ggml_are_same_stride$address() {
        return ggml_are_same_stride.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_are_same_stride(const struct ggml_tensor *t0, const struct ggml_tensor *t1)
     * }
     */
    public static boolean ggml_are_same_stride(MemorySegment t0, MemorySegment t1) {
        var mh$ = ggml_are_same_stride.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_are_same_stride", t0, t1);
            }
            return (boolean)mh$.invokeExact(t0, t1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_can_repeat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_can_repeat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_can_repeat(const struct ggml_tensor *t0, const struct ggml_tensor *t1)
     * }
     */
    public static FunctionDescriptor ggml_can_repeat$descriptor() {
        return ggml_can_repeat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_can_repeat(const struct ggml_tensor *t0, const struct ggml_tensor *t1)
     * }
     */
    public static MethodHandle ggml_can_repeat$handle() {
        return ggml_can_repeat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_can_repeat(const struct ggml_tensor *t0, const struct ggml_tensor *t1)
     * }
     */
    public static MemorySegment ggml_can_repeat$address() {
        return ggml_can_repeat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_can_repeat(const struct ggml_tensor *t0, const struct ggml_tensor *t1)
     * }
     */
    public static boolean ggml_can_repeat(MemorySegment t0, MemorySegment t1) {
        var mh$ = ggml_can_repeat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_can_repeat", t0, t1);
            }
            return (boolean)mh$.invokeExact(t0, t1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_tensor_overhead {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_tensor_overhead");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_tensor_overhead()
     * }
     */
    public static FunctionDescriptor ggml_tensor_overhead$descriptor() {
        return ggml_tensor_overhead.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_tensor_overhead()
     * }
     */
    public static MethodHandle ggml_tensor_overhead$handle() {
        return ggml_tensor_overhead.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_tensor_overhead()
     * }
     */
    public static MemorySegment ggml_tensor_overhead$address() {
        return ggml_tensor_overhead.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_tensor_overhead()
     * }
     */
    public static long ggml_tensor_overhead() {
        var mh$ = ggml_tensor_overhead.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_tensor_overhead");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_validate_row_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_validate_row_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_validate_row_data(enum ggml_type type, const void *data, size_t nbytes)
     * }
     */
    public static FunctionDescriptor ggml_validate_row_data$descriptor() {
        return ggml_validate_row_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_validate_row_data(enum ggml_type type, const void *data, size_t nbytes)
     * }
     */
    public static MethodHandle ggml_validate_row_data$handle() {
        return ggml_validate_row_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_validate_row_data(enum ggml_type type, const void *data, size_t nbytes)
     * }
     */
    public static MemorySegment ggml_validate_row_data$address() {
        return ggml_validate_row_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_validate_row_data(enum ggml_type type, const void *data, size_t nbytes)
     * }
     */
    public static boolean ggml_validate_row_data(int type, MemorySegment data, long nbytes) {
        var mh$ = ggml_validate_row_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_validate_row_data", type, data, nbytes);
            }
            return (boolean)mh$.invokeExact(type, data, nbytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            ggml_init_params.layout()
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_context *ggml_init(struct ggml_init_params params)
     * }
     */
    public static FunctionDescriptor ggml_init$descriptor() {
        return ggml_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_context *ggml_init(struct ggml_init_params params)
     * }
     */
    public static MethodHandle ggml_init$handle() {
        return ggml_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_context *ggml_init(struct ggml_init_params params)
     * }
     */
    public static MemorySegment ggml_init$address() {
        return ggml_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_context *ggml_init(struct ggml_init_params params)
     * }
     */
    public static MemorySegment ggml_init(MemorySegment params) {
        var mh$ = ggml_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_init", params);
            }
            return (MemorySegment)mh$.invokeExact(params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_reset(struct ggml_context *ctx)
     * }
     */
    public static FunctionDescriptor ggml_reset$descriptor() {
        return ggml_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_reset(struct ggml_context *ctx)
     * }
     */
    public static MethodHandle ggml_reset$handle() {
        return ggml_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_reset(struct ggml_context *ctx)
     * }
     */
    public static MemorySegment ggml_reset$address() {
        return ggml_reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_reset(struct ggml_context *ctx)
     * }
     */
    public static void ggml_reset(MemorySegment ctx) {
        var mh$ = ggml_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_reset", ctx);
            }
            mh$.invokeExact(ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_free(struct ggml_context *ctx)
     * }
     */
    public static FunctionDescriptor ggml_free$descriptor() {
        return ggml_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_free(struct ggml_context *ctx)
     * }
     */
    public static MethodHandle ggml_free$handle() {
        return ggml_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_free(struct ggml_context *ctx)
     * }
     */
    public static MemorySegment ggml_free$address() {
        return ggml_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_free(struct ggml_context *ctx)
     * }
     */
    public static void ggml_free(MemorySegment ctx) {
        var mh$ = ggml_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_free", ctx);
            }
            mh$.invokeExact(ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_used_mem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_used_mem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_used_mem(const struct ggml_context *ctx)
     * }
     */
    public static FunctionDescriptor ggml_used_mem$descriptor() {
        return ggml_used_mem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_used_mem(const struct ggml_context *ctx)
     * }
     */
    public static MethodHandle ggml_used_mem$handle() {
        return ggml_used_mem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_used_mem(const struct ggml_context *ctx)
     * }
     */
    public static MemorySegment ggml_used_mem$address() {
        return ggml_used_mem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_used_mem(const struct ggml_context *ctx)
     * }
     */
    public static long ggml_used_mem(MemorySegment ctx) {
        var mh$ = ggml_used_mem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_used_mem", ctx);
            }
            return (long)mh$.invokeExact(ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_no_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_no_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_get_no_alloc(struct ggml_context *ctx)
     * }
     */
    public static FunctionDescriptor ggml_get_no_alloc$descriptor() {
        return ggml_get_no_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_get_no_alloc(struct ggml_context *ctx)
     * }
     */
    public static MethodHandle ggml_get_no_alloc$handle() {
        return ggml_get_no_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_get_no_alloc(struct ggml_context *ctx)
     * }
     */
    public static MemorySegment ggml_get_no_alloc$address() {
        return ggml_get_no_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_get_no_alloc(struct ggml_context *ctx)
     * }
     */
    public static boolean ggml_get_no_alloc(MemorySegment ctx) {
        var mh$ = ggml_get_no_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_no_alloc", ctx);
            }
            return (boolean)mh$.invokeExact(ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_no_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_BOOL
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set_no_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_set_no_alloc(struct ggml_context *ctx, bool no_alloc)
     * }
     */
    public static FunctionDescriptor ggml_set_no_alloc$descriptor() {
        return ggml_set_no_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_set_no_alloc(struct ggml_context *ctx, bool no_alloc)
     * }
     */
    public static MethodHandle ggml_set_no_alloc$handle() {
        return ggml_set_no_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_set_no_alloc(struct ggml_context *ctx, bool no_alloc)
     * }
     */
    public static MemorySegment ggml_set_no_alloc$address() {
        return ggml_set_no_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_set_no_alloc(struct ggml_context *ctx, bool no_alloc)
     * }
     */
    public static void ggml_set_no_alloc(MemorySegment ctx, boolean no_alloc) {
        var mh$ = ggml_set_no_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_no_alloc", ctx, no_alloc);
            }
            mh$.invokeExact(ctx, no_alloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_mem_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_mem_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *ggml_get_mem_buffer(const struct ggml_context *ctx)
     * }
     */
    public static FunctionDescriptor ggml_get_mem_buffer$descriptor() {
        return ggml_get_mem_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *ggml_get_mem_buffer(const struct ggml_context *ctx)
     * }
     */
    public static MethodHandle ggml_get_mem_buffer$handle() {
        return ggml_get_mem_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *ggml_get_mem_buffer(const struct ggml_context *ctx)
     * }
     */
    public static MemorySegment ggml_get_mem_buffer$address() {
        return ggml_get_mem_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *ggml_get_mem_buffer(const struct ggml_context *ctx)
     * }
     */
    public static MemorySegment ggml_get_mem_buffer(MemorySegment ctx) {
        var mh$ = ggml_get_mem_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_mem_buffer", ctx);
            }
            return (MemorySegment)mh$.invokeExact(ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_mem_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_mem_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_get_mem_size(const struct ggml_context *ctx)
     * }
     */
    public static FunctionDescriptor ggml_get_mem_size$descriptor() {
        return ggml_get_mem_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_get_mem_size(const struct ggml_context *ctx)
     * }
     */
    public static MethodHandle ggml_get_mem_size$handle() {
        return ggml_get_mem_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_get_mem_size(const struct ggml_context *ctx)
     * }
     */
    public static MemorySegment ggml_get_mem_size$address() {
        return ggml_get_mem_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_get_mem_size(const struct ggml_context *ctx)
     * }
     */
    public static long ggml_get_mem_size(MemorySegment ctx) {
        var mh$ = ggml_get_mem_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_mem_size", ctx);
            }
            return (long)mh$.invokeExact(ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_max_tensor_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_max_tensor_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_get_max_tensor_size(const struct ggml_context *ctx)
     * }
     */
    public static FunctionDescriptor ggml_get_max_tensor_size$descriptor() {
        return ggml_get_max_tensor_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_get_max_tensor_size(const struct ggml_context *ctx)
     * }
     */
    public static MethodHandle ggml_get_max_tensor_size$handle() {
        return ggml_get_max_tensor_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_get_max_tensor_size(const struct ggml_context *ctx)
     * }
     */
    public static MemorySegment ggml_get_max_tensor_size$address() {
        return ggml_get_max_tensor_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_get_max_tensor_size(const struct ggml_context *ctx)
     * }
     */
    public static long ggml_get_max_tensor_size(MemorySegment ctx) {
        var mh$ = ggml_get_max_tensor_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_max_tensor_size", ctx);
            }
            return (long)mh$.invokeExact(ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_new_tensor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_new_tensor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_tensor(struct ggml_context *ctx, enum ggml_type type, int n_dims, const int64_t *ne)
     * }
     */
    public static FunctionDescriptor ggml_new_tensor$descriptor() {
        return ggml_new_tensor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_tensor(struct ggml_context *ctx, enum ggml_type type, int n_dims, const int64_t *ne)
     * }
     */
    public static MethodHandle ggml_new_tensor$handle() {
        return ggml_new_tensor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_tensor(struct ggml_context *ctx, enum ggml_type type, int n_dims, const int64_t *ne)
     * }
     */
    public static MemorySegment ggml_new_tensor$address() {
        return ggml_new_tensor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_tensor(struct ggml_context *ctx, enum ggml_type type, int n_dims, const int64_t *ne)
     * }
     */
    public static MemorySegment ggml_new_tensor(MemorySegment ctx, int type, int n_dims, MemorySegment ne) {
        var mh$ = ggml_new_tensor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_new_tensor", ctx, type, n_dims, ne);
            }
            return (MemorySegment)mh$.invokeExact(ctx, type, n_dims, ne);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_new_tensor_1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_new_tensor_1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_tensor_1d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0)
     * }
     */
    public static FunctionDescriptor ggml_new_tensor_1d$descriptor() {
        return ggml_new_tensor_1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_tensor_1d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0)
     * }
     */
    public static MethodHandle ggml_new_tensor_1d$handle() {
        return ggml_new_tensor_1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_tensor_1d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0)
     * }
     */
    public static MemorySegment ggml_new_tensor_1d$address() {
        return ggml_new_tensor_1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_tensor_1d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0)
     * }
     */
    public static MemorySegment ggml_new_tensor_1d(MemorySegment ctx, int type, long ne0) {
        var mh$ = ggml_new_tensor_1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_new_tensor_1d", ctx, type, ne0);
            }
            return (MemorySegment)mh$.invokeExact(ctx, type, ne0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_new_tensor_2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_new_tensor_2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_tensor_2d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0, int64_t ne1)
     * }
     */
    public static FunctionDescriptor ggml_new_tensor_2d$descriptor() {
        return ggml_new_tensor_2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_tensor_2d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0, int64_t ne1)
     * }
     */
    public static MethodHandle ggml_new_tensor_2d$handle() {
        return ggml_new_tensor_2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_tensor_2d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0, int64_t ne1)
     * }
     */
    public static MemorySegment ggml_new_tensor_2d$address() {
        return ggml_new_tensor_2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_tensor_2d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0, int64_t ne1)
     * }
     */
    public static MemorySegment ggml_new_tensor_2d(MemorySegment ctx, int type, long ne0, long ne1) {
        var mh$ = ggml_new_tensor_2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_new_tensor_2d", ctx, type, ne0, ne1);
            }
            return (MemorySegment)mh$.invokeExact(ctx, type, ne0, ne1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_new_tensor_3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_new_tensor_3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_tensor_3d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0, int64_t ne1, int64_t ne2)
     * }
     */
    public static FunctionDescriptor ggml_new_tensor_3d$descriptor() {
        return ggml_new_tensor_3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_tensor_3d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0, int64_t ne1, int64_t ne2)
     * }
     */
    public static MethodHandle ggml_new_tensor_3d$handle() {
        return ggml_new_tensor_3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_tensor_3d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0, int64_t ne1, int64_t ne2)
     * }
     */
    public static MemorySegment ggml_new_tensor_3d$address() {
        return ggml_new_tensor_3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_tensor_3d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0, int64_t ne1, int64_t ne2)
     * }
     */
    public static MemorySegment ggml_new_tensor_3d(MemorySegment ctx, int type, long ne0, long ne1, long ne2) {
        var mh$ = ggml_new_tensor_3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_new_tensor_3d", ctx, type, ne0, ne1, ne2);
            }
            return (MemorySegment)mh$.invokeExact(ctx, type, ne0, ne1, ne2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_new_tensor_4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_new_tensor_4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_tensor_4d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3)
     * }
     */
    public static FunctionDescriptor ggml_new_tensor_4d$descriptor() {
        return ggml_new_tensor_4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_tensor_4d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3)
     * }
     */
    public static MethodHandle ggml_new_tensor_4d$handle() {
        return ggml_new_tensor_4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_tensor_4d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3)
     * }
     */
    public static MemorySegment ggml_new_tensor_4d$address() {
        return ggml_new_tensor_4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_tensor_4d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3)
     * }
     */
    public static MemorySegment ggml_new_tensor_4d(MemorySegment ctx, int type, long ne0, long ne1, long ne2, long ne3) {
        var mh$ = ggml_new_tensor_4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_new_tensor_4d", ctx, type, ne0, ne1, ne2, ne3);
            }
            return (MemorySegment)mh$.invokeExact(ctx, type, ne0, ne1, ne2, ne3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_new_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_new_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *ggml_new_buffer(struct ggml_context *ctx, size_t nbytes)
     * }
     */
    public static FunctionDescriptor ggml_new_buffer$descriptor() {
        return ggml_new_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *ggml_new_buffer(struct ggml_context *ctx, size_t nbytes)
     * }
     */
    public static MethodHandle ggml_new_buffer$handle() {
        return ggml_new_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *ggml_new_buffer(struct ggml_context *ctx, size_t nbytes)
     * }
     */
    public static MemorySegment ggml_new_buffer$address() {
        return ggml_new_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *ggml_new_buffer(struct ggml_context *ctx, size_t nbytes)
     * }
     */
    public static MemorySegment ggml_new_buffer(MemorySegment ctx, long nbytes) {
        var mh$ = ggml_new_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_new_buffer", ctx, nbytes);
            }
            return (MemorySegment)mh$.invokeExact(ctx, nbytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_dup_tensor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_dup_tensor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_dup_tensor(struct ggml_context *ctx, const struct ggml_tensor *src)
     * }
     */
    public static FunctionDescriptor ggml_dup_tensor$descriptor() {
        return ggml_dup_tensor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_dup_tensor(struct ggml_context *ctx, const struct ggml_tensor *src)
     * }
     */
    public static MethodHandle ggml_dup_tensor$handle() {
        return ggml_dup_tensor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_dup_tensor(struct ggml_context *ctx, const struct ggml_tensor *src)
     * }
     */
    public static MemorySegment ggml_dup_tensor$address() {
        return ggml_dup_tensor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_dup_tensor(struct ggml_context *ctx, const struct ggml_tensor *src)
     * }
     */
    public static MemorySegment ggml_dup_tensor(MemorySegment ctx, MemorySegment src) {
        var mh$ = ggml_dup_tensor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_dup_tensor", ctx, src);
            }
            return (MemorySegment)mh$.invokeExact(ctx, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_view_tensor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_view_tensor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_view_tensor(struct ggml_context *ctx, struct ggml_tensor *src)
     * }
     */
    public static FunctionDescriptor ggml_view_tensor$descriptor() {
        return ggml_view_tensor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_view_tensor(struct ggml_context *ctx, struct ggml_tensor *src)
     * }
     */
    public static MethodHandle ggml_view_tensor$handle() {
        return ggml_view_tensor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_view_tensor(struct ggml_context *ctx, struct ggml_tensor *src)
     * }
     */
    public static MemorySegment ggml_view_tensor$address() {
        return ggml_view_tensor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_view_tensor(struct ggml_context *ctx, struct ggml_tensor *src)
     * }
     */
    public static MemorySegment ggml_view_tensor(MemorySegment ctx, MemorySegment src) {
        var mh$ = ggml_view_tensor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_view_tensor", ctx, src);
            }
            return (MemorySegment)mh$.invokeExact(ctx, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_first_tensor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_first_tensor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_first_tensor(const struct ggml_context *ctx)
     * }
     */
    public static FunctionDescriptor ggml_get_first_tensor$descriptor() {
        return ggml_get_first_tensor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_first_tensor(const struct ggml_context *ctx)
     * }
     */
    public static MethodHandle ggml_get_first_tensor$handle() {
        return ggml_get_first_tensor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_first_tensor(const struct ggml_context *ctx)
     * }
     */
    public static MemorySegment ggml_get_first_tensor$address() {
        return ggml_get_first_tensor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_first_tensor(const struct ggml_context *ctx)
     * }
     */
    public static MemorySegment ggml_get_first_tensor(MemorySegment ctx) {
        var mh$ = ggml_get_first_tensor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_first_tensor", ctx);
            }
            return (MemorySegment)mh$.invokeExact(ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_next_tensor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_next_tensor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_next_tensor(const struct ggml_context *ctx, struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_get_next_tensor$descriptor() {
        return ggml_get_next_tensor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_next_tensor(const struct ggml_context *ctx, struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_get_next_tensor$handle() {
        return ggml_get_next_tensor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_next_tensor(const struct ggml_context *ctx, struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_get_next_tensor$address() {
        return ggml_get_next_tensor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_next_tensor(const struct ggml_context *ctx, struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_get_next_tensor(MemorySegment ctx, MemorySegment tensor) {
        var mh$ = ggml_get_next_tensor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_next_tensor", ctx, tensor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_tensor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_tensor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_tensor(struct ggml_context *ctx, const char *name)
     * }
     */
    public static FunctionDescriptor ggml_get_tensor$descriptor() {
        return ggml_get_tensor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_tensor(struct ggml_context *ctx, const char *name)
     * }
     */
    public static MethodHandle ggml_get_tensor$handle() {
        return ggml_get_tensor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_tensor(struct ggml_context *ctx, const char *name)
     * }
     */
    public static MemorySegment ggml_get_tensor$address() {
        return ggml_get_tensor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_tensor(struct ggml_context *ctx, const char *name)
     * }
     */
    public static MemorySegment ggml_get_tensor(MemorySegment ctx, MemorySegment name) {
        var mh$ = ggml_get_tensor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_tensor", ctx, name);
            }
            return (MemorySegment)mh$.invokeExact(ctx, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_unravel_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_unravel_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_unravel_index(const struct ggml_tensor *tensor, int64_t i, int64_t *i0, int64_t *i1, int64_t *i2, int64_t *i3)
     * }
     */
    public static FunctionDescriptor ggml_unravel_index$descriptor() {
        return ggml_unravel_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_unravel_index(const struct ggml_tensor *tensor, int64_t i, int64_t *i0, int64_t *i1, int64_t *i2, int64_t *i3)
     * }
     */
    public static MethodHandle ggml_unravel_index$handle() {
        return ggml_unravel_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_unravel_index(const struct ggml_tensor *tensor, int64_t i, int64_t *i0, int64_t *i1, int64_t *i2, int64_t *i3)
     * }
     */
    public static MemorySegment ggml_unravel_index$address() {
        return ggml_unravel_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_unravel_index(const struct ggml_tensor *tensor, int64_t i, int64_t *i0, int64_t *i1, int64_t *i2, int64_t *i3)
     * }
     */
    public static void ggml_unravel_index(MemorySegment tensor, long i, MemorySegment i0, MemorySegment i1, MemorySegment i2, MemorySegment i3) {
        var mh$ = ggml_unravel_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_unravel_index", tensor, i, i0, i1, i2, i3);
            }
            mh$.invokeExact(tensor, i, i0, i1, i2, i3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_unary_op {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_unary_op");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_unary_op ggml_get_unary_op(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_get_unary_op$descriptor() {
        return ggml_get_unary_op.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_unary_op ggml_get_unary_op(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_get_unary_op$handle() {
        return ggml_get_unary_op.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_unary_op ggml_get_unary_op(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_get_unary_op$address() {
        return ggml_get_unary_op.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_unary_op ggml_get_unary_op(const struct ggml_tensor *tensor)
     * }
     */
    public static int ggml_get_unary_op(MemorySegment tensor) {
        var mh$ = ggml_get_unary_op.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_unary_op", tensor);
            }
            return (int)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_glu_op {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_glu_op");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_glu_op ggml_get_glu_op(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_get_glu_op$descriptor() {
        return ggml_get_glu_op.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_glu_op ggml_get_glu_op(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_get_glu_op$handle() {
        return ggml_get_glu_op.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_glu_op ggml_get_glu_op(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_get_glu_op$address() {
        return ggml_get_glu_op.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_glu_op ggml_get_glu_op(const struct ggml_tensor *tensor)
     * }
     */
    public static int ggml_get_glu_op(MemorySegment tensor) {
        var mh$ = ggml_get_glu_op.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_glu_op", tensor);
            }
            return (int)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *ggml_get_data(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_get_data$descriptor() {
        return ggml_get_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *ggml_get_data(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_get_data$handle() {
        return ggml_get_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *ggml_get_data(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_get_data$address() {
        return ggml_get_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *ggml_get_data(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_get_data(MemorySegment tensor) {
        var mh$ = ggml_get_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_data", tensor);
            }
            return (MemorySegment)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_data_f32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_data_f32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float *ggml_get_data_f32(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_get_data_f32$descriptor() {
        return ggml_get_data_f32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float *ggml_get_data_f32(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_get_data_f32$handle() {
        return ggml_get_data_f32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float *ggml_get_data_f32(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_get_data_f32$address() {
        return ggml_get_data_f32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float *ggml_get_data_f32(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_get_data_f32(MemorySegment tensor) {
        var mh$ = ggml_get_data_f32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_data_f32", tensor);
            }
            return (MemorySegment)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ggml_get_name(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_get_name$descriptor() {
        return ggml_get_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ggml_get_name(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_get_name$handle() {
        return ggml_get_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ggml_get_name(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_get_name$address() {
        return ggml_get_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ggml_get_name(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_get_name(MemorySegment tensor) {
        var mh$ = ggml_get_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_name", tensor);
            }
            return (MemorySegment)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_name(struct ggml_tensor *tensor, const char *name)
     * }
     */
    public static FunctionDescriptor ggml_set_name$descriptor() {
        return ggml_set_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_name(struct ggml_tensor *tensor, const char *name)
     * }
     */
    public static MethodHandle ggml_set_name$handle() {
        return ggml_set_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_name(struct ggml_tensor *tensor, const char *name)
     * }
     */
    public static MemorySegment ggml_set_name$address() {
        return ggml_set_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_name(struct ggml_tensor *tensor, const char *name)
     * }
     */
    public static MemorySegment ggml_set_name(MemorySegment tensor, MemorySegment name) {
        var mh$ = ggml_set_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_name", tensor, name);
            }
            return (MemorySegment)mh$.invokeExact(tensor, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_format_name(struct ggml_tensor *tensor, const char *fmt, ...)
     * }
     */
    public static class ggml_format_name {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                WhisperCpp.C_POINTER,
                WhisperCpp.C_POINTER,
                WhisperCpp.C_POINTER
            );
        private static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_format_name");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private ggml_format_name(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern struct ggml_tensor *ggml_format_name(struct ggml_tensor *tensor, const char *fmt, ...)
         * }
         */
        public static ggml_format_name makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new ggml_format_name(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment tensor, MemorySegment fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("ggml_format_name", tensor, fmt, x2);
                }
                return (MemorySegment) spreader.invokeExact(tensor, fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class ggml_set_input {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set_input");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_set_input(struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_set_input$descriptor() {
        return ggml_set_input.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_set_input(struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_set_input$handle() {
        return ggml_set_input.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_set_input(struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_set_input$address() {
        return ggml_set_input.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_set_input(struct ggml_tensor *tensor)
     * }
     */
    public static void ggml_set_input(MemorySegment tensor) {
        var mh$ = ggml_set_input.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_input", tensor);
            }
            mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_output {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set_output");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_set_output(struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_set_output$descriptor() {
        return ggml_set_output.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_set_output(struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_set_output$handle() {
        return ggml_set_output.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_set_output(struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_set_output$address() {
        return ggml_set_output.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_set_output(struct ggml_tensor *tensor)
     * }
     */
    public static void ggml_set_output(MemorySegment tensor) {
        var mh$ = ggml_set_output.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_output", tensor);
            }
            mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_param {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set_param");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_set_param(struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_set_param$descriptor() {
        return ggml_set_param.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_set_param(struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_set_param$handle() {
        return ggml_set_param.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_set_param(struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_set_param$address() {
        return ggml_set_param.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_set_param(struct ggml_tensor *tensor)
     * }
     */
    public static void ggml_set_param(MemorySegment tensor) {
        var mh$ = ggml_set_param.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_param", tensor);
            }
            mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_loss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set_loss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_set_loss(struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_set_loss$descriptor() {
        return ggml_set_loss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_set_loss(struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_set_loss$handle() {
        return ggml_set_loss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_set_loss(struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_set_loss$address() {
        return ggml_set_loss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_set_loss(struct ggml_tensor *tensor)
     * }
     */
    public static void ggml_set_loss(MemorySegment tensor) {
        var mh$ = ggml_set_loss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_loss", tensor);
            }
            mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_dup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_dup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_dup(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_dup$descriptor() {
        return ggml_dup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_dup(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_dup$handle() {
        return ggml_dup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_dup(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_dup$address() {
        return ggml_dup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_dup(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_dup(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_dup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_dup", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_dup_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_dup_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_dup_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_dup_inplace$descriptor() {
        return ggml_dup_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_dup_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_dup_inplace$handle() {
        return ggml_dup_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_dup_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_dup_inplace$address() {
        return ggml_dup_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_dup_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_dup_inplace(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_dup_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_dup_inplace", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_add$descriptor() {
        return ggml_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_add$handle() {
        return ggml_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_add$address() {
        return ggml_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_add(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_add", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_add_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_add_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_add_inplace$descriptor() {
        return ggml_add_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_add_inplace$handle() {
        return ggml_add_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_add_inplace$address() {
        return ggml_add_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_add_inplace(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_add_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_add_inplace", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_add_cast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_add_cast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_cast(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, enum ggml_type type)
     * }
     */
    public static FunctionDescriptor ggml_add_cast$descriptor() {
        return ggml_add_cast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_cast(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, enum ggml_type type)
     * }
     */
    public static MethodHandle ggml_add_cast$handle() {
        return ggml_add_cast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_cast(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, enum ggml_type type)
     * }
     */
    public static MemorySegment ggml_add_cast$address() {
        return ggml_add_cast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_cast(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, enum ggml_type type)
     * }
     */
    public static MemorySegment ggml_add_cast(MemorySegment ctx, MemorySegment a, MemorySegment b, int type) {
        var mh$ = ggml_add_cast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_add_cast", ctx, a, b, type);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_add1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_add1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add1(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_add1$descriptor() {
        return ggml_add1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add1(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_add1$handle() {
        return ggml_add1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add1(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_add1$address() {
        return ggml_add1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add1(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_add1(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_add1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_add1", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_add1_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_add1_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add1_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_add1_inplace$descriptor() {
        return ggml_add1_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add1_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_add1_inplace$handle() {
        return ggml_add1_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add1_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_add1_inplace$address() {
        return ggml_add1_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add1_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_add1_inplace(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_add1_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_add1_inplace", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_acc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_acc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_acc(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t nb2, size_t nb3, size_t offset)
     * }
     */
    public static FunctionDescriptor ggml_acc$descriptor() {
        return ggml_acc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_acc(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t nb2, size_t nb3, size_t offset)
     * }
     */
    public static MethodHandle ggml_acc$handle() {
        return ggml_acc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_acc(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t nb2, size_t nb3, size_t offset)
     * }
     */
    public static MemorySegment ggml_acc$address() {
        return ggml_acc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_acc(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t nb2, size_t nb3, size_t offset)
     * }
     */
    public static MemorySegment ggml_acc(MemorySegment ctx, MemorySegment a, MemorySegment b, long nb1, long nb2, long nb3, long offset) {
        var mh$ = ggml_acc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_acc", ctx, a, b, nb1, nb2, nb3, offset);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, nb1, nb2, nb3, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_acc_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_acc_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_acc_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t nb2, size_t nb3, size_t offset)
     * }
     */
    public static FunctionDescriptor ggml_acc_inplace$descriptor() {
        return ggml_acc_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_acc_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t nb2, size_t nb3, size_t offset)
     * }
     */
    public static MethodHandle ggml_acc_inplace$handle() {
        return ggml_acc_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_acc_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t nb2, size_t nb3, size_t offset)
     * }
     */
    public static MemorySegment ggml_acc_inplace$address() {
        return ggml_acc_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_acc_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t nb2, size_t nb3, size_t offset)
     * }
     */
    public static MemorySegment ggml_acc_inplace(MemorySegment ctx, MemorySegment a, MemorySegment b, long nb1, long nb2, long nb3, long offset) {
        var mh$ = ggml_acc_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_acc_inplace", ctx, a, b, nb1, nb2, nb3, offset);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, nb1, nb2, nb3, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_sub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_sub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sub(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_sub$descriptor() {
        return ggml_sub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sub(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_sub$handle() {
        return ggml_sub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sub(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_sub$address() {
        return ggml_sub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sub(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_sub(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_sub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_sub", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_sub_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_sub_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sub_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_sub_inplace$descriptor() {
        return ggml_sub_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sub_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_sub_inplace$handle() {
        return ggml_sub_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sub_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_sub_inplace$address() {
        return ggml_sub_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sub_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_sub_inplace(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_sub_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_sub_inplace", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_mul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_mul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_mul(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_mul$descriptor() {
        return ggml_mul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_mul(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_mul$handle() {
        return ggml_mul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_mul(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_mul$address() {
        return ggml_mul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_mul(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_mul(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_mul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_mul", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_mul_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_mul_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_mul_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_mul_inplace$descriptor() {
        return ggml_mul_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_mul_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_mul_inplace$handle() {
        return ggml_mul_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_mul_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_mul_inplace$address() {
        return ggml_mul_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_mul_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_mul_inplace(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_mul_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_mul_inplace", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_div {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_div");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_div(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_div$descriptor() {
        return ggml_div.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_div(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_div$handle() {
        return ggml_div.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_div(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_div$address() {
        return ggml_div.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_div(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_div(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_div.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_div", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_div_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_div_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_div_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_div_inplace$descriptor() {
        return ggml_div_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_div_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_div_inplace$handle() {
        return ggml_div_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_div_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_div_inplace$address() {
        return ggml_div_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_div_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_div_inplace(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_div_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_div_inplace", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_sqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_sqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sqr(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_sqr$descriptor() {
        return ggml_sqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sqr(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_sqr$handle() {
        return ggml_sqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sqr(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sqr$address() {
        return ggml_sqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sqr(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sqr(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_sqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_sqr", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_sqr_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_sqr_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sqr_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_sqr_inplace$descriptor() {
        return ggml_sqr_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sqr_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_sqr_inplace$handle() {
        return ggml_sqr_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sqr_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sqr_inplace$address() {
        return ggml_sqr_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sqr_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sqr_inplace(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_sqr_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_sqr_inplace", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_sqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_sqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sqrt(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_sqrt$descriptor() {
        return ggml_sqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sqrt(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_sqrt$handle() {
        return ggml_sqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sqrt(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sqrt$address() {
        return ggml_sqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sqrt(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sqrt(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_sqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_sqrt", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_sqrt_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_sqrt_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sqrt_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_sqrt_inplace$descriptor() {
        return ggml_sqrt_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sqrt_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_sqrt_inplace$handle() {
        return ggml_sqrt_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sqrt_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sqrt_inplace$address() {
        return ggml_sqrt_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sqrt_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sqrt_inplace(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_sqrt_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_sqrt_inplace", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_log {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_log");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_log(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_log$descriptor() {
        return ggml_log.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_log(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_log$handle() {
        return ggml_log.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_log(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_log$address() {
        return ggml_log.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_log(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_log(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_log.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_log", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_log_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_log_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_log_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_log_inplace$descriptor() {
        return ggml_log_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_log_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_log_inplace$handle() {
        return ggml_log_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_log_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_log_inplace$address() {
        return ggml_log_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_log_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_log_inplace(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_log_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_log_inplace", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_sin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_sin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sin(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_sin$descriptor() {
        return ggml_sin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sin(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_sin$handle() {
        return ggml_sin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sin(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sin$address() {
        return ggml_sin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sin(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sin(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_sin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_sin", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_sin_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_sin_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sin_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_sin_inplace$descriptor() {
        return ggml_sin_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sin_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_sin_inplace$handle() {
        return ggml_sin_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sin_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sin_inplace$address() {
        return ggml_sin_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sin_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sin_inplace(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_sin_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_sin_inplace", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cos(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_cos$descriptor() {
        return ggml_cos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cos(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_cos$handle() {
        return ggml_cos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cos(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_cos$address() {
        return ggml_cos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cos(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_cos(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_cos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cos", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cos_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cos_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cos_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_cos_inplace$descriptor() {
        return ggml_cos_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cos_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_cos_inplace$handle() {
        return ggml_cos_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cos_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_cos_inplace$address() {
        return ggml_cos_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cos_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_cos_inplace(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_cos_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cos_inplace", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_sum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_sum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sum(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_sum$descriptor() {
        return ggml_sum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sum(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_sum$handle() {
        return ggml_sum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sum(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sum$address() {
        return ggml_sum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sum(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sum(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_sum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_sum", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_sum_rows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_sum_rows");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sum_rows(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_sum_rows$descriptor() {
        return ggml_sum_rows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sum_rows(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_sum_rows$handle() {
        return ggml_sum_rows.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sum_rows(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sum_rows$address() {
        return ggml_sum_rows.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sum_rows(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sum_rows(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_sum_rows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_sum_rows", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_mean {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_mean");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_mean(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_mean$descriptor() {
        return ggml_mean.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_mean(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_mean$handle() {
        return ggml_mean.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_mean(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_mean$address() {
        return ggml_mean.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_mean(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_mean(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_mean.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_mean", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_argmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_argmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_argmax(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_argmax$descriptor() {
        return ggml_argmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_argmax(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_argmax$handle() {
        return ggml_argmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_argmax(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_argmax$address() {
        return ggml_argmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_argmax(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_argmax(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_argmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_argmax", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_count_equal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_count_equal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_count_equal(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_count_equal$descriptor() {
        return ggml_count_equal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_count_equal(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_count_equal$handle() {
        return ggml_count_equal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_count_equal(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_count_equal$address() {
        return ggml_count_equal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_count_equal(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_count_equal(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_count_equal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_count_equal", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_repeat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_repeat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_repeat(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_repeat$descriptor() {
        return ggml_repeat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_repeat(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_repeat$handle() {
        return ggml_repeat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_repeat(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_repeat$address() {
        return ggml_repeat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_repeat(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_repeat(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_repeat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_repeat", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_repeat_4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_repeat_4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_repeat_4d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3)
     * }
     */
    public static FunctionDescriptor ggml_repeat_4d$descriptor() {
        return ggml_repeat_4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_repeat_4d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3)
     * }
     */
    public static MethodHandle ggml_repeat_4d$handle() {
        return ggml_repeat_4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_repeat_4d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3)
     * }
     */
    public static MemorySegment ggml_repeat_4d$address() {
        return ggml_repeat_4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_repeat_4d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3)
     * }
     */
    public static MemorySegment ggml_repeat_4d(MemorySegment ctx, MemorySegment a, long ne0, long ne1, long ne2, long ne3) {
        var mh$ = ggml_repeat_4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_repeat_4d", ctx, a, ne0, ne1, ne2, ne3);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, ne0, ne1, ne2, ne3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_repeat_back {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_repeat_back");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_repeat_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_repeat_back$descriptor() {
        return ggml_repeat_back.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_repeat_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_repeat_back$handle() {
        return ggml_repeat_back.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_repeat_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_repeat_back$address() {
        return ggml_repeat_back.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_repeat_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_repeat_back(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_repeat_back.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_repeat_back", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_concat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_concat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_concat(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int dim)
     * }
     */
    public static FunctionDescriptor ggml_concat$descriptor() {
        return ggml_concat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_concat(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int dim)
     * }
     */
    public static MethodHandle ggml_concat$handle() {
        return ggml_concat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_concat(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int dim)
     * }
     */
    public static MemorySegment ggml_concat$address() {
        return ggml_concat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_concat(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int dim)
     * }
     */
    public static MemorySegment ggml_concat(MemorySegment ctx, MemorySegment a, MemorySegment b, int dim) {
        var mh$ = ggml_concat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_concat", ctx, a, b, dim);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, dim);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_abs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_abs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_abs(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_abs$descriptor() {
        return ggml_abs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_abs(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_abs$handle() {
        return ggml_abs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_abs(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_abs$address() {
        return ggml_abs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_abs(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_abs(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_abs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_abs", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_abs_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_abs_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_abs_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_abs_inplace$descriptor() {
        return ggml_abs_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_abs_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_abs_inplace$handle() {
        return ggml_abs_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_abs_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_abs_inplace$address() {
        return ggml_abs_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_abs_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_abs_inplace(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_abs_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_abs_inplace", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_sgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_sgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sgn(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_sgn$descriptor() {
        return ggml_sgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sgn(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_sgn$handle() {
        return ggml_sgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sgn(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sgn$address() {
        return ggml_sgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sgn(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sgn(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_sgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_sgn", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_sgn_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_sgn_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sgn_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_sgn_inplace$descriptor() {
        return ggml_sgn_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sgn_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_sgn_inplace$handle() {
        return ggml_sgn_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sgn_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sgn_inplace$address() {
        return ggml_sgn_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sgn_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sgn_inplace(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_sgn_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_sgn_inplace", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_neg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_neg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_neg(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_neg$descriptor() {
        return ggml_neg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_neg(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_neg$handle() {
        return ggml_neg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_neg(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_neg$address() {
        return ggml_neg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_neg(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_neg(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_neg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_neg", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_neg_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_neg_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_neg_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_neg_inplace$descriptor() {
        return ggml_neg_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_neg_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_neg_inplace$handle() {
        return ggml_neg_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_neg_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_neg_inplace$address() {
        return ggml_neg_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_neg_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_neg_inplace(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_neg_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_neg_inplace", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_step {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_step");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_step(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_step$descriptor() {
        return ggml_step.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_step(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_step$handle() {
        return ggml_step.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_step(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_step$address() {
        return ggml_step.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_step(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_step(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_step.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_step", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_step_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_step_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_step_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_step_inplace$descriptor() {
        return ggml_step_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_step_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_step_inplace$handle() {
        return ggml_step_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_step_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_step_inplace$address() {
        return ggml_step_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_step_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_step_inplace(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_step_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_step_inplace", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_tanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_tanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_tanh(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_tanh$descriptor() {
        return ggml_tanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_tanh(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_tanh$handle() {
        return ggml_tanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_tanh(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_tanh$address() {
        return ggml_tanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_tanh(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_tanh(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_tanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_tanh", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_tanh_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_tanh_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_tanh_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_tanh_inplace$descriptor() {
        return ggml_tanh_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_tanh_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_tanh_inplace$handle() {
        return ggml_tanh_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_tanh_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_tanh_inplace$address() {
        return ggml_tanh_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_tanh_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_tanh_inplace(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_tanh_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_tanh_inplace", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_elu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_elu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_elu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_elu$descriptor() {
        return ggml_elu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_elu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_elu$handle() {
        return ggml_elu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_elu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_elu$address() {
        return ggml_elu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_elu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_elu(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_elu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_elu", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_elu_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_elu_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_elu_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_elu_inplace$descriptor() {
        return ggml_elu_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_elu_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_elu_inplace$handle() {
        return ggml_elu_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_elu_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_elu_inplace$address() {
        return ggml_elu_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_elu_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_elu_inplace(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_elu_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_elu_inplace", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_relu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_relu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_relu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_relu$descriptor() {
        return ggml_relu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_relu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_relu$handle() {
        return ggml_relu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_relu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_relu$address() {
        return ggml_relu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_relu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_relu(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_relu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_relu", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_leaky_relu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_BOOL
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_leaky_relu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_leaky_relu(struct ggml_context *ctx, struct ggml_tensor *a, float negative_slope, bool inplace)
     * }
     */
    public static FunctionDescriptor ggml_leaky_relu$descriptor() {
        return ggml_leaky_relu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_leaky_relu(struct ggml_context *ctx, struct ggml_tensor *a, float negative_slope, bool inplace)
     * }
     */
    public static MethodHandle ggml_leaky_relu$handle() {
        return ggml_leaky_relu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_leaky_relu(struct ggml_context *ctx, struct ggml_tensor *a, float negative_slope, bool inplace)
     * }
     */
    public static MemorySegment ggml_leaky_relu$address() {
        return ggml_leaky_relu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_leaky_relu(struct ggml_context *ctx, struct ggml_tensor *a, float negative_slope, bool inplace)
     * }
     */
    public static MemorySegment ggml_leaky_relu(MemorySegment ctx, MemorySegment a, float negative_slope, boolean inplace) {
        var mh$ = ggml_leaky_relu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_leaky_relu", ctx, a, negative_slope, inplace);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, negative_slope, inplace);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_relu_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_relu_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_relu_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_relu_inplace$descriptor() {
        return ggml_relu_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_relu_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_relu_inplace$handle() {
        return ggml_relu_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_relu_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_relu_inplace$address() {
        return ggml_relu_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_relu_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_relu_inplace(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_relu_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_relu_inplace", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_sigmoid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_sigmoid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sigmoid(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_sigmoid$descriptor() {
        return ggml_sigmoid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sigmoid(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_sigmoid$handle() {
        return ggml_sigmoid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sigmoid(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sigmoid$address() {
        return ggml_sigmoid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sigmoid(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sigmoid(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_sigmoid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_sigmoid", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_sigmoid_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_sigmoid_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sigmoid_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_sigmoid_inplace$descriptor() {
        return ggml_sigmoid_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sigmoid_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_sigmoid_inplace$handle() {
        return ggml_sigmoid_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sigmoid_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sigmoid_inplace$address() {
        return ggml_sigmoid_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sigmoid_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sigmoid_inplace(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_sigmoid_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_sigmoid_inplace", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_gelu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_gelu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_gelu$descriptor() {
        return ggml_gelu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_gelu$handle() {
        return ggml_gelu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_gelu$address() {
        return ggml_gelu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_gelu(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_gelu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_gelu", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_gelu_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_gelu_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_gelu_inplace$descriptor() {
        return ggml_gelu_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_gelu_inplace$handle() {
        return ggml_gelu_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_gelu_inplace$address() {
        return ggml_gelu_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_gelu_inplace(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_gelu_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_gelu_inplace", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_gelu_erf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_gelu_erf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu_erf(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_gelu_erf$descriptor() {
        return ggml_gelu_erf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu_erf(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_gelu_erf$handle() {
        return ggml_gelu_erf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu_erf(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_gelu_erf$address() {
        return ggml_gelu_erf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu_erf(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_gelu_erf(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_gelu_erf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_gelu_erf", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_gelu_erf_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_gelu_erf_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu_erf_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_gelu_erf_inplace$descriptor() {
        return ggml_gelu_erf_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu_erf_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_gelu_erf_inplace$handle() {
        return ggml_gelu_erf_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu_erf_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_gelu_erf_inplace$address() {
        return ggml_gelu_erf_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu_erf_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_gelu_erf_inplace(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_gelu_erf_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_gelu_erf_inplace", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_gelu_quick {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_gelu_quick");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu_quick(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_gelu_quick$descriptor() {
        return ggml_gelu_quick.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu_quick(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_gelu_quick$handle() {
        return ggml_gelu_quick.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu_quick(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_gelu_quick$address() {
        return ggml_gelu_quick.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu_quick(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_gelu_quick(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_gelu_quick.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_gelu_quick", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_gelu_quick_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_gelu_quick_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu_quick_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_gelu_quick_inplace$descriptor() {
        return ggml_gelu_quick_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu_quick_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_gelu_quick_inplace$handle() {
        return ggml_gelu_quick_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu_quick_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_gelu_quick_inplace$address() {
        return ggml_gelu_quick_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu_quick_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_gelu_quick_inplace(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_gelu_quick_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_gelu_quick_inplace", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_silu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_silu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_silu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_silu$descriptor() {
        return ggml_silu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_silu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_silu$handle() {
        return ggml_silu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_silu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_silu$address() {
        return ggml_silu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_silu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_silu(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_silu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_silu", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_silu_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_silu_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_silu_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_silu_inplace$descriptor() {
        return ggml_silu_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_silu_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_silu_inplace$handle() {
        return ggml_silu_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_silu_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_silu_inplace$address() {
        return ggml_silu_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_silu_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_silu_inplace(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_silu_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_silu_inplace", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_silu_back {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_silu_back");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_silu_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_silu_back$descriptor() {
        return ggml_silu_back.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_silu_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_silu_back$handle() {
        return ggml_silu_back.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_silu_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_silu_back$address() {
        return ggml_silu_back.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_silu_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_silu_back(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_silu_back.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_silu_back", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_hardswish {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_hardswish");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_hardswish(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_hardswish$descriptor() {
        return ggml_hardswish.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_hardswish(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_hardswish$handle() {
        return ggml_hardswish.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_hardswish(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_hardswish$address() {
        return ggml_hardswish.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_hardswish(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_hardswish(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_hardswish.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_hardswish", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_hardsigmoid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_hardsigmoid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_hardsigmoid(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_hardsigmoid$descriptor() {
        return ggml_hardsigmoid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_hardsigmoid(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_hardsigmoid$handle() {
        return ggml_hardsigmoid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_hardsigmoid(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_hardsigmoid$address() {
        return ggml_hardsigmoid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_hardsigmoid(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_hardsigmoid(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_hardsigmoid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_hardsigmoid", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_exp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_exp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_exp(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_exp$descriptor() {
        return ggml_exp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_exp(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_exp$handle() {
        return ggml_exp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_exp(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_exp$address() {
        return ggml_exp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_exp(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_exp(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_exp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_exp", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_exp_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_exp_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_exp_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_exp_inplace$descriptor() {
        return ggml_exp_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_exp_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_exp_inplace$handle() {
        return ggml_exp_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_exp_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_exp_inplace$address() {
        return ggml_exp_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_exp_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_exp_inplace(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_exp_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_exp_inplace", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_glu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_BOOL
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_glu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_glu(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_glu_op op, bool swapped)
     * }
     */
    public static FunctionDescriptor ggml_glu$descriptor() {
        return ggml_glu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_glu(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_glu_op op, bool swapped)
     * }
     */
    public static MethodHandle ggml_glu$handle() {
        return ggml_glu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_glu(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_glu_op op, bool swapped)
     * }
     */
    public static MemorySegment ggml_glu$address() {
        return ggml_glu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_glu(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_glu_op op, bool swapped)
     * }
     */
    public static MemorySegment ggml_glu(MemorySegment ctx, MemorySegment a, int op, boolean swapped) {
        var mh$ = ggml_glu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_glu", ctx, a, op, swapped);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, op, swapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_reglu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_reglu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reglu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_reglu$descriptor() {
        return ggml_reglu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reglu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_reglu$handle() {
        return ggml_reglu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reglu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_reglu$address() {
        return ggml_reglu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reglu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_reglu(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_reglu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_reglu", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_reglu_swapped {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_reglu_swapped");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reglu_swapped(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_reglu_swapped$descriptor() {
        return ggml_reglu_swapped.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reglu_swapped(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_reglu_swapped$handle() {
        return ggml_reglu_swapped.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reglu_swapped(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_reglu_swapped$address() {
        return ggml_reglu_swapped.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reglu_swapped(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_reglu_swapped(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_reglu_swapped.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_reglu_swapped", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_geglu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_geglu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_geglu$descriptor() {
        return ggml_geglu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_geglu$handle() {
        return ggml_geglu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_geglu$address() {
        return ggml_geglu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_geglu(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_geglu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_geglu", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_geglu_swapped {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_geglu_swapped");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_swapped(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_geglu_swapped$descriptor() {
        return ggml_geglu_swapped.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_swapped(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_geglu_swapped$handle() {
        return ggml_geglu_swapped.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_swapped(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_geglu_swapped$address() {
        return ggml_geglu_swapped.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_swapped(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_geglu_swapped(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_geglu_swapped.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_geglu_swapped", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_swiglu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_swiglu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_swiglu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_swiglu$descriptor() {
        return ggml_swiglu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_swiglu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_swiglu$handle() {
        return ggml_swiglu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_swiglu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_swiglu$address() {
        return ggml_swiglu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_swiglu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_swiglu(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_swiglu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_swiglu", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_swiglu_swapped {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_swiglu_swapped");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_swiglu_swapped(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_swiglu_swapped$descriptor() {
        return ggml_swiglu_swapped.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_swiglu_swapped(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_swiglu_swapped$handle() {
        return ggml_swiglu_swapped.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_swiglu_swapped(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_swiglu_swapped$address() {
        return ggml_swiglu_swapped.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_swiglu_swapped(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_swiglu_swapped(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_swiglu_swapped.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_swiglu_swapped", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_geglu_erf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_geglu_erf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_erf(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_geglu_erf$descriptor() {
        return ggml_geglu_erf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_erf(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_geglu_erf$handle() {
        return ggml_geglu_erf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_erf(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_geglu_erf$address() {
        return ggml_geglu_erf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_erf(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_geglu_erf(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_geglu_erf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_geglu_erf", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_geglu_erf_swapped {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_geglu_erf_swapped");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_erf_swapped(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_geglu_erf_swapped$descriptor() {
        return ggml_geglu_erf_swapped.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_erf_swapped(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_geglu_erf_swapped$handle() {
        return ggml_geglu_erf_swapped.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_erf_swapped(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_geglu_erf_swapped$address() {
        return ggml_geglu_erf_swapped.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_erf_swapped(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_geglu_erf_swapped(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_geglu_erf_swapped.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_geglu_erf_swapped", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_geglu_quick {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_geglu_quick");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_quick(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_geglu_quick$descriptor() {
        return ggml_geglu_quick.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_quick(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_geglu_quick$handle() {
        return ggml_geglu_quick.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_quick(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_geglu_quick$address() {
        return ggml_geglu_quick.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_quick(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_geglu_quick(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_geglu_quick.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_geglu_quick", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_geglu_quick_swapped {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_geglu_quick_swapped");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_quick_swapped(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_geglu_quick_swapped$descriptor() {
        return ggml_geglu_quick_swapped.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_quick_swapped(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_geglu_quick_swapped$handle() {
        return ggml_geglu_quick_swapped.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_quick_swapped(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_geglu_quick_swapped$address() {
        return ggml_geglu_quick_swapped.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_quick_swapped(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_geglu_quick_swapped(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_geglu_quick_swapped.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_geglu_quick_swapped", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_glu_split {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_glu_split");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_glu_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, enum ggml_glu_op op)
     * }
     */
    public static FunctionDescriptor ggml_glu_split$descriptor() {
        return ggml_glu_split.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_glu_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, enum ggml_glu_op op)
     * }
     */
    public static MethodHandle ggml_glu_split$handle() {
        return ggml_glu_split.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_glu_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, enum ggml_glu_op op)
     * }
     */
    public static MemorySegment ggml_glu_split$address() {
        return ggml_glu_split.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_glu_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, enum ggml_glu_op op)
     * }
     */
    public static MemorySegment ggml_glu_split(MemorySegment ctx, MemorySegment a, MemorySegment b, int op) {
        var mh$ = ggml_glu_split.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_glu_split", ctx, a, b, op);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_reglu_split {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_reglu_split");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reglu_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_reglu_split$descriptor() {
        return ggml_reglu_split.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reglu_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_reglu_split$handle() {
        return ggml_reglu_split.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reglu_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_reglu_split$address() {
        return ggml_reglu_split.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reglu_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_reglu_split(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_reglu_split.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_reglu_split", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_geglu_split {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_geglu_split");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_geglu_split$descriptor() {
        return ggml_geglu_split.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_geglu_split$handle() {
        return ggml_geglu_split.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_geglu_split$address() {
        return ggml_geglu_split.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_geglu_split(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_geglu_split.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_geglu_split", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_swiglu_split {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_swiglu_split");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_swiglu_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_swiglu_split$descriptor() {
        return ggml_swiglu_split.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_swiglu_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_swiglu_split$handle() {
        return ggml_swiglu_split.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_swiglu_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_swiglu_split$address() {
        return ggml_swiglu_split.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_swiglu_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_swiglu_split(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_swiglu_split.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_swiglu_split", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_geglu_erf_split {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_geglu_erf_split");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_erf_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_geglu_erf_split$descriptor() {
        return ggml_geglu_erf_split.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_erf_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_geglu_erf_split$handle() {
        return ggml_geglu_erf_split.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_erf_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_geglu_erf_split$address() {
        return ggml_geglu_erf_split.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_erf_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_geglu_erf_split(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_geglu_erf_split.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_geglu_erf_split", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_geglu_quick_split {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_geglu_quick_split");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_quick_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_geglu_quick_split$descriptor() {
        return ggml_geglu_quick_split.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_quick_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_geglu_quick_split$handle() {
        return ggml_geglu_quick_split.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_quick_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_geglu_quick_split$address() {
        return ggml_geglu_quick_split.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_quick_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_geglu_quick_split(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_geglu_quick_split.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_geglu_quick_split", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_norm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_norm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_norm(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static FunctionDescriptor ggml_norm$descriptor() {
        return ggml_norm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_norm(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static MethodHandle ggml_norm$handle() {
        return ggml_norm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_norm(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static MemorySegment ggml_norm$address() {
        return ggml_norm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_norm(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static MemorySegment ggml_norm(MemorySegment ctx, MemorySegment a, float eps) {
        var mh$ = ggml_norm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_norm", ctx, a, eps);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, eps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_norm_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_norm_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_norm_inplace(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static FunctionDescriptor ggml_norm_inplace$descriptor() {
        return ggml_norm_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_norm_inplace(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static MethodHandle ggml_norm_inplace$handle() {
        return ggml_norm_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_norm_inplace(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static MemorySegment ggml_norm_inplace$address() {
        return ggml_norm_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_norm_inplace(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static MemorySegment ggml_norm_inplace(MemorySegment ctx, MemorySegment a, float eps) {
        var mh$ = ggml_norm_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_norm_inplace", ctx, a, eps);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, eps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_rms_norm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_rms_norm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rms_norm(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static FunctionDescriptor ggml_rms_norm$descriptor() {
        return ggml_rms_norm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rms_norm(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static MethodHandle ggml_rms_norm$handle() {
        return ggml_rms_norm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rms_norm(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static MemorySegment ggml_rms_norm$address() {
        return ggml_rms_norm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rms_norm(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static MemorySegment ggml_rms_norm(MemorySegment ctx, MemorySegment a, float eps) {
        var mh$ = ggml_rms_norm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_rms_norm", ctx, a, eps);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, eps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_rms_norm_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_rms_norm_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rms_norm_inplace(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static FunctionDescriptor ggml_rms_norm_inplace$descriptor() {
        return ggml_rms_norm_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rms_norm_inplace(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static MethodHandle ggml_rms_norm_inplace$handle() {
        return ggml_rms_norm_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rms_norm_inplace(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static MemorySegment ggml_rms_norm_inplace$address() {
        return ggml_rms_norm_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rms_norm_inplace(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static MemorySegment ggml_rms_norm_inplace(MemorySegment ctx, MemorySegment a, float eps) {
        var mh$ = ggml_rms_norm_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_rms_norm_inplace", ctx, a, eps);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, eps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_group_norm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_group_norm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_group_norm(struct ggml_context *ctx, struct ggml_tensor *a, int n_groups, float eps)
     * }
     */
    public static FunctionDescriptor ggml_group_norm$descriptor() {
        return ggml_group_norm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_group_norm(struct ggml_context *ctx, struct ggml_tensor *a, int n_groups, float eps)
     * }
     */
    public static MethodHandle ggml_group_norm$handle() {
        return ggml_group_norm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_group_norm(struct ggml_context *ctx, struct ggml_tensor *a, int n_groups, float eps)
     * }
     */
    public static MemorySegment ggml_group_norm$address() {
        return ggml_group_norm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_group_norm(struct ggml_context *ctx, struct ggml_tensor *a, int n_groups, float eps)
     * }
     */
    public static MemorySegment ggml_group_norm(MemorySegment ctx, MemorySegment a, int n_groups, float eps) {
        var mh$ = ggml_group_norm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_group_norm", ctx, a, n_groups, eps);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, n_groups, eps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_group_norm_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_group_norm_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_group_norm_inplace(struct ggml_context *ctx, struct ggml_tensor *a, int n_groups, float eps)
     * }
     */
    public static FunctionDescriptor ggml_group_norm_inplace$descriptor() {
        return ggml_group_norm_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_group_norm_inplace(struct ggml_context *ctx, struct ggml_tensor *a, int n_groups, float eps)
     * }
     */
    public static MethodHandle ggml_group_norm_inplace$handle() {
        return ggml_group_norm_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_group_norm_inplace(struct ggml_context *ctx, struct ggml_tensor *a, int n_groups, float eps)
     * }
     */
    public static MemorySegment ggml_group_norm_inplace$address() {
        return ggml_group_norm_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_group_norm_inplace(struct ggml_context *ctx, struct ggml_tensor *a, int n_groups, float eps)
     * }
     */
    public static MemorySegment ggml_group_norm_inplace(MemorySegment ctx, MemorySegment a, int n_groups, float eps) {
        var mh$ = ggml_group_norm_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_group_norm_inplace", ctx, a, n_groups, eps);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, n_groups, eps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_l2_norm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_l2_norm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_l2_norm(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static FunctionDescriptor ggml_l2_norm$descriptor() {
        return ggml_l2_norm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_l2_norm(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static MethodHandle ggml_l2_norm$handle() {
        return ggml_l2_norm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_l2_norm(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static MemorySegment ggml_l2_norm$address() {
        return ggml_l2_norm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_l2_norm(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static MemorySegment ggml_l2_norm(MemorySegment ctx, MemorySegment a, float eps) {
        var mh$ = ggml_l2_norm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_l2_norm", ctx, a, eps);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, eps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_l2_norm_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_l2_norm_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_l2_norm_inplace(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static FunctionDescriptor ggml_l2_norm_inplace$descriptor() {
        return ggml_l2_norm_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_l2_norm_inplace(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static MethodHandle ggml_l2_norm_inplace$handle() {
        return ggml_l2_norm_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_l2_norm_inplace(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static MemorySegment ggml_l2_norm_inplace$address() {
        return ggml_l2_norm_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_l2_norm_inplace(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static MemorySegment ggml_l2_norm_inplace(MemorySegment ctx, MemorySegment a, float eps) {
        var mh$ = ggml_l2_norm_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_l2_norm_inplace", ctx, a, eps);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, eps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_rms_norm_back {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_rms_norm_back");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rms_norm_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, float eps)
     * }
     */
    public static FunctionDescriptor ggml_rms_norm_back$descriptor() {
        return ggml_rms_norm_back.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rms_norm_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, float eps)
     * }
     */
    public static MethodHandle ggml_rms_norm_back$handle() {
        return ggml_rms_norm_back.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rms_norm_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, float eps)
     * }
     */
    public static MemorySegment ggml_rms_norm_back$address() {
        return ggml_rms_norm_back.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rms_norm_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, float eps)
     * }
     */
    public static MemorySegment ggml_rms_norm_back(MemorySegment ctx, MemorySegment a, MemorySegment b, float eps) {
        var mh$ = ggml_rms_norm_back.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_rms_norm_back", ctx, a, b, eps);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, eps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_mul_mat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_mul_mat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_mul_mat(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_mul_mat$descriptor() {
        return ggml_mul_mat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_mul_mat(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_mul_mat$handle() {
        return ggml_mul_mat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_mul_mat(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_mul_mat$address() {
        return ggml_mul_mat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_mul_mat(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_mul_mat(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_mul_mat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_mul_mat", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_mul_mat_set_prec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_mul_mat_set_prec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_mul_mat_set_prec(struct ggml_tensor *a, enum ggml_prec prec)
     * }
     */
    public static FunctionDescriptor ggml_mul_mat_set_prec$descriptor() {
        return ggml_mul_mat_set_prec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_mul_mat_set_prec(struct ggml_tensor *a, enum ggml_prec prec)
     * }
     */
    public static MethodHandle ggml_mul_mat_set_prec$handle() {
        return ggml_mul_mat_set_prec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_mul_mat_set_prec(struct ggml_tensor *a, enum ggml_prec prec)
     * }
     */
    public static MemorySegment ggml_mul_mat_set_prec$address() {
        return ggml_mul_mat_set_prec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_mul_mat_set_prec(struct ggml_tensor *a, enum ggml_prec prec)
     * }
     */
    public static void ggml_mul_mat_set_prec(MemorySegment a, int prec) {
        var mh$ = ggml_mul_mat_set_prec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_mul_mat_set_prec", a, prec);
            }
            mh$.invokeExact(a, prec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_mul_mat_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_mul_mat_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_mul_mat_id(struct ggml_context *ctx, struct ggml_tensor *as, struct ggml_tensor *b, struct ggml_tensor *ids)
     * }
     */
    public static FunctionDescriptor ggml_mul_mat_id$descriptor() {
        return ggml_mul_mat_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_mul_mat_id(struct ggml_context *ctx, struct ggml_tensor *as, struct ggml_tensor *b, struct ggml_tensor *ids)
     * }
     */
    public static MethodHandle ggml_mul_mat_id$handle() {
        return ggml_mul_mat_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_mul_mat_id(struct ggml_context *ctx, struct ggml_tensor *as, struct ggml_tensor *b, struct ggml_tensor *ids)
     * }
     */
    public static MemorySegment ggml_mul_mat_id$address() {
        return ggml_mul_mat_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_mul_mat_id(struct ggml_context *ctx, struct ggml_tensor *as, struct ggml_tensor *b, struct ggml_tensor *ids)
     * }
     */
    public static MemorySegment ggml_mul_mat_id(MemorySegment ctx, MemorySegment as, MemorySegment b, MemorySegment ids) {
        var mh$ = ggml_mul_mat_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_mul_mat_id", ctx, as, b, ids);
            }
            return (MemorySegment)mh$.invokeExact(ctx, as, b, ids);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_out_prod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_out_prod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_out_prod(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_out_prod$descriptor() {
        return ggml_out_prod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_out_prod(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_out_prod$handle() {
        return ggml_out_prod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_out_prod(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_out_prod$address() {
        return ggml_out_prod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_out_prod(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_out_prod(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_out_prod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_out_prod", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_scale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_scale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_scale(struct ggml_context *ctx, struct ggml_tensor *a, float s)
     * }
     */
    public static FunctionDescriptor ggml_scale$descriptor() {
        return ggml_scale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_scale(struct ggml_context *ctx, struct ggml_tensor *a, float s)
     * }
     */
    public static MethodHandle ggml_scale$handle() {
        return ggml_scale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_scale(struct ggml_context *ctx, struct ggml_tensor *a, float s)
     * }
     */
    public static MemorySegment ggml_scale$address() {
        return ggml_scale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_scale(struct ggml_context *ctx, struct ggml_tensor *a, float s)
     * }
     */
    public static MemorySegment ggml_scale(MemorySegment ctx, MemorySegment a, float s) {
        var mh$ = ggml_scale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_scale", ctx, a, s);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_scale_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_scale_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_scale_inplace(struct ggml_context *ctx, struct ggml_tensor *a, float s)
     * }
     */
    public static FunctionDescriptor ggml_scale_inplace$descriptor() {
        return ggml_scale_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_scale_inplace(struct ggml_context *ctx, struct ggml_tensor *a, float s)
     * }
     */
    public static MethodHandle ggml_scale_inplace$handle() {
        return ggml_scale_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_scale_inplace(struct ggml_context *ctx, struct ggml_tensor *a, float s)
     * }
     */
    public static MemorySegment ggml_scale_inplace$address() {
        return ggml_scale_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_scale_inplace(struct ggml_context *ctx, struct ggml_tensor *a, float s)
     * }
     */
    public static MemorySegment ggml_scale_inplace(MemorySegment ctx, MemorySegment a, float s) {
        var mh$ = ggml_scale_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_scale_inplace", ctx, a, s);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_scale_bias {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_scale_bias");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_scale_bias(struct ggml_context *ctx, struct ggml_tensor *a, float s, float b)
     * }
     */
    public static FunctionDescriptor ggml_scale_bias$descriptor() {
        return ggml_scale_bias.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_scale_bias(struct ggml_context *ctx, struct ggml_tensor *a, float s, float b)
     * }
     */
    public static MethodHandle ggml_scale_bias$handle() {
        return ggml_scale_bias.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_scale_bias(struct ggml_context *ctx, struct ggml_tensor *a, float s, float b)
     * }
     */
    public static MemorySegment ggml_scale_bias$address() {
        return ggml_scale_bias.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_scale_bias(struct ggml_context *ctx, struct ggml_tensor *a, float s, float b)
     * }
     */
    public static MemorySegment ggml_scale_bias(MemorySegment ctx, MemorySegment a, float s, float b) {
        var mh$ = ggml_scale_bias.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_scale_bias", ctx, a, s, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, s, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_scale_bias_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_scale_bias_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_scale_bias_inplace(struct ggml_context *ctx, struct ggml_tensor *a, float s, float b)
     * }
     */
    public static FunctionDescriptor ggml_scale_bias_inplace$descriptor() {
        return ggml_scale_bias_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_scale_bias_inplace(struct ggml_context *ctx, struct ggml_tensor *a, float s, float b)
     * }
     */
    public static MethodHandle ggml_scale_bias_inplace$handle() {
        return ggml_scale_bias_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_scale_bias_inplace(struct ggml_context *ctx, struct ggml_tensor *a, float s, float b)
     * }
     */
    public static MemorySegment ggml_scale_bias_inplace$address() {
        return ggml_scale_bias_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_scale_bias_inplace(struct ggml_context *ctx, struct ggml_tensor *a, float s, float b)
     * }
     */
    public static MemorySegment ggml_scale_bias_inplace(MemorySegment ctx, MemorySegment a, float s, float b) {
        var mh$ = ggml_scale_bias_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_scale_bias_inplace", ctx, a, s, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, s, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t nb2, size_t nb3, size_t offset)
     * }
     */
    public static FunctionDescriptor ggml_set$descriptor() {
        return ggml_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t nb2, size_t nb3, size_t offset)
     * }
     */
    public static MethodHandle ggml_set$handle() {
        return ggml_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t nb2, size_t nb3, size_t offset)
     * }
     */
    public static MemorySegment ggml_set$address() {
        return ggml_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t nb2, size_t nb3, size_t offset)
     * }
     */
    public static MemorySegment ggml_set(MemorySegment ctx, MemorySegment a, MemorySegment b, long nb1, long nb2, long nb3, long offset) {
        var mh$ = ggml_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set", ctx, a, b, nb1, nb2, nb3, offset);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, nb1, nb2, nb3, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t nb2, size_t nb3, size_t offset)
     * }
     */
    public static FunctionDescriptor ggml_set_inplace$descriptor() {
        return ggml_set_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t nb2, size_t nb3, size_t offset)
     * }
     */
    public static MethodHandle ggml_set_inplace$handle() {
        return ggml_set_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t nb2, size_t nb3, size_t offset)
     * }
     */
    public static MemorySegment ggml_set_inplace$address() {
        return ggml_set_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t nb2, size_t nb3, size_t offset)
     * }
     */
    public static MemorySegment ggml_set_inplace(MemorySegment ctx, MemorySegment a, MemorySegment b, long nb1, long nb2, long nb3, long offset) {
        var mh$ = ggml_set_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_inplace", ctx, a, b, nb1, nb2, nb3, offset);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, nb1, nb2, nb3, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set_1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_1d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t offset)
     * }
     */
    public static FunctionDescriptor ggml_set_1d$descriptor() {
        return ggml_set_1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_1d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t offset)
     * }
     */
    public static MethodHandle ggml_set_1d$handle() {
        return ggml_set_1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_1d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t offset)
     * }
     */
    public static MemorySegment ggml_set_1d$address() {
        return ggml_set_1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_1d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t offset)
     * }
     */
    public static MemorySegment ggml_set_1d(MemorySegment ctx, MemorySegment a, MemorySegment b, long offset) {
        var mh$ = ggml_set_1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_1d", ctx, a, b, offset);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_1d_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set_1d_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_1d_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t offset)
     * }
     */
    public static FunctionDescriptor ggml_set_1d_inplace$descriptor() {
        return ggml_set_1d_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_1d_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t offset)
     * }
     */
    public static MethodHandle ggml_set_1d_inplace$handle() {
        return ggml_set_1d_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_1d_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t offset)
     * }
     */
    public static MemorySegment ggml_set_1d_inplace$address() {
        return ggml_set_1d_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_1d_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t offset)
     * }
     */
    public static MemorySegment ggml_set_1d_inplace(MemorySegment ctx, MemorySegment a, MemorySegment b, long offset) {
        var mh$ = ggml_set_1d_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_1d_inplace", ctx, a, b, offset);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set_2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_2d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t offset)
     * }
     */
    public static FunctionDescriptor ggml_set_2d$descriptor() {
        return ggml_set_2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_2d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t offset)
     * }
     */
    public static MethodHandle ggml_set_2d$handle() {
        return ggml_set_2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_2d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t offset)
     * }
     */
    public static MemorySegment ggml_set_2d$address() {
        return ggml_set_2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_2d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t offset)
     * }
     */
    public static MemorySegment ggml_set_2d(MemorySegment ctx, MemorySegment a, MemorySegment b, long nb1, long offset) {
        var mh$ = ggml_set_2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_2d", ctx, a, b, nb1, offset);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, nb1, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_2d_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set_2d_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_2d_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t offset)
     * }
     */
    public static FunctionDescriptor ggml_set_2d_inplace$descriptor() {
        return ggml_set_2d_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_2d_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t offset)
     * }
     */
    public static MethodHandle ggml_set_2d_inplace$handle() {
        return ggml_set_2d_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_2d_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t offset)
     * }
     */
    public static MemorySegment ggml_set_2d_inplace$address() {
        return ggml_set_2d_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_2d_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t offset)
     * }
     */
    public static MemorySegment ggml_set_2d_inplace(MemorySegment ctx, MemorySegment a, MemorySegment b, long nb1, long offset) {
        var mh$ = ggml_set_2d_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_2d_inplace", ctx, a, b, nb1, offset);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, nb1, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cpy(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_cpy$descriptor() {
        return ggml_cpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cpy(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_cpy$handle() {
        return ggml_cpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cpy(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_cpy$address() {
        return ggml_cpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cpy(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_cpy(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_cpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpy", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cast(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_type type)
     * }
     */
    public static FunctionDescriptor ggml_cast$descriptor() {
        return ggml_cast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cast(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_type type)
     * }
     */
    public static MethodHandle ggml_cast$handle() {
        return ggml_cast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cast(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_type type)
     * }
     */
    public static MemorySegment ggml_cast$address() {
        return ggml_cast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cast(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_type type)
     * }
     */
    public static MemorySegment ggml_cast(MemorySegment ctx, MemorySegment a, int type) {
        var mh$ = ggml_cast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cast", ctx, a, type);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cont {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cont");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cont(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_cont$descriptor() {
        return ggml_cont.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cont(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_cont$handle() {
        return ggml_cont.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cont(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_cont$address() {
        return ggml_cont.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cont(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_cont(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_cont.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cont", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cont_1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cont_1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cont_1d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0)
     * }
     */
    public static FunctionDescriptor ggml_cont_1d$descriptor() {
        return ggml_cont_1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cont_1d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0)
     * }
     */
    public static MethodHandle ggml_cont_1d$handle() {
        return ggml_cont_1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cont_1d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0)
     * }
     */
    public static MemorySegment ggml_cont_1d$address() {
        return ggml_cont_1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cont_1d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0)
     * }
     */
    public static MemorySegment ggml_cont_1d(MemorySegment ctx, MemorySegment a, long ne0) {
        var mh$ = ggml_cont_1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cont_1d", ctx, a, ne0);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, ne0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cont_2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cont_2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cont_2d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1)
     * }
     */
    public static FunctionDescriptor ggml_cont_2d$descriptor() {
        return ggml_cont_2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cont_2d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1)
     * }
     */
    public static MethodHandle ggml_cont_2d$handle() {
        return ggml_cont_2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cont_2d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1)
     * }
     */
    public static MemorySegment ggml_cont_2d$address() {
        return ggml_cont_2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cont_2d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1)
     * }
     */
    public static MemorySegment ggml_cont_2d(MemorySegment ctx, MemorySegment a, long ne0, long ne1) {
        var mh$ = ggml_cont_2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cont_2d", ctx, a, ne0, ne1);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, ne0, ne1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cont_3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cont_3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cont_3d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2)
     * }
     */
    public static FunctionDescriptor ggml_cont_3d$descriptor() {
        return ggml_cont_3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cont_3d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2)
     * }
     */
    public static MethodHandle ggml_cont_3d$handle() {
        return ggml_cont_3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cont_3d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2)
     * }
     */
    public static MemorySegment ggml_cont_3d$address() {
        return ggml_cont_3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cont_3d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2)
     * }
     */
    public static MemorySegment ggml_cont_3d(MemorySegment ctx, MemorySegment a, long ne0, long ne1, long ne2) {
        var mh$ = ggml_cont_3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cont_3d", ctx, a, ne0, ne1, ne2);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, ne0, ne1, ne2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cont_4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cont_4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cont_4d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3)
     * }
     */
    public static FunctionDescriptor ggml_cont_4d$descriptor() {
        return ggml_cont_4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cont_4d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3)
     * }
     */
    public static MethodHandle ggml_cont_4d$handle() {
        return ggml_cont_4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cont_4d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3)
     * }
     */
    public static MemorySegment ggml_cont_4d$address() {
        return ggml_cont_4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cont_4d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3)
     * }
     */
    public static MemorySegment ggml_cont_4d(MemorySegment ctx, MemorySegment a, long ne0, long ne1, long ne2, long ne3) {
        var mh$ = ggml_cont_4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cont_4d", ctx, a, ne0, ne1, ne2, ne3);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, ne0, ne1, ne2, ne3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_reshape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_reshape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reshape(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_reshape$descriptor() {
        return ggml_reshape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reshape(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_reshape$handle() {
        return ggml_reshape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reshape(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_reshape$address() {
        return ggml_reshape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reshape(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_reshape(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_reshape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_reshape", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_reshape_1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_reshape_1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reshape_1d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0)
     * }
     */
    public static FunctionDescriptor ggml_reshape_1d$descriptor() {
        return ggml_reshape_1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reshape_1d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0)
     * }
     */
    public static MethodHandle ggml_reshape_1d$handle() {
        return ggml_reshape_1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reshape_1d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0)
     * }
     */
    public static MemorySegment ggml_reshape_1d$address() {
        return ggml_reshape_1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reshape_1d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0)
     * }
     */
    public static MemorySegment ggml_reshape_1d(MemorySegment ctx, MemorySegment a, long ne0) {
        var mh$ = ggml_reshape_1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_reshape_1d", ctx, a, ne0);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, ne0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_reshape_2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_reshape_2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reshape_2d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1)
     * }
     */
    public static FunctionDescriptor ggml_reshape_2d$descriptor() {
        return ggml_reshape_2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reshape_2d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1)
     * }
     */
    public static MethodHandle ggml_reshape_2d$handle() {
        return ggml_reshape_2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reshape_2d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1)
     * }
     */
    public static MemorySegment ggml_reshape_2d$address() {
        return ggml_reshape_2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reshape_2d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1)
     * }
     */
    public static MemorySegment ggml_reshape_2d(MemorySegment ctx, MemorySegment a, long ne0, long ne1) {
        var mh$ = ggml_reshape_2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_reshape_2d", ctx, a, ne0, ne1);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, ne0, ne1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_reshape_3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_reshape_3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reshape_3d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2)
     * }
     */
    public static FunctionDescriptor ggml_reshape_3d$descriptor() {
        return ggml_reshape_3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reshape_3d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2)
     * }
     */
    public static MethodHandle ggml_reshape_3d$handle() {
        return ggml_reshape_3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reshape_3d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2)
     * }
     */
    public static MemorySegment ggml_reshape_3d$address() {
        return ggml_reshape_3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reshape_3d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2)
     * }
     */
    public static MemorySegment ggml_reshape_3d(MemorySegment ctx, MemorySegment a, long ne0, long ne1, long ne2) {
        var mh$ = ggml_reshape_3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_reshape_3d", ctx, a, ne0, ne1, ne2);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, ne0, ne1, ne2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_reshape_4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_reshape_4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reshape_4d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3)
     * }
     */
    public static FunctionDescriptor ggml_reshape_4d$descriptor() {
        return ggml_reshape_4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reshape_4d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3)
     * }
     */
    public static MethodHandle ggml_reshape_4d$handle() {
        return ggml_reshape_4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reshape_4d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3)
     * }
     */
    public static MemorySegment ggml_reshape_4d$address() {
        return ggml_reshape_4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reshape_4d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3)
     * }
     */
    public static MemorySegment ggml_reshape_4d(MemorySegment ctx, MemorySegment a, long ne0, long ne1, long ne2, long ne3) {
        var mh$ = ggml_reshape_4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_reshape_4d", ctx, a, ne0, ne1, ne2, ne3);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, ne0, ne1, ne2, ne3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_view_1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_view_1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_view_1d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, size_t offset)
     * }
     */
    public static FunctionDescriptor ggml_view_1d$descriptor() {
        return ggml_view_1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_view_1d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, size_t offset)
     * }
     */
    public static MethodHandle ggml_view_1d$handle() {
        return ggml_view_1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_view_1d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, size_t offset)
     * }
     */
    public static MemorySegment ggml_view_1d$address() {
        return ggml_view_1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_view_1d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, size_t offset)
     * }
     */
    public static MemorySegment ggml_view_1d(MemorySegment ctx, MemorySegment a, long ne0, long offset) {
        var mh$ = ggml_view_1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_view_1d", ctx, a, ne0, offset);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, ne0, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_view_2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_view_2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_view_2d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, size_t nb1, size_t offset)
     * }
     */
    public static FunctionDescriptor ggml_view_2d$descriptor() {
        return ggml_view_2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_view_2d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, size_t nb1, size_t offset)
     * }
     */
    public static MethodHandle ggml_view_2d$handle() {
        return ggml_view_2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_view_2d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, size_t nb1, size_t offset)
     * }
     */
    public static MemorySegment ggml_view_2d$address() {
        return ggml_view_2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_view_2d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, size_t nb1, size_t offset)
     * }
     */
    public static MemorySegment ggml_view_2d(MemorySegment ctx, MemorySegment a, long ne0, long ne1, long nb1, long offset) {
        var mh$ = ggml_view_2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_view_2d", ctx, a, ne0, ne1, nb1, offset);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, ne0, ne1, nb1, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_view_3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_view_3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_view_3d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, size_t nb1, size_t nb2, size_t offset)
     * }
     */
    public static FunctionDescriptor ggml_view_3d$descriptor() {
        return ggml_view_3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_view_3d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, size_t nb1, size_t nb2, size_t offset)
     * }
     */
    public static MethodHandle ggml_view_3d$handle() {
        return ggml_view_3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_view_3d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, size_t nb1, size_t nb2, size_t offset)
     * }
     */
    public static MemorySegment ggml_view_3d$address() {
        return ggml_view_3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_view_3d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, size_t nb1, size_t nb2, size_t offset)
     * }
     */
    public static MemorySegment ggml_view_3d(MemorySegment ctx, MemorySegment a, long ne0, long ne1, long ne2, long nb1, long nb2, long offset) {
        var mh$ = ggml_view_3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_view_3d", ctx, a, ne0, ne1, ne2, nb1, nb2, offset);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, ne0, ne1, ne2, nb1, nb2, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_view_4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_view_4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_view_4d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3, size_t nb1, size_t nb2, size_t nb3, size_t offset)
     * }
     */
    public static FunctionDescriptor ggml_view_4d$descriptor() {
        return ggml_view_4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_view_4d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3, size_t nb1, size_t nb2, size_t nb3, size_t offset)
     * }
     */
    public static MethodHandle ggml_view_4d$handle() {
        return ggml_view_4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_view_4d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3, size_t nb1, size_t nb2, size_t nb3, size_t offset)
     * }
     */
    public static MemorySegment ggml_view_4d$address() {
        return ggml_view_4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_view_4d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3, size_t nb1, size_t nb2, size_t nb3, size_t offset)
     * }
     */
    public static MemorySegment ggml_view_4d(MemorySegment ctx, MemorySegment a, long ne0, long ne1, long ne2, long ne3, long nb1, long nb2, long nb3, long offset) {
        var mh$ = ggml_view_4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_view_4d", ctx, a, ne0, ne1, ne2, ne3, nb1, nb2, nb3, offset);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, ne0, ne1, ne2, ne3, nb1, nb2, nb3, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_permute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_permute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_permute(struct ggml_context *ctx, struct ggml_tensor *a, int axis0, int axis1, int axis2, int axis3)
     * }
     */
    public static FunctionDescriptor ggml_permute$descriptor() {
        return ggml_permute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_permute(struct ggml_context *ctx, struct ggml_tensor *a, int axis0, int axis1, int axis2, int axis3)
     * }
     */
    public static MethodHandle ggml_permute$handle() {
        return ggml_permute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_permute(struct ggml_context *ctx, struct ggml_tensor *a, int axis0, int axis1, int axis2, int axis3)
     * }
     */
    public static MemorySegment ggml_permute$address() {
        return ggml_permute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_permute(struct ggml_context *ctx, struct ggml_tensor *a, int axis0, int axis1, int axis2, int axis3)
     * }
     */
    public static MemorySegment ggml_permute(MemorySegment ctx, MemorySegment a, int axis0, int axis1, int axis2, int axis3) {
        var mh$ = ggml_permute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_permute", ctx, a, axis0, axis1, axis2, axis3);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, axis0, axis1, axis2, axis3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_transpose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_transpose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_transpose(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_transpose$descriptor() {
        return ggml_transpose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_transpose(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_transpose$handle() {
        return ggml_transpose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_transpose(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_transpose$address() {
        return ggml_transpose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_transpose(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_transpose(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_transpose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_transpose", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_rows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_rows");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_rows(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_get_rows$descriptor() {
        return ggml_get_rows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_rows(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_get_rows$handle() {
        return ggml_get_rows.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_rows(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_get_rows$address() {
        return ggml_get_rows.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_rows(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_get_rows(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_get_rows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_rows", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_rows_back {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_rows_back");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_rows_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c)
     * }
     */
    public static FunctionDescriptor ggml_get_rows_back$descriptor() {
        return ggml_get_rows_back.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_rows_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c)
     * }
     */
    public static MethodHandle ggml_get_rows_back$handle() {
        return ggml_get_rows_back.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_rows_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c)
     * }
     */
    public static MemorySegment ggml_get_rows_back$address() {
        return ggml_get_rows_back.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_rows_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c)
     * }
     */
    public static MemorySegment ggml_get_rows_back(MemorySegment ctx, MemorySegment a, MemorySegment b, MemorySegment c) {
        var mh$ = ggml_get_rows_back.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_rows_back", ctx, a, b, c);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_rows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set_rows");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_rows(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c)
     * }
     */
    public static FunctionDescriptor ggml_set_rows$descriptor() {
        return ggml_set_rows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_rows(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c)
     * }
     */
    public static MethodHandle ggml_set_rows$handle() {
        return ggml_set_rows.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_rows(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c)
     * }
     */
    public static MemorySegment ggml_set_rows$address() {
        return ggml_set_rows.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_rows(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c)
     * }
     */
    public static MemorySegment ggml_set_rows(MemorySegment ctx, MemorySegment a, MemorySegment b, MemorySegment c) {
        var mh$ = ggml_set_rows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_rows", ctx, a, b, c);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_diag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_diag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_diag(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_diag$descriptor() {
        return ggml_diag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_diag(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_diag$handle() {
        return ggml_diag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_diag(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_diag$address() {
        return ggml_diag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_diag(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_diag(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_diag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_diag", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_diag_mask_inf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_diag_mask_inf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_diag_mask_inf(struct ggml_context *ctx, struct ggml_tensor *a, int n_past)
     * }
     */
    public static FunctionDescriptor ggml_diag_mask_inf$descriptor() {
        return ggml_diag_mask_inf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_diag_mask_inf(struct ggml_context *ctx, struct ggml_tensor *a, int n_past)
     * }
     */
    public static MethodHandle ggml_diag_mask_inf$handle() {
        return ggml_diag_mask_inf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_diag_mask_inf(struct ggml_context *ctx, struct ggml_tensor *a, int n_past)
     * }
     */
    public static MemorySegment ggml_diag_mask_inf$address() {
        return ggml_diag_mask_inf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_diag_mask_inf(struct ggml_context *ctx, struct ggml_tensor *a, int n_past)
     * }
     */
    public static MemorySegment ggml_diag_mask_inf(MemorySegment ctx, MemorySegment a, int n_past) {
        var mh$ = ggml_diag_mask_inf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_diag_mask_inf", ctx, a, n_past);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, n_past);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_diag_mask_inf_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_diag_mask_inf_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_diag_mask_inf_inplace(struct ggml_context *ctx, struct ggml_tensor *a, int n_past)
     * }
     */
    public static FunctionDescriptor ggml_diag_mask_inf_inplace$descriptor() {
        return ggml_diag_mask_inf_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_diag_mask_inf_inplace(struct ggml_context *ctx, struct ggml_tensor *a, int n_past)
     * }
     */
    public static MethodHandle ggml_diag_mask_inf_inplace$handle() {
        return ggml_diag_mask_inf_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_diag_mask_inf_inplace(struct ggml_context *ctx, struct ggml_tensor *a, int n_past)
     * }
     */
    public static MemorySegment ggml_diag_mask_inf_inplace$address() {
        return ggml_diag_mask_inf_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_diag_mask_inf_inplace(struct ggml_context *ctx, struct ggml_tensor *a, int n_past)
     * }
     */
    public static MemorySegment ggml_diag_mask_inf_inplace(MemorySegment ctx, MemorySegment a, int n_past) {
        var mh$ = ggml_diag_mask_inf_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_diag_mask_inf_inplace", ctx, a, n_past);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, n_past);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_diag_mask_zero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_diag_mask_zero");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_diag_mask_zero(struct ggml_context *ctx, struct ggml_tensor *a, int n_past)
     * }
     */
    public static FunctionDescriptor ggml_diag_mask_zero$descriptor() {
        return ggml_diag_mask_zero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_diag_mask_zero(struct ggml_context *ctx, struct ggml_tensor *a, int n_past)
     * }
     */
    public static MethodHandle ggml_diag_mask_zero$handle() {
        return ggml_diag_mask_zero.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_diag_mask_zero(struct ggml_context *ctx, struct ggml_tensor *a, int n_past)
     * }
     */
    public static MemorySegment ggml_diag_mask_zero$address() {
        return ggml_diag_mask_zero.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_diag_mask_zero(struct ggml_context *ctx, struct ggml_tensor *a, int n_past)
     * }
     */
    public static MemorySegment ggml_diag_mask_zero(MemorySegment ctx, MemorySegment a, int n_past) {
        var mh$ = ggml_diag_mask_zero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_diag_mask_zero", ctx, a, n_past);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, n_past);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_diag_mask_zero_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_diag_mask_zero_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_diag_mask_zero_inplace(struct ggml_context *ctx, struct ggml_tensor *a, int n_past)
     * }
     */
    public static FunctionDescriptor ggml_diag_mask_zero_inplace$descriptor() {
        return ggml_diag_mask_zero_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_diag_mask_zero_inplace(struct ggml_context *ctx, struct ggml_tensor *a, int n_past)
     * }
     */
    public static MethodHandle ggml_diag_mask_zero_inplace$handle() {
        return ggml_diag_mask_zero_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_diag_mask_zero_inplace(struct ggml_context *ctx, struct ggml_tensor *a, int n_past)
     * }
     */
    public static MemorySegment ggml_diag_mask_zero_inplace$address() {
        return ggml_diag_mask_zero_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_diag_mask_zero_inplace(struct ggml_context *ctx, struct ggml_tensor *a, int n_past)
     * }
     */
    public static MemorySegment ggml_diag_mask_zero_inplace(MemorySegment ctx, MemorySegment a, int n_past) {
        var mh$ = ggml_diag_mask_zero_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_diag_mask_zero_inplace", ctx, a, n_past);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, n_past);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_soft_max {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_soft_max");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_soft_max(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_soft_max$descriptor() {
        return ggml_soft_max.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_soft_max(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_soft_max$handle() {
        return ggml_soft_max.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_soft_max(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_soft_max$address() {
        return ggml_soft_max.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_soft_max(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_soft_max(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_soft_max.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_soft_max", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_soft_max_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_soft_max_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_soft_max_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_soft_max_inplace$descriptor() {
        return ggml_soft_max_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_soft_max_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_soft_max_inplace$handle() {
        return ggml_soft_max_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_soft_max_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_soft_max_inplace$address() {
        return ggml_soft_max_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_soft_max_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_soft_max_inplace(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_soft_max_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_soft_max_inplace", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_soft_max_ext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_soft_max_ext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_soft_max_ext(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *mask, float scale, float max_bias)
     * }
     */
    public static FunctionDescriptor ggml_soft_max_ext$descriptor() {
        return ggml_soft_max_ext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_soft_max_ext(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *mask, float scale, float max_bias)
     * }
     */
    public static MethodHandle ggml_soft_max_ext$handle() {
        return ggml_soft_max_ext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_soft_max_ext(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *mask, float scale, float max_bias)
     * }
     */
    public static MemorySegment ggml_soft_max_ext$address() {
        return ggml_soft_max_ext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_soft_max_ext(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *mask, float scale, float max_bias)
     * }
     */
    public static MemorySegment ggml_soft_max_ext(MemorySegment ctx, MemorySegment a, MemorySegment mask, float scale, float max_bias) {
        var mh$ = ggml_soft_max_ext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_soft_max_ext", ctx, a, mask, scale, max_bias);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, mask, scale, max_bias);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_soft_max_ext_back {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_soft_max_ext_back");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_soft_max_ext_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, float scale, float max_bias)
     * }
     */
    public static FunctionDescriptor ggml_soft_max_ext_back$descriptor() {
        return ggml_soft_max_ext_back.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_soft_max_ext_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, float scale, float max_bias)
     * }
     */
    public static MethodHandle ggml_soft_max_ext_back$handle() {
        return ggml_soft_max_ext_back.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_soft_max_ext_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, float scale, float max_bias)
     * }
     */
    public static MemorySegment ggml_soft_max_ext_back$address() {
        return ggml_soft_max_ext_back.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_soft_max_ext_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, float scale, float max_bias)
     * }
     */
    public static MemorySegment ggml_soft_max_ext_back(MemorySegment ctx, MemorySegment a, MemorySegment b, float scale, float max_bias) {
        var mh$ = ggml_soft_max_ext_back.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_soft_max_ext_back", ctx, a, b, scale, max_bias);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, scale, max_bias);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_soft_max_ext_back_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_soft_max_ext_back_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_soft_max_ext_back_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, float scale, float max_bias)
     * }
     */
    public static FunctionDescriptor ggml_soft_max_ext_back_inplace$descriptor() {
        return ggml_soft_max_ext_back_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_soft_max_ext_back_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, float scale, float max_bias)
     * }
     */
    public static MethodHandle ggml_soft_max_ext_back_inplace$handle() {
        return ggml_soft_max_ext_back_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_soft_max_ext_back_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, float scale, float max_bias)
     * }
     */
    public static MemorySegment ggml_soft_max_ext_back_inplace$address() {
        return ggml_soft_max_ext_back_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_soft_max_ext_back_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, float scale, float max_bias)
     * }
     */
    public static MemorySegment ggml_soft_max_ext_back_inplace(MemorySegment ctx, MemorySegment a, MemorySegment b, float scale, float max_bias) {
        var mh$ = ggml_soft_max_ext_back_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_soft_max_ext_back_inplace", ctx, a, b, scale, max_bias);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, scale, max_bias);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_rope {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_rope");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int n_dims, int mode)
     * }
     */
    public static FunctionDescriptor ggml_rope$descriptor() {
        return ggml_rope.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int n_dims, int mode)
     * }
     */
    public static MethodHandle ggml_rope$handle() {
        return ggml_rope.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int n_dims, int mode)
     * }
     */
    public static MemorySegment ggml_rope$address() {
        return ggml_rope.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int n_dims, int mode)
     * }
     */
    public static MemorySegment ggml_rope(MemorySegment ctx, MemorySegment a, MemorySegment b, int n_dims, int mode) {
        var mh$ = ggml_rope.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_rope", ctx, a, b, n_dims, mode);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, n_dims, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_rope_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_rope_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int n_dims, int mode)
     * }
     */
    public static FunctionDescriptor ggml_rope_inplace$descriptor() {
        return ggml_rope_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int n_dims, int mode)
     * }
     */
    public static MethodHandle ggml_rope_inplace$handle() {
        return ggml_rope_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int n_dims, int mode)
     * }
     */
    public static MemorySegment ggml_rope_inplace$address() {
        return ggml_rope_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int n_dims, int mode)
     * }
     */
    public static MemorySegment ggml_rope_inplace(MemorySegment ctx, MemorySegment a, MemorySegment b, int n_dims, int mode) {
        var mh$ = ggml_rope_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_rope_inplace", ctx, a, b, n_dims, mode);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, n_dims, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_rope_ext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_rope_ext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_ext(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static FunctionDescriptor ggml_rope_ext$descriptor() {
        return ggml_rope_ext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_ext(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MethodHandle ggml_rope_ext$handle() {
        return ggml_rope_ext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_ext(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MemorySegment ggml_rope_ext$address() {
        return ggml_rope_ext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_ext(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MemorySegment ggml_rope_ext(MemorySegment ctx, MemorySegment a, MemorySegment b, MemorySegment c, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow) {
        var mh$ = ggml_rope_ext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_rope_ext", ctx, a, b, c, n_dims, mode, n_ctx_orig, freq_base, freq_scale, ext_factor, attn_factor, beta_fast, beta_slow);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, c, n_dims, mode, n_ctx_orig, freq_base, freq_scale, ext_factor, attn_factor, beta_fast, beta_slow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_rope_multi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_rope_multi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_multi(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int sections[4], int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static FunctionDescriptor ggml_rope_multi$descriptor() {
        return ggml_rope_multi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_multi(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int sections[4], int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MethodHandle ggml_rope_multi$handle() {
        return ggml_rope_multi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_multi(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int sections[4], int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MemorySegment ggml_rope_multi$address() {
        return ggml_rope_multi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_multi(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int sections[4], int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MemorySegment ggml_rope_multi(MemorySegment ctx, MemorySegment a, MemorySegment b, MemorySegment c, int n_dims, MemorySegment sections, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow) {
        var mh$ = ggml_rope_multi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_rope_multi", ctx, a, b, c, n_dims, sections, mode, n_ctx_orig, freq_base, freq_scale, ext_factor, attn_factor, beta_fast, beta_slow);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, c, n_dims, sections, mode, n_ctx_orig, freq_base, freq_scale, ext_factor, attn_factor, beta_fast, beta_slow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_rope_ext_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_rope_ext_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_ext_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static FunctionDescriptor ggml_rope_ext_inplace$descriptor() {
        return ggml_rope_ext_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_ext_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MethodHandle ggml_rope_ext_inplace$handle() {
        return ggml_rope_ext_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_ext_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MemorySegment ggml_rope_ext_inplace$address() {
        return ggml_rope_ext_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_ext_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MemorySegment ggml_rope_ext_inplace(MemorySegment ctx, MemorySegment a, MemorySegment b, MemorySegment c, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow) {
        var mh$ = ggml_rope_ext_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_rope_ext_inplace", ctx, a, b, c, n_dims, mode, n_ctx_orig, freq_base, freq_scale, ext_factor, attn_factor, beta_fast, beta_slow);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, c, n_dims, mode, n_ctx_orig, freq_base, freq_scale, ext_factor, attn_factor, beta_fast, beta_slow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_rope_custom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_rope_custom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_custom(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static FunctionDescriptor ggml_rope_custom$descriptor() {
        return ggml_rope_custom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_custom(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MethodHandle ggml_rope_custom$handle() {
        return ggml_rope_custom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_custom(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MemorySegment ggml_rope_custom$address() {
        return ggml_rope_custom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_custom(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MemorySegment ggml_rope_custom(MemorySegment ctx, MemorySegment a, MemorySegment b, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow) {
        var mh$ = ggml_rope_custom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_rope_custom", ctx, a, b, n_dims, mode, n_ctx_orig, freq_base, freq_scale, ext_factor, attn_factor, beta_fast, beta_slow);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, n_dims, mode, n_ctx_orig, freq_base, freq_scale, ext_factor, attn_factor, beta_fast, beta_slow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_rope_custom_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_rope_custom_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_custom_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static FunctionDescriptor ggml_rope_custom_inplace$descriptor() {
        return ggml_rope_custom_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_custom_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MethodHandle ggml_rope_custom_inplace$handle() {
        return ggml_rope_custom_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_custom_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MemorySegment ggml_rope_custom_inplace$address() {
        return ggml_rope_custom_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_custom_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MemorySegment ggml_rope_custom_inplace(MemorySegment ctx, MemorySegment a, MemorySegment b, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow) {
        var mh$ = ggml_rope_custom_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_rope_custom_inplace", ctx, a, b, n_dims, mode, n_ctx_orig, freq_base, freq_scale, ext_factor, attn_factor, beta_fast, beta_slow);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, n_dims, mode, n_ctx_orig, freq_base, freq_scale, ext_factor, attn_factor, beta_fast, beta_slow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_rope_yarn_corr_dims {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_rope_yarn_corr_dims");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_rope_yarn_corr_dims(int n_dims, int n_ctx_orig, float freq_base, float beta_fast, float beta_slow, float dims[2])
     * }
     */
    public static FunctionDescriptor ggml_rope_yarn_corr_dims$descriptor() {
        return ggml_rope_yarn_corr_dims.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_rope_yarn_corr_dims(int n_dims, int n_ctx_orig, float freq_base, float beta_fast, float beta_slow, float dims[2])
     * }
     */
    public static MethodHandle ggml_rope_yarn_corr_dims$handle() {
        return ggml_rope_yarn_corr_dims.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_rope_yarn_corr_dims(int n_dims, int n_ctx_orig, float freq_base, float beta_fast, float beta_slow, float dims[2])
     * }
     */
    public static MemorySegment ggml_rope_yarn_corr_dims$address() {
        return ggml_rope_yarn_corr_dims.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_rope_yarn_corr_dims(int n_dims, int n_ctx_orig, float freq_base, float beta_fast, float beta_slow, float dims[2])
     * }
     */
    public static void ggml_rope_yarn_corr_dims(int n_dims, int n_ctx_orig, float freq_base, float beta_fast, float beta_slow, MemorySegment dims) {
        var mh$ = ggml_rope_yarn_corr_dims.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_rope_yarn_corr_dims", n_dims, n_ctx_orig, freq_base, beta_fast, beta_slow, dims);
            }
            mh$.invokeExact(n_dims, n_ctx_orig, freq_base, beta_fast, beta_slow, dims);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_rope_ext_back {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_rope_ext_back");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_ext_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static FunctionDescriptor ggml_rope_ext_back$descriptor() {
        return ggml_rope_ext_back.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_ext_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MethodHandle ggml_rope_ext_back$handle() {
        return ggml_rope_ext_back.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_ext_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MemorySegment ggml_rope_ext_back$address() {
        return ggml_rope_ext_back.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_ext_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MemorySegment ggml_rope_ext_back(MemorySegment ctx, MemorySegment a, MemorySegment b, MemorySegment c, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow) {
        var mh$ = ggml_rope_ext_back.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_rope_ext_back", ctx, a, b, c, n_dims, mode, n_ctx_orig, freq_base, freq_scale, ext_factor, attn_factor, beta_fast, beta_slow);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, c, n_dims, mode, n_ctx_orig, freq_base, freq_scale, ext_factor, attn_factor, beta_fast, beta_slow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_rope_multi_back {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_rope_multi_back");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_multi_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int sections[4], int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static FunctionDescriptor ggml_rope_multi_back$descriptor() {
        return ggml_rope_multi_back.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_multi_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int sections[4], int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MethodHandle ggml_rope_multi_back$handle() {
        return ggml_rope_multi_back.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_multi_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int sections[4], int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MemorySegment ggml_rope_multi_back$address() {
        return ggml_rope_multi_back.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_multi_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int sections[4], int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MemorySegment ggml_rope_multi_back(MemorySegment ctx, MemorySegment a, MemorySegment b, MemorySegment c, int n_dims, MemorySegment sections, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow) {
        var mh$ = ggml_rope_multi_back.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_rope_multi_back", ctx, a, b, c, n_dims, sections, mode, n_ctx_orig, freq_base, freq_scale, ext_factor, attn_factor, beta_fast, beta_slow);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, c, n_dims, sections, mode, n_ctx_orig, freq_base, freq_scale, ext_factor, attn_factor, beta_fast, beta_slow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_clamp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_clamp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_clamp(struct ggml_context *ctx, struct ggml_tensor *a, float min, float max)
     * }
     */
    public static FunctionDescriptor ggml_clamp$descriptor() {
        return ggml_clamp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_clamp(struct ggml_context *ctx, struct ggml_tensor *a, float min, float max)
     * }
     */
    public static MethodHandle ggml_clamp$handle() {
        return ggml_clamp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_clamp(struct ggml_context *ctx, struct ggml_tensor *a, float min, float max)
     * }
     */
    public static MemorySegment ggml_clamp$address() {
        return ggml_clamp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_clamp(struct ggml_context *ctx, struct ggml_tensor *a, float min, float max)
     * }
     */
    public static MemorySegment ggml_clamp(MemorySegment ctx, MemorySegment a, float min, float max) {
        var mh$ = ggml_clamp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_clamp", ctx, a, min, max);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, min, max);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_im2col {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_BOOL,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_im2col");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_im2col(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1, bool is_2D, enum ggml_type dst_type)
     * }
     */
    public static FunctionDescriptor ggml_im2col$descriptor() {
        return ggml_im2col.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_im2col(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1, bool is_2D, enum ggml_type dst_type)
     * }
     */
    public static MethodHandle ggml_im2col$handle() {
        return ggml_im2col.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_im2col(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1, bool is_2D, enum ggml_type dst_type)
     * }
     */
    public static MemorySegment ggml_im2col$address() {
        return ggml_im2col.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_im2col(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1, bool is_2D, enum ggml_type dst_type)
     * }
     */
    public static MemorySegment ggml_im2col(MemorySegment ctx, MemorySegment a, MemorySegment b, int s0, int s1, int p0, int p1, int d0, int d1, boolean is_2D, int dst_type) {
        var mh$ = ggml_im2col.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_im2col", ctx, a, b, s0, s1, p0, p1, d0, d1, is_2D, dst_type);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, s0, s1, p0, p1, d0, d1, is_2D, dst_type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_im2col_back {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_BOOL
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_im2col_back");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_im2col_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int64_t *ne, int s0, int s1, int p0, int p1, int d0, int d1, bool is_2D)
     * }
     */
    public static FunctionDescriptor ggml_im2col_back$descriptor() {
        return ggml_im2col_back.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_im2col_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int64_t *ne, int s0, int s1, int p0, int p1, int d0, int d1, bool is_2D)
     * }
     */
    public static MethodHandle ggml_im2col_back$handle() {
        return ggml_im2col_back.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_im2col_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int64_t *ne, int s0, int s1, int p0, int p1, int d0, int d1, bool is_2D)
     * }
     */
    public static MemorySegment ggml_im2col_back$address() {
        return ggml_im2col_back.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_im2col_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int64_t *ne, int s0, int s1, int p0, int p1, int d0, int d1, bool is_2D)
     * }
     */
    public static MemorySegment ggml_im2col_back(MemorySegment ctx, MemorySegment a, MemorySegment b, MemorySegment ne, int s0, int s1, int p0, int p1, int d0, int d1, boolean is_2D) {
        var mh$ = ggml_im2col_back.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_im2col_back", ctx, a, b, ne, s0, s1, p0, p1, d0, d1, is_2D);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, ne, s0, s1, p0, p1, d0, d1, is_2D);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_conv_1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_conv_1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int p0, int d0)
     * }
     */
    public static FunctionDescriptor ggml_conv_1d$descriptor() {
        return ggml_conv_1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int p0, int d0)
     * }
     */
    public static MethodHandle ggml_conv_1d$handle() {
        return ggml_conv_1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int p0, int d0)
     * }
     */
    public static MemorySegment ggml_conv_1d$address() {
        return ggml_conv_1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int p0, int d0)
     * }
     */
    public static MemorySegment ggml_conv_1d(MemorySegment ctx, MemorySegment a, MemorySegment b, int s0, int p0, int d0) {
        var mh$ = ggml_conv_1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_conv_1d", ctx, a, b, s0, p0, d0);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, s0, p0, d0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_conv_1d_ph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_conv_1d_ph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d_ph(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s, int d)
     * }
     */
    public static FunctionDescriptor ggml_conv_1d_ph$descriptor() {
        return ggml_conv_1d_ph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d_ph(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s, int d)
     * }
     */
    public static MethodHandle ggml_conv_1d_ph$handle() {
        return ggml_conv_1d_ph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d_ph(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s, int d)
     * }
     */
    public static MemorySegment ggml_conv_1d_ph$address() {
        return ggml_conv_1d_ph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d_ph(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s, int d)
     * }
     */
    public static MemorySegment ggml_conv_1d_ph(MemorySegment ctx, MemorySegment a, MemorySegment b, int s, int d) {
        var mh$ = ggml_conv_1d_ph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_conv_1d_ph", ctx, a, b, s, d);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, s, d);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_conv_1d_dw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_conv_1d_dw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d_dw(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int p0, int d0)
     * }
     */
    public static FunctionDescriptor ggml_conv_1d_dw$descriptor() {
        return ggml_conv_1d_dw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d_dw(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int p0, int d0)
     * }
     */
    public static MethodHandle ggml_conv_1d_dw$handle() {
        return ggml_conv_1d_dw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d_dw(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int p0, int d0)
     * }
     */
    public static MemorySegment ggml_conv_1d_dw$address() {
        return ggml_conv_1d_dw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d_dw(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int p0, int d0)
     * }
     */
    public static MemorySegment ggml_conv_1d_dw(MemorySegment ctx, MemorySegment a, MemorySegment b, int s0, int p0, int d0) {
        var mh$ = ggml_conv_1d_dw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_conv_1d_dw", ctx, a, b, s0, p0, d0);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, s0, p0, d0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_conv_1d_dw_ph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_conv_1d_dw_ph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d_dw_ph(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int d0)
     * }
     */
    public static FunctionDescriptor ggml_conv_1d_dw_ph$descriptor() {
        return ggml_conv_1d_dw_ph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d_dw_ph(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int d0)
     * }
     */
    public static MethodHandle ggml_conv_1d_dw_ph$handle() {
        return ggml_conv_1d_dw_ph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d_dw_ph(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int d0)
     * }
     */
    public static MemorySegment ggml_conv_1d_dw_ph$address() {
        return ggml_conv_1d_dw_ph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d_dw_ph(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int d0)
     * }
     */
    public static MemorySegment ggml_conv_1d_dw_ph(MemorySegment ctx, MemorySegment a, MemorySegment b, int s0, int d0) {
        var mh$ = ggml_conv_1d_dw_ph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_conv_1d_dw_ph", ctx, a, b, s0, d0);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, s0, d0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_conv_transpose_1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_conv_transpose_1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_transpose_1d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int p0, int d0)
     * }
     */
    public static FunctionDescriptor ggml_conv_transpose_1d$descriptor() {
        return ggml_conv_transpose_1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_transpose_1d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int p0, int d0)
     * }
     */
    public static MethodHandle ggml_conv_transpose_1d$handle() {
        return ggml_conv_transpose_1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_transpose_1d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int p0, int d0)
     * }
     */
    public static MemorySegment ggml_conv_transpose_1d$address() {
        return ggml_conv_transpose_1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_transpose_1d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int p0, int d0)
     * }
     */
    public static MemorySegment ggml_conv_transpose_1d(MemorySegment ctx, MemorySegment a, MemorySegment b, int s0, int p0, int d0) {
        var mh$ = ggml_conv_transpose_1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_conv_transpose_1d", ctx, a, b, s0, p0, d0);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, s0, p0, d0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_conv_2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_conv_2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1)
     * }
     */
    public static FunctionDescriptor ggml_conv_2d$descriptor() {
        return ggml_conv_2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1)
     * }
     */
    public static MethodHandle ggml_conv_2d$handle() {
        return ggml_conv_2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1)
     * }
     */
    public static MemorySegment ggml_conv_2d$address() {
        return ggml_conv_2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1)
     * }
     */
    public static MemorySegment ggml_conv_2d(MemorySegment ctx, MemorySegment a, MemorySegment b, int s0, int s1, int p0, int p1, int d0, int d1) {
        var mh$ = ggml_conv_2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_conv_2d", ctx, a, b, s0, s1, p0, p1, d0, d1);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, s0, s1, p0, p1, d0, d1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_conv_2d_sk_p0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_conv_2d_sk_p0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_sk_p0(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_conv_2d_sk_p0$descriptor() {
        return ggml_conv_2d_sk_p0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_sk_p0(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_conv_2d_sk_p0$handle() {
        return ggml_conv_2d_sk_p0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_sk_p0(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_conv_2d_sk_p0$address() {
        return ggml_conv_2d_sk_p0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_sk_p0(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_conv_2d_sk_p0(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_conv_2d_sk_p0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_conv_2d_sk_p0", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_conv_2d_s1_ph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_conv_2d_s1_ph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_s1_ph(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_conv_2d_s1_ph$descriptor() {
        return ggml_conv_2d_s1_ph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_s1_ph(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_conv_2d_s1_ph$handle() {
        return ggml_conv_2d_s1_ph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_s1_ph(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_conv_2d_s1_ph$address() {
        return ggml_conv_2d_s1_ph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_s1_ph(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_conv_2d_s1_ph(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_conv_2d_s1_ph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_conv_2d_s1_ph", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_conv_2d_dw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_conv_2d_dw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_dw(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1)
     * }
     */
    public static FunctionDescriptor ggml_conv_2d_dw$descriptor() {
        return ggml_conv_2d_dw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_dw(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1)
     * }
     */
    public static MethodHandle ggml_conv_2d_dw$handle() {
        return ggml_conv_2d_dw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_dw(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1)
     * }
     */
    public static MemorySegment ggml_conv_2d_dw$address() {
        return ggml_conv_2d_dw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_dw(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1)
     * }
     */
    public static MemorySegment ggml_conv_2d_dw(MemorySegment ctx, MemorySegment a, MemorySegment b, int s0, int s1, int p0, int p1, int d0, int d1) {
        var mh$ = ggml_conv_2d_dw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_conv_2d_dw", ctx, a, b, s0, s1, p0, p1, d0, d1);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, s0, s1, p0, p1, d0, d1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_conv_2d_dw_direct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_conv_2d_dw_direct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_dw_direct(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int stride0, int stride1, int pad0, int pad1, int dilation0, int dilation1)
     * }
     */
    public static FunctionDescriptor ggml_conv_2d_dw_direct$descriptor() {
        return ggml_conv_2d_dw_direct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_dw_direct(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int stride0, int stride1, int pad0, int pad1, int dilation0, int dilation1)
     * }
     */
    public static MethodHandle ggml_conv_2d_dw_direct$handle() {
        return ggml_conv_2d_dw_direct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_dw_direct(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int stride0, int stride1, int pad0, int pad1, int dilation0, int dilation1)
     * }
     */
    public static MemorySegment ggml_conv_2d_dw_direct$address() {
        return ggml_conv_2d_dw_direct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_dw_direct(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int stride0, int stride1, int pad0, int pad1, int dilation0, int dilation1)
     * }
     */
    public static MemorySegment ggml_conv_2d_dw_direct(MemorySegment ctx, MemorySegment a, MemorySegment b, int stride0, int stride1, int pad0, int pad1, int dilation0, int dilation1) {
        var mh$ = ggml_conv_2d_dw_direct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_conv_2d_dw_direct", ctx, a, b, stride0, stride1, pad0, pad1, dilation0, dilation1);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, stride0, stride1, pad0, pad1, dilation0, dilation1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_conv_transpose_2d_p0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_conv_transpose_2d_p0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_transpose_2d_p0(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int stride)
     * }
     */
    public static FunctionDescriptor ggml_conv_transpose_2d_p0$descriptor() {
        return ggml_conv_transpose_2d_p0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_transpose_2d_p0(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int stride)
     * }
     */
    public static MethodHandle ggml_conv_transpose_2d_p0$handle() {
        return ggml_conv_transpose_2d_p0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_transpose_2d_p0(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int stride)
     * }
     */
    public static MemorySegment ggml_conv_transpose_2d_p0$address() {
        return ggml_conv_transpose_2d_p0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_transpose_2d_p0(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int stride)
     * }
     */
    public static MemorySegment ggml_conv_transpose_2d_p0(MemorySegment ctx, MemorySegment a, MemorySegment b, int stride) {
        var mh$ = ggml_conv_transpose_2d_p0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_conv_transpose_2d_p0", ctx, a, b, stride);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, stride);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_conv_2d_direct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_conv_2d_direct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_direct(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1)
     * }
     */
    public static FunctionDescriptor ggml_conv_2d_direct$descriptor() {
        return ggml_conv_2d_direct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_direct(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1)
     * }
     */
    public static MethodHandle ggml_conv_2d_direct$handle() {
        return ggml_conv_2d_direct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_direct(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1)
     * }
     */
    public static MemorySegment ggml_conv_2d_direct$address() {
        return ggml_conv_2d_direct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_direct(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1)
     * }
     */
    public static MemorySegment ggml_conv_2d_direct(MemorySegment ctx, MemorySegment a, MemorySegment b, int s0, int s1, int p0, int p1, int d0, int d1) {
        var mh$ = ggml_conv_2d_direct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_conv_2d_direct", ctx, a, b, s0, s1, p0, p1, d0, d1);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, s0, s1, p0, p1, d0, d1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GGML_OP_POOL_MAX = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ggml_op_pool.GGML_OP_POOL_MAX = 0
     * }
     */
    public static int GGML_OP_POOL_MAX() {
        return GGML_OP_POOL_MAX;
    }
    private static final int GGML_OP_POOL_AVG = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ggml_op_pool.GGML_OP_POOL_AVG = 1
     * }
     */
    public static int GGML_OP_POOL_AVG() {
        return GGML_OP_POOL_AVG;
    }
    private static final int GGML_OP_POOL_COUNT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ggml_op_pool.GGML_OP_POOL_COUNT = 2
     * }
     */
    public static int GGML_OP_POOL_COUNT() {
        return GGML_OP_POOL_COUNT;
    }

    private static class ggml_pool_1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_pool_1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pool_1d(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_op_pool op, int k0, int s0, int p0)
     * }
     */
    public static FunctionDescriptor ggml_pool_1d$descriptor() {
        return ggml_pool_1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pool_1d(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_op_pool op, int k0, int s0, int p0)
     * }
     */
    public static MethodHandle ggml_pool_1d$handle() {
        return ggml_pool_1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pool_1d(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_op_pool op, int k0, int s0, int p0)
     * }
     */
    public static MemorySegment ggml_pool_1d$address() {
        return ggml_pool_1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pool_1d(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_op_pool op, int k0, int s0, int p0)
     * }
     */
    public static MemorySegment ggml_pool_1d(MemorySegment ctx, MemorySegment a, int op, int k0, int s0, int p0) {
        var mh$ = ggml_pool_1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_pool_1d", ctx, a, op, k0, s0, p0);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, op, k0, s0, p0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_pool_2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_pool_2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pool_2d(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_op_pool op, int k0, int k1, int s0, int s1, float p0, float p1)
     * }
     */
    public static FunctionDescriptor ggml_pool_2d$descriptor() {
        return ggml_pool_2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pool_2d(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_op_pool op, int k0, int k1, int s0, int s1, float p0, float p1)
     * }
     */
    public static MethodHandle ggml_pool_2d$handle() {
        return ggml_pool_2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pool_2d(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_op_pool op, int k0, int k1, int s0, int s1, float p0, float p1)
     * }
     */
    public static MemorySegment ggml_pool_2d$address() {
        return ggml_pool_2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pool_2d(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_op_pool op, int k0, int k1, int s0, int s1, float p0, float p1)
     * }
     */
    public static MemorySegment ggml_pool_2d(MemorySegment ctx, MemorySegment a, int op, int k0, int k1, int s0, int s1, float p0, float p1) {
        var mh$ = ggml_pool_2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_pool_2d", ctx, a, op, k0, k1, s0, s1, p0, p1);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, op, k0, k1, s0, s1, p0, p1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_pool_2d_back {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_pool_2d_back");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pool_2d_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *af, enum ggml_op_pool op, int k0, int k1, int s0, int s1, float p0, float p1)
     * }
     */
    public static FunctionDescriptor ggml_pool_2d_back$descriptor() {
        return ggml_pool_2d_back.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pool_2d_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *af, enum ggml_op_pool op, int k0, int k1, int s0, int s1, float p0, float p1)
     * }
     */
    public static MethodHandle ggml_pool_2d_back$handle() {
        return ggml_pool_2d_back.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pool_2d_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *af, enum ggml_op_pool op, int k0, int k1, int s0, int s1, float p0, float p1)
     * }
     */
    public static MemorySegment ggml_pool_2d_back$address() {
        return ggml_pool_2d_back.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pool_2d_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *af, enum ggml_op_pool op, int k0, int k1, int s0, int s1, float p0, float p1)
     * }
     */
    public static MemorySegment ggml_pool_2d_back(MemorySegment ctx, MemorySegment a, MemorySegment af, int op, int k0, int k1, int s0, int s1, float p0, float p1) {
        var mh$ = ggml_pool_2d_back.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_pool_2d_back", ctx, a, af, op, k0, k1, s0, s1, p0, p1);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, af, op, k0, k1, s0, s1, p0, p1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GGML_SCALE_MODE_NEAREST = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ggml_scale_mode.GGML_SCALE_MODE_NEAREST = 0
     * }
     */
    public static int GGML_SCALE_MODE_NEAREST() {
        return GGML_SCALE_MODE_NEAREST;
    }
    private static final int GGML_SCALE_MODE_BILINEAR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ggml_scale_mode.GGML_SCALE_MODE_BILINEAR = 1
     * }
     */
    public static int GGML_SCALE_MODE_BILINEAR() {
        return GGML_SCALE_MODE_BILINEAR;
    }
    private static final int GGML_SCALE_MODE_COUNT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ggml_scale_mode.GGML_SCALE_MODE_COUNT = 2
     * }
     */
    public static int GGML_SCALE_MODE_COUNT() {
        return GGML_SCALE_MODE_COUNT;
    }
    private static final int GGML_SCALE_FLAG_ALIGN_CORNERS = (int)256L;
    /**
     * {@snippet lang=c :
     * enum ggml_scale_flag.GGML_SCALE_FLAG_ALIGN_CORNERS = 256
     * }
     */
    public static int GGML_SCALE_FLAG_ALIGN_CORNERS() {
        return GGML_SCALE_FLAG_ALIGN_CORNERS;
    }

    private static class ggml_upscale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_upscale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_upscale(struct ggml_context *ctx, struct ggml_tensor *a, int scale_factor, enum ggml_scale_mode mode)
     * }
     */
    public static FunctionDescriptor ggml_upscale$descriptor() {
        return ggml_upscale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_upscale(struct ggml_context *ctx, struct ggml_tensor *a, int scale_factor, enum ggml_scale_mode mode)
     * }
     */
    public static MethodHandle ggml_upscale$handle() {
        return ggml_upscale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_upscale(struct ggml_context *ctx, struct ggml_tensor *a, int scale_factor, enum ggml_scale_mode mode)
     * }
     */
    public static MemorySegment ggml_upscale$address() {
        return ggml_upscale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_upscale(struct ggml_context *ctx, struct ggml_tensor *a, int scale_factor, enum ggml_scale_mode mode)
     * }
     */
    public static MemorySegment ggml_upscale(MemorySegment ctx, MemorySegment a, int scale_factor, int mode) {
        var mh$ = ggml_upscale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_upscale", ctx, a, scale_factor, mode);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, scale_factor, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_upscale_ext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_upscale_ext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_upscale_ext(struct ggml_context *ctx, struct ggml_tensor *a, int ne0, int ne1, int ne2, int ne3, enum ggml_scale_mode mode)
     * }
     */
    public static FunctionDescriptor ggml_upscale_ext$descriptor() {
        return ggml_upscale_ext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_upscale_ext(struct ggml_context *ctx, struct ggml_tensor *a, int ne0, int ne1, int ne2, int ne3, enum ggml_scale_mode mode)
     * }
     */
    public static MethodHandle ggml_upscale_ext$handle() {
        return ggml_upscale_ext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_upscale_ext(struct ggml_context *ctx, struct ggml_tensor *a, int ne0, int ne1, int ne2, int ne3, enum ggml_scale_mode mode)
     * }
     */
    public static MemorySegment ggml_upscale_ext$address() {
        return ggml_upscale_ext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_upscale_ext(struct ggml_context *ctx, struct ggml_tensor *a, int ne0, int ne1, int ne2, int ne3, enum ggml_scale_mode mode)
     * }
     */
    public static MemorySegment ggml_upscale_ext(MemorySegment ctx, MemorySegment a, int ne0, int ne1, int ne2, int ne3, int mode) {
        var mh$ = ggml_upscale_ext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_upscale_ext", ctx, a, ne0, ne1, ne2, ne3, mode);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, ne0, ne1, ne2, ne3, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_interpolate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_interpolate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_interpolate(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3, uint32_t mode)
     * }
     */
    public static FunctionDescriptor ggml_interpolate$descriptor() {
        return ggml_interpolate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_interpolate(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3, uint32_t mode)
     * }
     */
    public static MethodHandle ggml_interpolate$handle() {
        return ggml_interpolate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_interpolate(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3, uint32_t mode)
     * }
     */
    public static MemorySegment ggml_interpolate$address() {
        return ggml_interpolate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_interpolate(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3, uint32_t mode)
     * }
     */
    public static MemorySegment ggml_interpolate(MemorySegment ctx, MemorySegment a, long ne0, long ne1, long ne2, long ne3, int mode) {
        var mh$ = ggml_interpolate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_interpolate", ctx, a, ne0, ne1, ne2, ne3, mode);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, ne0, ne1, ne2, ne3, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_pad {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_pad");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pad(struct ggml_context *ctx, struct ggml_tensor *a, int p0, int p1, int p2, int p3)
     * }
     */
    public static FunctionDescriptor ggml_pad$descriptor() {
        return ggml_pad.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pad(struct ggml_context *ctx, struct ggml_tensor *a, int p0, int p1, int p2, int p3)
     * }
     */
    public static MethodHandle ggml_pad$handle() {
        return ggml_pad.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pad(struct ggml_context *ctx, struct ggml_tensor *a, int p0, int p1, int p2, int p3)
     * }
     */
    public static MemorySegment ggml_pad$address() {
        return ggml_pad.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pad(struct ggml_context *ctx, struct ggml_tensor *a, int p0, int p1, int p2, int p3)
     * }
     */
    public static MemorySegment ggml_pad(MemorySegment ctx, MemorySegment a, int p0, int p1, int p2, int p3) {
        var mh$ = ggml_pad.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_pad", ctx, a, p0, p1, p2, p3);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, p0, p1, p2, p3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_pad_reflect_1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_pad_reflect_1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pad_reflect_1d(struct ggml_context *ctx, struct ggml_tensor *a, int p0, int p1)
     * }
     */
    public static FunctionDescriptor ggml_pad_reflect_1d$descriptor() {
        return ggml_pad_reflect_1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pad_reflect_1d(struct ggml_context *ctx, struct ggml_tensor *a, int p0, int p1)
     * }
     */
    public static MethodHandle ggml_pad_reflect_1d$handle() {
        return ggml_pad_reflect_1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pad_reflect_1d(struct ggml_context *ctx, struct ggml_tensor *a, int p0, int p1)
     * }
     */
    public static MemorySegment ggml_pad_reflect_1d$address() {
        return ggml_pad_reflect_1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pad_reflect_1d(struct ggml_context *ctx, struct ggml_tensor *a, int p0, int p1)
     * }
     */
    public static MemorySegment ggml_pad_reflect_1d(MemorySegment ctx, MemorySegment a, int p0, int p1) {
        var mh$ = ggml_pad_reflect_1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_pad_reflect_1d", ctx, a, p0, p1);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, p0, p1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_roll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_roll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_roll(struct ggml_context *ctx, struct ggml_tensor *a, int shift0, int shift1, int shift2, int shift3)
     * }
     */
    public static FunctionDescriptor ggml_roll$descriptor() {
        return ggml_roll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_roll(struct ggml_context *ctx, struct ggml_tensor *a, int shift0, int shift1, int shift2, int shift3)
     * }
     */
    public static MethodHandle ggml_roll$handle() {
        return ggml_roll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_roll(struct ggml_context *ctx, struct ggml_tensor *a, int shift0, int shift1, int shift2, int shift3)
     * }
     */
    public static MemorySegment ggml_roll$address() {
        return ggml_roll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_roll(struct ggml_context *ctx, struct ggml_tensor *a, int shift0, int shift1, int shift2, int shift3)
     * }
     */
    public static MemorySegment ggml_roll(MemorySegment ctx, MemorySegment a, int shift0, int shift1, int shift2, int shift3) {
        var mh$ = ggml_roll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_roll", ctx, a, shift0, shift1, shift2, shift3);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, shift0, shift1, shift2, shift3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_timestep_embedding {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_timestep_embedding");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_timestep_embedding(struct ggml_context *ctx, struct ggml_tensor *timesteps, int dim, int max_period)
     * }
     */
    public static FunctionDescriptor ggml_timestep_embedding$descriptor() {
        return ggml_timestep_embedding.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_timestep_embedding(struct ggml_context *ctx, struct ggml_tensor *timesteps, int dim, int max_period)
     * }
     */
    public static MethodHandle ggml_timestep_embedding$handle() {
        return ggml_timestep_embedding.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_timestep_embedding(struct ggml_context *ctx, struct ggml_tensor *timesteps, int dim, int max_period)
     * }
     */
    public static MemorySegment ggml_timestep_embedding$address() {
        return ggml_timestep_embedding.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_timestep_embedding(struct ggml_context *ctx, struct ggml_tensor *timesteps, int dim, int max_period)
     * }
     */
    public static MemorySegment ggml_timestep_embedding(MemorySegment ctx, MemorySegment timesteps, int dim, int max_period) {
        var mh$ = ggml_timestep_embedding.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_timestep_embedding", ctx, timesteps, dim, max_period);
            }
            return (MemorySegment)mh$.invokeExact(ctx, timesteps, dim, max_period);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GGML_SORT_ORDER_ASC = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ggml_sort_order.GGML_SORT_ORDER_ASC = 0
     * }
     */
    public static int GGML_SORT_ORDER_ASC() {
        return GGML_SORT_ORDER_ASC;
    }
    private static final int GGML_SORT_ORDER_DESC = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ggml_sort_order.GGML_SORT_ORDER_DESC = 1
     * }
     */
    public static int GGML_SORT_ORDER_DESC() {
        return GGML_SORT_ORDER_DESC;
    }

    private static class ggml_argsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_argsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_argsort(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_sort_order order)
     * }
     */
    public static FunctionDescriptor ggml_argsort$descriptor() {
        return ggml_argsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_argsort(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_sort_order order)
     * }
     */
    public static MethodHandle ggml_argsort$handle() {
        return ggml_argsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_argsort(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_sort_order order)
     * }
     */
    public static MemorySegment ggml_argsort$address() {
        return ggml_argsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_argsort(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_sort_order order)
     * }
     */
    public static MemorySegment ggml_argsort(MemorySegment ctx, MemorySegment a, int order) {
        var mh$ = ggml_argsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_argsort", ctx, a, order);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, order);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_arange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_arange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_arange(struct ggml_context *ctx, float start, float stop, float step)
     * }
     */
    public static FunctionDescriptor ggml_arange$descriptor() {
        return ggml_arange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_arange(struct ggml_context *ctx, float start, float stop, float step)
     * }
     */
    public static MethodHandle ggml_arange$handle() {
        return ggml_arange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_arange(struct ggml_context *ctx, float start, float stop, float step)
     * }
     */
    public static MemorySegment ggml_arange$address() {
        return ggml_arange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_arange(struct ggml_context *ctx, float start, float stop, float step)
     * }
     */
    public static MemorySegment ggml_arange(MemorySegment ctx, float start, float stop, float step) {
        var mh$ = ggml_arange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_arange", ctx, start, stop, step);
            }
            return (MemorySegment)mh$.invokeExact(ctx, start, stop, step);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_top_k {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_top_k");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_top_k(struct ggml_context *ctx, struct ggml_tensor *a, int k)
     * }
     */
    public static FunctionDescriptor ggml_top_k$descriptor() {
        return ggml_top_k.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_top_k(struct ggml_context *ctx, struct ggml_tensor *a, int k)
     * }
     */
    public static MethodHandle ggml_top_k$handle() {
        return ggml_top_k.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_top_k(struct ggml_context *ctx, struct ggml_tensor *a, int k)
     * }
     */
    public static MemorySegment ggml_top_k$address() {
        return ggml_top_k.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_top_k(struct ggml_context *ctx, struct ggml_tensor *a, int k)
     * }
     */
    public static MemorySegment ggml_top_k(MemorySegment ctx, MemorySegment a, int k) {
        var mh$ = ggml_top_k.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_top_k", ctx, a, k);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_flash_attn_ext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_flash_attn_ext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_flash_attn_ext(struct ggml_context *ctx, struct ggml_tensor *q, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *mask, float scale, float max_bias, float logit_softcap)
     * }
     */
    public static FunctionDescriptor ggml_flash_attn_ext$descriptor() {
        return ggml_flash_attn_ext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_flash_attn_ext(struct ggml_context *ctx, struct ggml_tensor *q, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *mask, float scale, float max_bias, float logit_softcap)
     * }
     */
    public static MethodHandle ggml_flash_attn_ext$handle() {
        return ggml_flash_attn_ext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_flash_attn_ext(struct ggml_context *ctx, struct ggml_tensor *q, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *mask, float scale, float max_bias, float logit_softcap)
     * }
     */
    public static MemorySegment ggml_flash_attn_ext$address() {
        return ggml_flash_attn_ext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_flash_attn_ext(struct ggml_context *ctx, struct ggml_tensor *q, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *mask, float scale, float max_bias, float logit_softcap)
     * }
     */
    public static MemorySegment ggml_flash_attn_ext(MemorySegment ctx, MemorySegment q, MemorySegment k, MemorySegment v, MemorySegment mask, float scale, float max_bias, float logit_softcap) {
        var mh$ = ggml_flash_attn_ext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_flash_attn_ext", ctx, q, k, v, mask, scale, max_bias, logit_softcap);
            }
            return (MemorySegment)mh$.invokeExact(ctx, q, k, v, mask, scale, max_bias, logit_softcap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_flash_attn_ext_set_prec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_flash_attn_ext_set_prec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_flash_attn_ext_set_prec(struct ggml_tensor *a, enum ggml_prec prec)
     * }
     */
    public static FunctionDescriptor ggml_flash_attn_ext_set_prec$descriptor() {
        return ggml_flash_attn_ext_set_prec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_flash_attn_ext_set_prec(struct ggml_tensor *a, enum ggml_prec prec)
     * }
     */
    public static MethodHandle ggml_flash_attn_ext_set_prec$handle() {
        return ggml_flash_attn_ext_set_prec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_flash_attn_ext_set_prec(struct ggml_tensor *a, enum ggml_prec prec)
     * }
     */
    public static MemorySegment ggml_flash_attn_ext_set_prec$address() {
        return ggml_flash_attn_ext_set_prec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_flash_attn_ext_set_prec(struct ggml_tensor *a, enum ggml_prec prec)
     * }
     */
    public static void ggml_flash_attn_ext_set_prec(MemorySegment a, int prec) {
        var mh$ = ggml_flash_attn_ext_set_prec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_flash_attn_ext_set_prec", a, prec);
            }
            mh$.invokeExact(a, prec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_flash_attn_ext_get_prec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_flash_attn_ext_get_prec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_prec ggml_flash_attn_ext_get_prec(const struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_flash_attn_ext_get_prec$descriptor() {
        return ggml_flash_attn_ext_get_prec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_prec ggml_flash_attn_ext_get_prec(const struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_flash_attn_ext_get_prec$handle() {
        return ggml_flash_attn_ext_get_prec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_prec ggml_flash_attn_ext_get_prec(const struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_flash_attn_ext_get_prec$address() {
        return ggml_flash_attn_ext_get_prec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_prec ggml_flash_attn_ext_get_prec(const struct ggml_tensor *a)
     * }
     */
    public static int ggml_flash_attn_ext_get_prec(MemorySegment a) {
        var mh$ = ggml_flash_attn_ext_get_prec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_flash_attn_ext_get_prec", a);
            }
            return (int)mh$.invokeExact(a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_flash_attn_back {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_BOOL
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_flash_attn_back");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_flash_attn_back(struct ggml_context *ctx, struct ggml_tensor *q, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *d, bool masked)
     * }
     */
    public static FunctionDescriptor ggml_flash_attn_back$descriptor() {
        return ggml_flash_attn_back.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_flash_attn_back(struct ggml_context *ctx, struct ggml_tensor *q, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *d, bool masked)
     * }
     */
    public static MethodHandle ggml_flash_attn_back$handle() {
        return ggml_flash_attn_back.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_flash_attn_back(struct ggml_context *ctx, struct ggml_tensor *q, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *d, bool masked)
     * }
     */
    public static MemorySegment ggml_flash_attn_back$address() {
        return ggml_flash_attn_back.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_flash_attn_back(struct ggml_context *ctx, struct ggml_tensor *q, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *d, bool masked)
     * }
     */
    public static MemorySegment ggml_flash_attn_back(MemorySegment ctx, MemorySegment q, MemorySegment k, MemorySegment v, MemorySegment d, boolean masked) {
        var mh$ = ggml_flash_attn_back.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_flash_attn_back", ctx, q, k, v, d, masked);
            }
            return (MemorySegment)mh$.invokeExact(ctx, q, k, v, d, masked);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_ssm_conv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_ssm_conv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_ssm_conv(struct ggml_context *ctx, struct ggml_tensor *sx, struct ggml_tensor *c)
     * }
     */
    public static FunctionDescriptor ggml_ssm_conv$descriptor() {
        return ggml_ssm_conv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_ssm_conv(struct ggml_context *ctx, struct ggml_tensor *sx, struct ggml_tensor *c)
     * }
     */
    public static MethodHandle ggml_ssm_conv$handle() {
        return ggml_ssm_conv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_ssm_conv(struct ggml_context *ctx, struct ggml_tensor *sx, struct ggml_tensor *c)
     * }
     */
    public static MemorySegment ggml_ssm_conv$address() {
        return ggml_ssm_conv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_ssm_conv(struct ggml_context *ctx, struct ggml_tensor *sx, struct ggml_tensor *c)
     * }
     */
    public static MemorySegment ggml_ssm_conv(MemorySegment ctx, MemorySegment sx, MemorySegment c) {
        var mh$ = ggml_ssm_conv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_ssm_conv", ctx, sx, c);
            }
            return (MemorySegment)mh$.invokeExact(ctx, sx, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_ssm_scan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_ssm_scan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_ssm_scan(struct ggml_context *ctx, struct ggml_tensor *s, struct ggml_tensor *x, struct ggml_tensor *dt, struct ggml_tensor *A, struct ggml_tensor *B, struct ggml_tensor *C, struct ggml_tensor *ids)
     * }
     */
    public static FunctionDescriptor ggml_ssm_scan$descriptor() {
        return ggml_ssm_scan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_ssm_scan(struct ggml_context *ctx, struct ggml_tensor *s, struct ggml_tensor *x, struct ggml_tensor *dt, struct ggml_tensor *A, struct ggml_tensor *B, struct ggml_tensor *C, struct ggml_tensor *ids)
     * }
     */
    public static MethodHandle ggml_ssm_scan$handle() {
        return ggml_ssm_scan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_ssm_scan(struct ggml_context *ctx, struct ggml_tensor *s, struct ggml_tensor *x, struct ggml_tensor *dt, struct ggml_tensor *A, struct ggml_tensor *B, struct ggml_tensor *C, struct ggml_tensor *ids)
     * }
     */
    public static MemorySegment ggml_ssm_scan$address() {
        return ggml_ssm_scan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_ssm_scan(struct ggml_context *ctx, struct ggml_tensor *s, struct ggml_tensor *x, struct ggml_tensor *dt, struct ggml_tensor *A, struct ggml_tensor *B, struct ggml_tensor *C, struct ggml_tensor *ids)
     * }
     */
    public static MemorySegment ggml_ssm_scan(MemorySegment ctx, MemorySegment s, MemorySegment x, MemorySegment dt, MemorySegment A, MemorySegment B, MemorySegment C, MemorySegment ids) {
        var mh$ = ggml_ssm_scan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_ssm_scan", ctx, s, x, dt, A, B, C, ids);
            }
            return (MemorySegment)mh$.invokeExact(ctx, s, x, dt, A, B, C, ids);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_win_part {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_win_part");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_win_part(struct ggml_context *ctx, struct ggml_tensor *a, int w)
     * }
     */
    public static FunctionDescriptor ggml_win_part$descriptor() {
        return ggml_win_part.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_win_part(struct ggml_context *ctx, struct ggml_tensor *a, int w)
     * }
     */
    public static MethodHandle ggml_win_part$handle() {
        return ggml_win_part.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_win_part(struct ggml_context *ctx, struct ggml_tensor *a, int w)
     * }
     */
    public static MemorySegment ggml_win_part$address() {
        return ggml_win_part.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_win_part(struct ggml_context *ctx, struct ggml_tensor *a, int w)
     * }
     */
    public static MemorySegment ggml_win_part(MemorySegment ctx, MemorySegment a, int w) {
        var mh$ = ggml_win_part.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_win_part", ctx, a, w);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_win_unpart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_win_unpart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_win_unpart(struct ggml_context *ctx, struct ggml_tensor *a, int w0, int h0, int w)
     * }
     */
    public static FunctionDescriptor ggml_win_unpart$descriptor() {
        return ggml_win_unpart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_win_unpart(struct ggml_context *ctx, struct ggml_tensor *a, int w0, int h0, int w)
     * }
     */
    public static MethodHandle ggml_win_unpart$handle() {
        return ggml_win_unpart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_win_unpart(struct ggml_context *ctx, struct ggml_tensor *a, int w0, int h0, int w)
     * }
     */
    public static MemorySegment ggml_win_unpart$address() {
        return ggml_win_unpart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_win_unpart(struct ggml_context *ctx, struct ggml_tensor *a, int w0, int h0, int w)
     * }
     */
    public static MemorySegment ggml_win_unpart(MemorySegment ctx, MemorySegment a, int w0, int h0, int w) {
        var mh$ = ggml_win_unpart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_win_unpart", ctx, a, w0, h0, w);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, w0, h0, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_unary {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_unary");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_unary(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_unary_op op)
     * }
     */
    public static FunctionDescriptor ggml_unary$descriptor() {
        return ggml_unary.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_unary(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_unary_op op)
     * }
     */
    public static MethodHandle ggml_unary$handle() {
        return ggml_unary.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_unary(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_unary_op op)
     * }
     */
    public static MemorySegment ggml_unary$address() {
        return ggml_unary.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_unary(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_unary_op op)
     * }
     */
    public static MemorySegment ggml_unary(MemorySegment ctx, MemorySegment a, int op) {
        var mh$ = ggml_unary.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_unary", ctx, a, op);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_unary_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_unary_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_unary_inplace(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_unary_op op)
     * }
     */
    public static FunctionDescriptor ggml_unary_inplace$descriptor() {
        return ggml_unary_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_unary_inplace(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_unary_op op)
     * }
     */
    public static MethodHandle ggml_unary_inplace$handle() {
        return ggml_unary_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_unary_inplace(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_unary_op op)
     * }
     */
    public static MemorySegment ggml_unary_inplace$address() {
        return ggml_unary_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_unary_inplace(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_unary_op op)
     * }
     */
    public static MemorySegment ggml_unary_inplace(MemorySegment ctx, MemorySegment a, int op) {
        var mh$ = ggml_unary_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_unary_inplace", ctx, a, op);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_rel_pos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_rel_pos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_rel_pos(struct ggml_context *ctx, struct ggml_tensor *a, int qh, int kh)
     * }
     */
    public static FunctionDescriptor ggml_get_rel_pos$descriptor() {
        return ggml_get_rel_pos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_rel_pos(struct ggml_context *ctx, struct ggml_tensor *a, int qh, int kh)
     * }
     */
    public static MethodHandle ggml_get_rel_pos$handle() {
        return ggml_get_rel_pos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_rel_pos(struct ggml_context *ctx, struct ggml_tensor *a, int qh, int kh)
     * }
     */
    public static MemorySegment ggml_get_rel_pos$address() {
        return ggml_get_rel_pos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_rel_pos(struct ggml_context *ctx, struct ggml_tensor *a, int qh, int kh)
     * }
     */
    public static MemorySegment ggml_get_rel_pos(MemorySegment ctx, MemorySegment a, int qh, int kh) {
        var mh$ = ggml_get_rel_pos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_rel_pos", ctx, a, qh, kh);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, qh, kh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_add_rel_pos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_add_rel_pos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_rel_pos(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *pw, struct ggml_tensor *ph)
     * }
     */
    public static FunctionDescriptor ggml_add_rel_pos$descriptor() {
        return ggml_add_rel_pos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_rel_pos(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *pw, struct ggml_tensor *ph)
     * }
     */
    public static MethodHandle ggml_add_rel_pos$handle() {
        return ggml_add_rel_pos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_rel_pos(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *pw, struct ggml_tensor *ph)
     * }
     */
    public static MemorySegment ggml_add_rel_pos$address() {
        return ggml_add_rel_pos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_rel_pos(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *pw, struct ggml_tensor *ph)
     * }
     */
    public static MemorySegment ggml_add_rel_pos(MemorySegment ctx, MemorySegment a, MemorySegment pw, MemorySegment ph) {
        var mh$ = ggml_add_rel_pos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_add_rel_pos", ctx, a, pw, ph);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, pw, ph);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_add_rel_pos_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_add_rel_pos_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_rel_pos_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *pw, struct ggml_tensor *ph)
     * }
     */
    public static FunctionDescriptor ggml_add_rel_pos_inplace$descriptor() {
        return ggml_add_rel_pos_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_rel_pos_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *pw, struct ggml_tensor *ph)
     * }
     */
    public static MethodHandle ggml_add_rel_pos_inplace$handle() {
        return ggml_add_rel_pos_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_rel_pos_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *pw, struct ggml_tensor *ph)
     * }
     */
    public static MemorySegment ggml_add_rel_pos_inplace$address() {
        return ggml_add_rel_pos_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_rel_pos_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *pw, struct ggml_tensor *ph)
     * }
     */
    public static MemorySegment ggml_add_rel_pos_inplace(MemorySegment ctx, MemorySegment a, MemorySegment pw, MemorySegment ph) {
        var mh$ = ggml_add_rel_pos_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_add_rel_pos_inplace", ctx, a, pw, ph);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, pw, ph);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_rwkv_wkv6 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_rwkv_wkv6");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rwkv_wkv6(struct ggml_context *ctx, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *r, struct ggml_tensor *tf, struct ggml_tensor *td, struct ggml_tensor *state)
     * }
     */
    public static FunctionDescriptor ggml_rwkv_wkv6$descriptor() {
        return ggml_rwkv_wkv6.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rwkv_wkv6(struct ggml_context *ctx, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *r, struct ggml_tensor *tf, struct ggml_tensor *td, struct ggml_tensor *state)
     * }
     */
    public static MethodHandle ggml_rwkv_wkv6$handle() {
        return ggml_rwkv_wkv6.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rwkv_wkv6(struct ggml_context *ctx, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *r, struct ggml_tensor *tf, struct ggml_tensor *td, struct ggml_tensor *state)
     * }
     */
    public static MemorySegment ggml_rwkv_wkv6$address() {
        return ggml_rwkv_wkv6.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rwkv_wkv6(struct ggml_context *ctx, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *r, struct ggml_tensor *tf, struct ggml_tensor *td, struct ggml_tensor *state)
     * }
     */
    public static MemorySegment ggml_rwkv_wkv6(MemorySegment ctx, MemorySegment k, MemorySegment v, MemorySegment r, MemorySegment tf, MemorySegment td, MemorySegment state) {
        var mh$ = ggml_rwkv_wkv6.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_rwkv_wkv6", ctx, k, v, r, tf, td, state);
            }
            return (MemorySegment)mh$.invokeExact(ctx, k, v, r, tf, td, state);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_gated_linear_attn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_gated_linear_attn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gated_linear_attn(struct ggml_context *ctx, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *q, struct ggml_tensor *g, struct ggml_tensor *state, float scale)
     * }
     */
    public static FunctionDescriptor ggml_gated_linear_attn$descriptor() {
        return ggml_gated_linear_attn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gated_linear_attn(struct ggml_context *ctx, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *q, struct ggml_tensor *g, struct ggml_tensor *state, float scale)
     * }
     */
    public static MethodHandle ggml_gated_linear_attn$handle() {
        return ggml_gated_linear_attn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gated_linear_attn(struct ggml_context *ctx, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *q, struct ggml_tensor *g, struct ggml_tensor *state, float scale)
     * }
     */
    public static MemorySegment ggml_gated_linear_attn$address() {
        return ggml_gated_linear_attn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gated_linear_attn(struct ggml_context *ctx, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *q, struct ggml_tensor *g, struct ggml_tensor *state, float scale)
     * }
     */
    public static MemorySegment ggml_gated_linear_attn(MemorySegment ctx, MemorySegment k, MemorySegment v, MemorySegment q, MemorySegment g, MemorySegment state, float scale) {
        var mh$ = ggml_gated_linear_attn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_gated_linear_attn", ctx, k, v, q, g, state, scale);
            }
            return (MemorySegment)mh$.invokeExact(ctx, k, v, q, g, state, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_rwkv_wkv7 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_rwkv_wkv7");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rwkv_wkv7(struct ggml_context *ctx, struct ggml_tensor *r, struct ggml_tensor *w, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *state)
     * }
     */
    public static FunctionDescriptor ggml_rwkv_wkv7$descriptor() {
        return ggml_rwkv_wkv7.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rwkv_wkv7(struct ggml_context *ctx, struct ggml_tensor *r, struct ggml_tensor *w, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *state)
     * }
     */
    public static MethodHandle ggml_rwkv_wkv7$handle() {
        return ggml_rwkv_wkv7.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rwkv_wkv7(struct ggml_context *ctx, struct ggml_tensor *r, struct ggml_tensor *w, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *state)
     * }
     */
    public static MemorySegment ggml_rwkv_wkv7$address() {
        return ggml_rwkv_wkv7.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rwkv_wkv7(struct ggml_context *ctx, struct ggml_tensor *r, struct ggml_tensor *w, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *state)
     * }
     */
    public static MemorySegment ggml_rwkv_wkv7(MemorySegment ctx, MemorySegment r, MemorySegment w, MemorySegment k, MemorySegment v, MemorySegment a, MemorySegment b, MemorySegment state) {
        var mh$ = ggml_rwkv_wkv7.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_rwkv_wkv7", ctx, r, w, k, v, a, b, state);
            }
            return (MemorySegment)mh$.invokeExact(ctx, r, w, k, v, a, b, state);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_map_custom1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_map_custom1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom1(struct ggml_context *ctx, struct ggml_tensor *a, ggml_custom1_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static FunctionDescriptor ggml_map_custom1$descriptor() {
        return ggml_map_custom1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom1(struct ggml_context *ctx, struct ggml_tensor *a, ggml_custom1_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MethodHandle ggml_map_custom1$handle() {
        return ggml_map_custom1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom1(struct ggml_context *ctx, struct ggml_tensor *a, ggml_custom1_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_map_custom1$address() {
        return ggml_map_custom1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom1(struct ggml_context *ctx, struct ggml_tensor *a, ggml_custom1_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_map_custom1(MemorySegment ctx, MemorySegment a, MemorySegment fun, int n_tasks, MemorySegment userdata) {
        var mh$ = ggml_map_custom1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_map_custom1", ctx, a, fun, n_tasks, userdata);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, fun, n_tasks, userdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_map_custom1_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_map_custom1_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom1_inplace(struct ggml_context *ctx, struct ggml_tensor *a, ggml_custom1_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static FunctionDescriptor ggml_map_custom1_inplace$descriptor() {
        return ggml_map_custom1_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom1_inplace(struct ggml_context *ctx, struct ggml_tensor *a, ggml_custom1_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MethodHandle ggml_map_custom1_inplace$handle() {
        return ggml_map_custom1_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom1_inplace(struct ggml_context *ctx, struct ggml_tensor *a, ggml_custom1_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_map_custom1_inplace$address() {
        return ggml_map_custom1_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom1_inplace(struct ggml_context *ctx, struct ggml_tensor *a, ggml_custom1_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_map_custom1_inplace(MemorySegment ctx, MemorySegment a, MemorySegment fun, int n_tasks, MemorySegment userdata) {
        var mh$ = ggml_map_custom1_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_map_custom1_inplace", ctx, a, fun, n_tasks, userdata);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, fun, n_tasks, userdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_map_custom2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_map_custom2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom2(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, ggml_custom2_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static FunctionDescriptor ggml_map_custom2$descriptor() {
        return ggml_map_custom2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom2(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, ggml_custom2_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MethodHandle ggml_map_custom2$handle() {
        return ggml_map_custom2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom2(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, ggml_custom2_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_map_custom2$address() {
        return ggml_map_custom2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom2(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, ggml_custom2_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_map_custom2(MemorySegment ctx, MemorySegment a, MemorySegment b, MemorySegment fun, int n_tasks, MemorySegment userdata) {
        var mh$ = ggml_map_custom2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_map_custom2", ctx, a, b, fun, n_tasks, userdata);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, fun, n_tasks, userdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_map_custom2_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_map_custom2_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom2_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, ggml_custom2_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static FunctionDescriptor ggml_map_custom2_inplace$descriptor() {
        return ggml_map_custom2_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom2_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, ggml_custom2_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MethodHandle ggml_map_custom2_inplace$handle() {
        return ggml_map_custom2_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom2_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, ggml_custom2_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_map_custom2_inplace$address() {
        return ggml_map_custom2_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom2_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, ggml_custom2_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_map_custom2_inplace(MemorySegment ctx, MemorySegment a, MemorySegment b, MemorySegment fun, int n_tasks, MemorySegment userdata) {
        var mh$ = ggml_map_custom2_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_map_custom2_inplace", ctx, a, b, fun, n_tasks, userdata);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, fun, n_tasks, userdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_map_custom3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_map_custom3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom3(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, ggml_custom3_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static FunctionDescriptor ggml_map_custom3$descriptor() {
        return ggml_map_custom3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom3(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, ggml_custom3_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MethodHandle ggml_map_custom3$handle() {
        return ggml_map_custom3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom3(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, ggml_custom3_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_map_custom3$address() {
        return ggml_map_custom3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom3(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, ggml_custom3_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_map_custom3(MemorySegment ctx, MemorySegment a, MemorySegment b, MemorySegment c, MemorySegment fun, int n_tasks, MemorySegment userdata) {
        var mh$ = ggml_map_custom3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_map_custom3", ctx, a, b, c, fun, n_tasks, userdata);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, c, fun, n_tasks, userdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_map_custom3_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_map_custom3_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom3_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, ggml_custom3_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static FunctionDescriptor ggml_map_custom3_inplace$descriptor() {
        return ggml_map_custom3_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom3_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, ggml_custom3_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MethodHandle ggml_map_custom3_inplace$handle() {
        return ggml_map_custom3_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom3_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, ggml_custom3_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_map_custom3_inplace$address() {
        return ggml_map_custom3_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom3_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, ggml_custom3_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_map_custom3_inplace(MemorySegment ctx, MemorySegment a, MemorySegment b, MemorySegment c, MemorySegment fun, int n_tasks, MemorySegment userdata) {
        var mh$ = ggml_map_custom3_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_map_custom3_inplace", ctx, a, b, c, fun, n_tasks, userdata);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, c, fun, n_tasks, userdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_custom_4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_custom_4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_custom_4d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3, struct ggml_tensor **args, int n_args, ggml_custom_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static FunctionDescriptor ggml_custom_4d$descriptor() {
        return ggml_custom_4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_custom_4d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3, struct ggml_tensor **args, int n_args, ggml_custom_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MethodHandle ggml_custom_4d$handle() {
        return ggml_custom_4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_custom_4d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3, struct ggml_tensor **args, int n_args, ggml_custom_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_custom_4d$address() {
        return ggml_custom_4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_custom_4d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3, struct ggml_tensor **args, int n_args, ggml_custom_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_custom_4d(MemorySegment ctx, int type, long ne0, long ne1, long ne2, long ne3, MemorySegment args, int n_args, MemorySegment fun, int n_tasks, MemorySegment userdata) {
        var mh$ = ggml_custom_4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_custom_4d", ctx, type, ne0, ne1, ne2, ne3, args, n_args, fun, n_tasks, userdata);
            }
            return (MemorySegment)mh$.invokeExact(ctx, type, ne0, ne1, ne2, ne3, args, n_args, fun, n_tasks, userdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_custom_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_custom_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_custom_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor **args, int n_args, ggml_custom_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static FunctionDescriptor ggml_custom_inplace$descriptor() {
        return ggml_custom_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_custom_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor **args, int n_args, ggml_custom_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MethodHandle ggml_custom_inplace$handle() {
        return ggml_custom_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_custom_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor **args, int n_args, ggml_custom_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_custom_inplace$address() {
        return ggml_custom_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_custom_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor **args, int n_args, ggml_custom_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_custom_inplace(MemorySegment ctx, MemorySegment a, MemorySegment args, int n_args, MemorySegment fun, int n_tasks, MemorySegment userdata) {
        var mh$ = ggml_custom_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_custom_inplace", ctx, a, args, n_args, fun, n_tasks, userdata);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, args, n_args, fun, n_tasks, userdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cross_entropy_loss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cross_entropy_loss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cross_entropy_loss(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_cross_entropy_loss$descriptor() {
        return ggml_cross_entropy_loss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cross_entropy_loss(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_cross_entropy_loss$handle() {
        return ggml_cross_entropy_loss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cross_entropy_loss(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_cross_entropy_loss$address() {
        return ggml_cross_entropy_loss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cross_entropy_loss(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_cross_entropy_loss(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_cross_entropy_loss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cross_entropy_loss", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cross_entropy_loss_back {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cross_entropy_loss_back");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cross_entropy_loss_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c)
     * }
     */
    public static FunctionDescriptor ggml_cross_entropy_loss_back$descriptor() {
        return ggml_cross_entropy_loss_back.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cross_entropy_loss_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c)
     * }
     */
    public static MethodHandle ggml_cross_entropy_loss_back$handle() {
        return ggml_cross_entropy_loss_back.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cross_entropy_loss_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c)
     * }
     */
    public static MemorySegment ggml_cross_entropy_loss_back$address() {
        return ggml_cross_entropy_loss_back.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cross_entropy_loss_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c)
     * }
     */
    public static MemorySegment ggml_cross_entropy_loss_back(MemorySegment ctx, MemorySegment a, MemorySegment b, MemorySegment c) {
        var mh$ = ggml_cross_entropy_loss_back.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cross_entropy_loss_back", ctx, a, b, c);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_opt_step_adamw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_opt_step_adamw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_step_adamw(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *grad, struct ggml_tensor *m, struct ggml_tensor *v, struct ggml_tensor *adamw_params)
     * }
     */
    public static FunctionDescriptor ggml_opt_step_adamw$descriptor() {
        return ggml_opt_step_adamw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_step_adamw(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *grad, struct ggml_tensor *m, struct ggml_tensor *v, struct ggml_tensor *adamw_params)
     * }
     */
    public static MethodHandle ggml_opt_step_adamw$handle() {
        return ggml_opt_step_adamw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_step_adamw(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *grad, struct ggml_tensor *m, struct ggml_tensor *v, struct ggml_tensor *adamw_params)
     * }
     */
    public static MemorySegment ggml_opt_step_adamw$address() {
        return ggml_opt_step_adamw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_step_adamw(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *grad, struct ggml_tensor *m, struct ggml_tensor *v, struct ggml_tensor *adamw_params)
     * }
     */
    public static MemorySegment ggml_opt_step_adamw(MemorySegment ctx, MemorySegment a, MemorySegment grad, MemorySegment m, MemorySegment v, MemorySegment adamw_params) {
        var mh$ = ggml_opt_step_adamw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_opt_step_adamw", ctx, a, grad, m, v, adamw_params);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, grad, m, v, adamw_params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_build_forward_expand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_build_forward_expand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_build_forward_expand(struct ggml_cgraph *cgraph, struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_build_forward_expand$descriptor() {
        return ggml_build_forward_expand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_build_forward_expand(struct ggml_cgraph *cgraph, struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_build_forward_expand$handle() {
        return ggml_build_forward_expand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_build_forward_expand(struct ggml_cgraph *cgraph, struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_build_forward_expand$address() {
        return ggml_build_forward_expand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_build_forward_expand(struct ggml_cgraph *cgraph, struct ggml_tensor *tensor)
     * }
     */
    public static void ggml_build_forward_expand(MemorySegment cgraph, MemorySegment tensor) {
        var mh$ = ggml_build_forward_expand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_build_forward_expand", cgraph, tensor);
            }
            mh$.invokeExact(cgraph, tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_build_backward_expand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_build_backward_expand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_build_backward_expand(struct ggml_context *ctx, struct ggml_cgraph *cgraph, struct ggml_tensor **grad_accs)
     * }
     */
    public static FunctionDescriptor ggml_build_backward_expand$descriptor() {
        return ggml_build_backward_expand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_build_backward_expand(struct ggml_context *ctx, struct ggml_cgraph *cgraph, struct ggml_tensor **grad_accs)
     * }
     */
    public static MethodHandle ggml_build_backward_expand$handle() {
        return ggml_build_backward_expand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_build_backward_expand(struct ggml_context *ctx, struct ggml_cgraph *cgraph, struct ggml_tensor **grad_accs)
     * }
     */
    public static MemorySegment ggml_build_backward_expand$address() {
        return ggml_build_backward_expand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_build_backward_expand(struct ggml_context *ctx, struct ggml_cgraph *cgraph, struct ggml_tensor **grad_accs)
     * }
     */
    public static void ggml_build_backward_expand(MemorySegment ctx, MemorySegment cgraph, MemorySegment grad_accs) {
        var mh$ = ggml_build_backward_expand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_build_backward_expand", ctx, cgraph, grad_accs);
            }
            mh$.invokeExact(ctx, cgraph, grad_accs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_new_graph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_new_graph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_cgraph *ggml_new_graph(struct ggml_context *ctx)
     * }
     */
    public static FunctionDescriptor ggml_new_graph$descriptor() {
        return ggml_new_graph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_cgraph *ggml_new_graph(struct ggml_context *ctx)
     * }
     */
    public static MethodHandle ggml_new_graph$handle() {
        return ggml_new_graph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_cgraph *ggml_new_graph(struct ggml_context *ctx)
     * }
     */
    public static MemorySegment ggml_new_graph$address() {
        return ggml_new_graph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_cgraph *ggml_new_graph(struct ggml_context *ctx)
     * }
     */
    public static MemorySegment ggml_new_graph(MemorySegment ctx) {
        var mh$ = ggml_new_graph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_new_graph", ctx);
            }
            return (MemorySegment)mh$.invokeExact(ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_new_graph_custom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_BOOL
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_new_graph_custom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_cgraph *ggml_new_graph_custom(struct ggml_context *ctx, size_t size, bool grads)
     * }
     */
    public static FunctionDescriptor ggml_new_graph_custom$descriptor() {
        return ggml_new_graph_custom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_cgraph *ggml_new_graph_custom(struct ggml_context *ctx, size_t size, bool grads)
     * }
     */
    public static MethodHandle ggml_new_graph_custom$handle() {
        return ggml_new_graph_custom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_cgraph *ggml_new_graph_custom(struct ggml_context *ctx, size_t size, bool grads)
     * }
     */
    public static MemorySegment ggml_new_graph_custom$address() {
        return ggml_new_graph_custom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_cgraph *ggml_new_graph_custom(struct ggml_context *ctx, size_t size, bool grads)
     * }
     */
    public static MemorySegment ggml_new_graph_custom(MemorySegment ctx, long size, boolean grads) {
        var mh$ = ggml_new_graph_custom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_new_graph_custom", ctx, size, grads);
            }
            return (MemorySegment)mh$.invokeExact(ctx, size, grads);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_dup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_BOOL
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_graph_dup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_cgraph *ggml_graph_dup(struct ggml_context *ctx, struct ggml_cgraph *cgraph, bool force_grads)
     * }
     */
    public static FunctionDescriptor ggml_graph_dup$descriptor() {
        return ggml_graph_dup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_cgraph *ggml_graph_dup(struct ggml_context *ctx, struct ggml_cgraph *cgraph, bool force_grads)
     * }
     */
    public static MethodHandle ggml_graph_dup$handle() {
        return ggml_graph_dup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_cgraph *ggml_graph_dup(struct ggml_context *ctx, struct ggml_cgraph *cgraph, bool force_grads)
     * }
     */
    public static MemorySegment ggml_graph_dup$address() {
        return ggml_graph_dup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_cgraph *ggml_graph_dup(struct ggml_context *ctx, struct ggml_cgraph *cgraph, bool force_grads)
     * }
     */
    public static MemorySegment ggml_graph_dup(MemorySegment ctx, MemorySegment cgraph, boolean force_grads) {
        var mh$ = ggml_graph_dup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_dup", ctx, cgraph, force_grads);
            }
            return (MemorySegment)mh$.invokeExact(ctx, cgraph, force_grads);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_cpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_graph_cpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_graph_cpy(struct ggml_cgraph *src, struct ggml_cgraph *dst)
     * }
     */
    public static FunctionDescriptor ggml_graph_cpy$descriptor() {
        return ggml_graph_cpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_graph_cpy(struct ggml_cgraph *src, struct ggml_cgraph *dst)
     * }
     */
    public static MethodHandle ggml_graph_cpy$handle() {
        return ggml_graph_cpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_graph_cpy(struct ggml_cgraph *src, struct ggml_cgraph *dst)
     * }
     */
    public static MemorySegment ggml_graph_cpy$address() {
        return ggml_graph_cpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_graph_cpy(struct ggml_cgraph *src, struct ggml_cgraph *dst)
     * }
     */
    public static void ggml_graph_cpy(MemorySegment src, MemorySegment dst) {
        var mh$ = ggml_graph_cpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_cpy", src, dst);
            }
            mh$.invokeExact(src, dst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_graph_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_graph_reset(struct ggml_cgraph *cgraph)
     * }
     */
    public static FunctionDescriptor ggml_graph_reset$descriptor() {
        return ggml_graph_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_graph_reset(struct ggml_cgraph *cgraph)
     * }
     */
    public static MethodHandle ggml_graph_reset$handle() {
        return ggml_graph_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_graph_reset(struct ggml_cgraph *cgraph)
     * }
     */
    public static MemorySegment ggml_graph_reset$address() {
        return ggml_graph_reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_graph_reset(struct ggml_cgraph *cgraph)
     * }
     */
    public static void ggml_graph_reset(MemorySegment cgraph) {
        var mh$ = ggml_graph_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_reset", cgraph);
            }
            mh$.invokeExact(cgraph);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_graph_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_graph_clear(struct ggml_cgraph *cgraph)
     * }
     */
    public static FunctionDescriptor ggml_graph_clear$descriptor() {
        return ggml_graph_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_graph_clear(struct ggml_cgraph *cgraph)
     * }
     */
    public static MethodHandle ggml_graph_clear$handle() {
        return ggml_graph_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_graph_clear(struct ggml_cgraph *cgraph)
     * }
     */
    public static MemorySegment ggml_graph_clear$address() {
        return ggml_graph_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_graph_clear(struct ggml_cgraph *cgraph)
     * }
     */
    public static void ggml_graph_clear(MemorySegment cgraph) {
        var mh$ = ggml_graph_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_clear", cgraph);
            }
            mh$.invokeExact(cgraph);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_graph_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_graph_size(struct ggml_cgraph *cgraph)
     * }
     */
    public static FunctionDescriptor ggml_graph_size$descriptor() {
        return ggml_graph_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_graph_size(struct ggml_cgraph *cgraph)
     * }
     */
    public static MethodHandle ggml_graph_size$handle() {
        return ggml_graph_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_graph_size(struct ggml_cgraph *cgraph)
     * }
     */
    public static MemorySegment ggml_graph_size$address() {
        return ggml_graph_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_graph_size(struct ggml_cgraph *cgraph)
     * }
     */
    public static int ggml_graph_size(MemorySegment cgraph) {
        var mh$ = ggml_graph_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_size", cgraph);
            }
            return (int)mh$.invokeExact(cgraph);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_node {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_graph_node");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_node(struct ggml_cgraph *cgraph, int i)
     * }
     */
    public static FunctionDescriptor ggml_graph_node$descriptor() {
        return ggml_graph_node.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_node(struct ggml_cgraph *cgraph, int i)
     * }
     */
    public static MethodHandle ggml_graph_node$handle() {
        return ggml_graph_node.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_node(struct ggml_cgraph *cgraph, int i)
     * }
     */
    public static MemorySegment ggml_graph_node$address() {
        return ggml_graph_node.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_node(struct ggml_cgraph *cgraph, int i)
     * }
     */
    public static MemorySegment ggml_graph_node(MemorySegment cgraph, int i) {
        var mh$ = ggml_graph_node.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_node", cgraph, i);
            }
            return (MemorySegment)mh$.invokeExact(cgraph, i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_nodes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_graph_nodes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor **ggml_graph_nodes(struct ggml_cgraph *cgraph)
     * }
     */
    public static FunctionDescriptor ggml_graph_nodes$descriptor() {
        return ggml_graph_nodes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor **ggml_graph_nodes(struct ggml_cgraph *cgraph)
     * }
     */
    public static MethodHandle ggml_graph_nodes$handle() {
        return ggml_graph_nodes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor **ggml_graph_nodes(struct ggml_cgraph *cgraph)
     * }
     */
    public static MemorySegment ggml_graph_nodes$address() {
        return ggml_graph_nodes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor **ggml_graph_nodes(struct ggml_cgraph *cgraph)
     * }
     */
    public static MemorySegment ggml_graph_nodes(MemorySegment cgraph) {
        var mh$ = ggml_graph_nodes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_nodes", cgraph);
            }
            return (MemorySegment)mh$.invokeExact(cgraph);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_n_nodes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_graph_n_nodes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_graph_n_nodes(struct ggml_cgraph *cgraph)
     * }
     */
    public static FunctionDescriptor ggml_graph_n_nodes$descriptor() {
        return ggml_graph_n_nodes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_graph_n_nodes(struct ggml_cgraph *cgraph)
     * }
     */
    public static MethodHandle ggml_graph_n_nodes$handle() {
        return ggml_graph_n_nodes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_graph_n_nodes(struct ggml_cgraph *cgraph)
     * }
     */
    public static MemorySegment ggml_graph_n_nodes$address() {
        return ggml_graph_n_nodes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_graph_n_nodes(struct ggml_cgraph *cgraph)
     * }
     */
    public static int ggml_graph_n_nodes(MemorySegment cgraph) {
        var mh$ = ggml_graph_n_nodes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_n_nodes", cgraph);
            }
            return (int)mh$.invokeExact(cgraph);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_add_node {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_graph_add_node");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_graph_add_node(struct ggml_cgraph *cgraph, struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_graph_add_node$descriptor() {
        return ggml_graph_add_node.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_graph_add_node(struct ggml_cgraph *cgraph, struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_graph_add_node$handle() {
        return ggml_graph_add_node.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_graph_add_node(struct ggml_cgraph *cgraph, struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_graph_add_node$address() {
        return ggml_graph_add_node.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_graph_add_node(struct ggml_cgraph *cgraph, struct ggml_tensor *tensor)
     * }
     */
    public static void ggml_graph_add_node(MemorySegment cgraph, MemorySegment tensor) {
        var mh$ = ggml_graph_add_node.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_add_node", cgraph, tensor);
            }
            mh$.invokeExact(cgraph, tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_overhead {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_graph_overhead");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_graph_overhead()
     * }
     */
    public static FunctionDescriptor ggml_graph_overhead$descriptor() {
        return ggml_graph_overhead.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_graph_overhead()
     * }
     */
    public static MethodHandle ggml_graph_overhead$handle() {
        return ggml_graph_overhead.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_graph_overhead()
     * }
     */
    public static MemorySegment ggml_graph_overhead$address() {
        return ggml_graph_overhead.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_graph_overhead()
     * }
     */
    public static long ggml_graph_overhead() {
        var mh$ = ggml_graph_overhead.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_overhead");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_overhead_custom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_BOOL
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_graph_overhead_custom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_graph_overhead_custom(size_t size, bool grads)
     * }
     */
    public static FunctionDescriptor ggml_graph_overhead_custom$descriptor() {
        return ggml_graph_overhead_custom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_graph_overhead_custom(size_t size, bool grads)
     * }
     */
    public static MethodHandle ggml_graph_overhead_custom$handle() {
        return ggml_graph_overhead_custom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_graph_overhead_custom(size_t size, bool grads)
     * }
     */
    public static MemorySegment ggml_graph_overhead_custom$address() {
        return ggml_graph_overhead_custom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_graph_overhead_custom(size_t size, bool grads)
     * }
     */
    public static long ggml_graph_overhead_custom(long size, boolean grads) {
        var mh$ = ggml_graph_overhead_custom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_overhead_custom", size, grads);
            }
            return (long)mh$.invokeExact(size, grads);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_get_tensor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_graph_get_tensor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_get_tensor(const struct ggml_cgraph *cgraph, const char *name)
     * }
     */
    public static FunctionDescriptor ggml_graph_get_tensor$descriptor() {
        return ggml_graph_get_tensor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_get_tensor(const struct ggml_cgraph *cgraph, const char *name)
     * }
     */
    public static MethodHandle ggml_graph_get_tensor$handle() {
        return ggml_graph_get_tensor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_get_tensor(const struct ggml_cgraph *cgraph, const char *name)
     * }
     */
    public static MemorySegment ggml_graph_get_tensor$address() {
        return ggml_graph_get_tensor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_get_tensor(const struct ggml_cgraph *cgraph, const char *name)
     * }
     */
    public static MemorySegment ggml_graph_get_tensor(MemorySegment cgraph, MemorySegment name) {
        var mh$ = ggml_graph_get_tensor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_get_tensor", cgraph, name);
            }
            return (MemorySegment)mh$.invokeExact(cgraph, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_get_grad {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_graph_get_grad");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_get_grad(const struct ggml_cgraph *cgraph, const struct ggml_tensor *node)
     * }
     */
    public static FunctionDescriptor ggml_graph_get_grad$descriptor() {
        return ggml_graph_get_grad.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_get_grad(const struct ggml_cgraph *cgraph, const struct ggml_tensor *node)
     * }
     */
    public static MethodHandle ggml_graph_get_grad$handle() {
        return ggml_graph_get_grad.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_get_grad(const struct ggml_cgraph *cgraph, const struct ggml_tensor *node)
     * }
     */
    public static MemorySegment ggml_graph_get_grad$address() {
        return ggml_graph_get_grad.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_get_grad(const struct ggml_cgraph *cgraph, const struct ggml_tensor *node)
     * }
     */
    public static MemorySegment ggml_graph_get_grad(MemorySegment cgraph, MemorySegment node) {
        var mh$ = ggml_graph_get_grad.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_get_grad", cgraph, node);
            }
            return (MemorySegment)mh$.invokeExact(cgraph, node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_get_grad_acc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_graph_get_grad_acc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_get_grad_acc(const struct ggml_cgraph *cgraph, const struct ggml_tensor *node)
     * }
     */
    public static FunctionDescriptor ggml_graph_get_grad_acc$descriptor() {
        return ggml_graph_get_grad_acc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_get_grad_acc(const struct ggml_cgraph *cgraph, const struct ggml_tensor *node)
     * }
     */
    public static MethodHandle ggml_graph_get_grad_acc$handle() {
        return ggml_graph_get_grad_acc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_get_grad_acc(const struct ggml_cgraph *cgraph, const struct ggml_tensor *node)
     * }
     */
    public static MemorySegment ggml_graph_get_grad_acc$address() {
        return ggml_graph_get_grad_acc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_get_grad_acc(const struct ggml_cgraph *cgraph, const struct ggml_tensor *node)
     * }
     */
    public static MemorySegment ggml_graph_get_grad_acc(MemorySegment cgraph, MemorySegment node) {
        var mh$ = ggml_graph_get_grad_acc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_get_grad_acc", cgraph, node);
            }
            return (MemorySegment)mh$.invokeExact(cgraph, node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_graph_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_graph_print(const struct ggml_cgraph *cgraph)
     * }
     */
    public static FunctionDescriptor ggml_graph_print$descriptor() {
        return ggml_graph_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_graph_print(const struct ggml_cgraph *cgraph)
     * }
     */
    public static MethodHandle ggml_graph_print$handle() {
        return ggml_graph_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_graph_print(const struct ggml_cgraph *cgraph)
     * }
     */
    public static MemorySegment ggml_graph_print$address() {
        return ggml_graph_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_graph_print(const struct ggml_cgraph *cgraph)
     * }
     */
    public static void ggml_graph_print(MemorySegment cgraph) {
        var mh$ = ggml_graph_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_print", cgraph);
            }
            mh$.invokeExact(cgraph);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_dump_dot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_graph_dump_dot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_graph_dump_dot(const struct ggml_cgraph *gb, const struct ggml_cgraph *gf, const char *filename)
     * }
     */
    public static FunctionDescriptor ggml_graph_dump_dot$descriptor() {
        return ggml_graph_dump_dot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_graph_dump_dot(const struct ggml_cgraph *gb, const struct ggml_cgraph *gf, const char *filename)
     * }
     */
    public static MethodHandle ggml_graph_dump_dot$handle() {
        return ggml_graph_dump_dot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_graph_dump_dot(const struct ggml_cgraph *gb, const struct ggml_cgraph *gf, const char *filename)
     * }
     */
    public static MemorySegment ggml_graph_dump_dot$address() {
        return ggml_graph_dump_dot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_graph_dump_dot(const struct ggml_cgraph *gb, const struct ggml_cgraph *gf, const char *filename)
     * }
     */
    public static void ggml_graph_dump_dot(MemorySegment gb, MemorySegment gf, MemorySegment filename) {
        var mh$ = ggml_graph_dump_dot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_dump_dot", gb, gf, filename);
            }
            mh$.invokeExact(gb, gf, filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_log_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_log_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_log_set(ggml_log_callback log_callback, void *user_data)
     * }
     */
    public static FunctionDescriptor ggml_log_set$descriptor() {
        return ggml_log_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_log_set(ggml_log_callback log_callback, void *user_data)
     * }
     */
    public static MethodHandle ggml_log_set$handle() {
        return ggml_log_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_log_set(ggml_log_callback log_callback, void *user_data)
     * }
     */
    public static MemorySegment ggml_log_set$address() {
        return ggml_log_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_log_set(ggml_log_callback log_callback, void *user_data)
     * }
     */
    public static void ggml_log_set(MemorySegment log_callback, MemorySegment user_data) {
        var mh$ = ggml_log_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_log_set", log_callback, user_data);
            }
            mh$.invokeExact(log_callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_zero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set_zero");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_zero(struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_set_zero$descriptor() {
        return ggml_set_zero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_zero(struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_set_zero$handle() {
        return ggml_set_zero.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_zero(struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_set_zero$address() {
        return ggml_set_zero.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_zero(struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_set_zero(MemorySegment tensor) {
        var mh$ = ggml_set_zero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_zero", tensor);
            }
            return (MemorySegment)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_quantize_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_quantize_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_quantize_init(enum ggml_type type)
     * }
     */
    public static FunctionDescriptor ggml_quantize_init$descriptor() {
        return ggml_quantize_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_quantize_init(enum ggml_type type)
     * }
     */
    public static MethodHandle ggml_quantize_init$handle() {
        return ggml_quantize_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_quantize_init(enum ggml_type type)
     * }
     */
    public static MemorySegment ggml_quantize_init$address() {
        return ggml_quantize_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_quantize_init(enum ggml_type type)
     * }
     */
    public static void ggml_quantize_init(int type) {
        var mh$ = ggml_quantize_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_quantize_init", type);
            }
            mh$.invokeExact(type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_quantize_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_quantize_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_quantize_free()
     * }
     */
    public static FunctionDescriptor ggml_quantize_free$descriptor() {
        return ggml_quantize_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_quantize_free()
     * }
     */
    public static MethodHandle ggml_quantize_free$handle() {
        return ggml_quantize_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_quantize_free()
     * }
     */
    public static MemorySegment ggml_quantize_free$address() {
        return ggml_quantize_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_quantize_free()
     * }
     */
    public static void ggml_quantize_free() {
        var mh$ = ggml_quantize_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_quantize_free");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_quantize_requires_imatrix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_quantize_requires_imatrix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_quantize_requires_imatrix(enum ggml_type type)
     * }
     */
    public static FunctionDescriptor ggml_quantize_requires_imatrix$descriptor() {
        return ggml_quantize_requires_imatrix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_quantize_requires_imatrix(enum ggml_type type)
     * }
     */
    public static MethodHandle ggml_quantize_requires_imatrix$handle() {
        return ggml_quantize_requires_imatrix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_quantize_requires_imatrix(enum ggml_type type)
     * }
     */
    public static MemorySegment ggml_quantize_requires_imatrix$address() {
        return ggml_quantize_requires_imatrix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_quantize_requires_imatrix(enum ggml_type type)
     * }
     */
    public static boolean ggml_quantize_requires_imatrix(int type) {
        var mh$ = ggml_quantize_requires_imatrix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_quantize_requires_imatrix", type);
            }
            return (boolean)mh$.invokeExact(type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_quantize_chunk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_quantize_chunk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_quantize_chunk(enum ggml_type type, const float *src, void *dst, int64_t start, int64_t nrows, int64_t n_per_row, const float *imatrix)
     * }
     */
    public static FunctionDescriptor ggml_quantize_chunk$descriptor() {
        return ggml_quantize_chunk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_quantize_chunk(enum ggml_type type, const float *src, void *dst, int64_t start, int64_t nrows, int64_t n_per_row, const float *imatrix)
     * }
     */
    public static MethodHandle ggml_quantize_chunk$handle() {
        return ggml_quantize_chunk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_quantize_chunk(enum ggml_type type, const float *src, void *dst, int64_t start, int64_t nrows, int64_t n_per_row, const float *imatrix)
     * }
     */
    public static MemorySegment ggml_quantize_chunk$address() {
        return ggml_quantize_chunk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_quantize_chunk(enum ggml_type type, const float *src, void *dst, int64_t start, int64_t nrows, int64_t n_per_row, const float *imatrix)
     * }
     */
    public static long ggml_quantize_chunk(int type, MemorySegment src, MemorySegment dst, long start, long nrows, long n_per_row, MemorySegment imatrix) {
        var mh$ = ggml_quantize_chunk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_quantize_chunk", type, src, dst, start, nrows, n_per_row, imatrix);
            }
            return (long)mh$.invokeExact(type, src, dst, start, nrows, n_per_row, imatrix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_type_traits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_type_traits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const struct ggml_type_traits *ggml_get_type_traits(enum ggml_type type)
     * }
     */
    public static FunctionDescriptor ggml_get_type_traits$descriptor() {
        return ggml_get_type_traits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const struct ggml_type_traits *ggml_get_type_traits(enum ggml_type type)
     * }
     */
    public static MethodHandle ggml_get_type_traits$handle() {
        return ggml_get_type_traits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const struct ggml_type_traits *ggml_get_type_traits(enum ggml_type type)
     * }
     */
    public static MemorySegment ggml_get_type_traits$address() {
        return ggml_get_type_traits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const struct ggml_type_traits *ggml_get_type_traits(enum ggml_type type)
     * }
     */
    public static MemorySegment ggml_get_type_traits(int type) {
        var mh$ = ggml_get_type_traits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_type_traits", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GGML_SCHED_PRIO_LOW = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum ggml_sched_priority.GGML_SCHED_PRIO_LOW = -1
     * }
     */
    public static int GGML_SCHED_PRIO_LOW() {
        return GGML_SCHED_PRIO_LOW;
    }
    private static final int GGML_SCHED_PRIO_NORMAL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ggml_sched_priority.GGML_SCHED_PRIO_NORMAL = 0
     * }
     */
    public static int GGML_SCHED_PRIO_NORMAL() {
        return GGML_SCHED_PRIO_NORMAL;
    }
    private static final int GGML_SCHED_PRIO_MEDIUM = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ggml_sched_priority.GGML_SCHED_PRIO_MEDIUM = 1
     * }
     */
    public static int GGML_SCHED_PRIO_MEDIUM() {
        return GGML_SCHED_PRIO_MEDIUM;
    }
    private static final int GGML_SCHED_PRIO_HIGH = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ggml_sched_priority.GGML_SCHED_PRIO_HIGH = 2
     * }
     */
    public static int GGML_SCHED_PRIO_HIGH() {
        return GGML_SCHED_PRIO_HIGH;
    }
    private static final int GGML_SCHED_PRIO_REALTIME = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ggml_sched_priority.GGML_SCHED_PRIO_REALTIME = 3
     * }
     */
    public static int GGML_SCHED_PRIO_REALTIME() {
        return GGML_SCHED_PRIO_REALTIME;
    }
    /**
     * {@snippet lang=c :
     * typedef struct ggml_threadpool *ggml_threadpool_t
     * }
     */
    public static final AddressLayout ggml_threadpool_t = WhisperCpp.C_POINTER;

    private static class ggml_threadpool_params_default {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ggml_threadpool_params.layout(),
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_threadpool_params_default");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_threadpool_params ggml_threadpool_params_default(int n_threads)
     * }
     */
    public static FunctionDescriptor ggml_threadpool_params_default$descriptor() {
        return ggml_threadpool_params_default.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_threadpool_params ggml_threadpool_params_default(int n_threads)
     * }
     */
    public static MethodHandle ggml_threadpool_params_default$handle() {
        return ggml_threadpool_params_default.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_threadpool_params ggml_threadpool_params_default(int n_threads)
     * }
     */
    public static MemorySegment ggml_threadpool_params_default$address() {
        return ggml_threadpool_params_default.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_threadpool_params ggml_threadpool_params_default(int n_threads)
     * }
     */
    public static MemorySegment ggml_threadpool_params_default(SegmentAllocator allocator, int n_threads) {
        var mh$ = ggml_threadpool_params_default.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_threadpool_params_default", allocator, n_threads);
            }
            return (MemorySegment)mh$.invokeExact(allocator, n_threads);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_threadpool_params_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_threadpool_params_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_threadpool_params_init(struct ggml_threadpool_params *p, int n_threads)
     * }
     */
    public static FunctionDescriptor ggml_threadpool_params_init$descriptor() {
        return ggml_threadpool_params_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_threadpool_params_init(struct ggml_threadpool_params *p, int n_threads)
     * }
     */
    public static MethodHandle ggml_threadpool_params_init$handle() {
        return ggml_threadpool_params_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_threadpool_params_init(struct ggml_threadpool_params *p, int n_threads)
     * }
     */
    public static MemorySegment ggml_threadpool_params_init$address() {
        return ggml_threadpool_params_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_threadpool_params_init(struct ggml_threadpool_params *p, int n_threads)
     * }
     */
    public static void ggml_threadpool_params_init(MemorySegment p, int n_threads) {
        var mh$ = ggml_threadpool_params_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_threadpool_params_init", p, n_threads);
            }
            mh$.invokeExact(p, n_threads);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_threadpool_params_match {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_threadpool_params_match");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_threadpool_params_match(const struct ggml_threadpool_params *p0, const struct ggml_threadpool_params *p1)
     * }
     */
    public static FunctionDescriptor ggml_threadpool_params_match$descriptor() {
        return ggml_threadpool_params_match.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_threadpool_params_match(const struct ggml_threadpool_params *p0, const struct ggml_threadpool_params *p1)
     * }
     */
    public static MethodHandle ggml_threadpool_params_match$handle() {
        return ggml_threadpool_params_match.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_threadpool_params_match(const struct ggml_threadpool_params *p0, const struct ggml_threadpool_params *p1)
     * }
     */
    public static MemorySegment ggml_threadpool_params_match$address() {
        return ggml_threadpool_params_match.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_threadpool_params_match(const struct ggml_threadpool_params *p0, const struct ggml_threadpool_params *p1)
     * }
     */
    public static boolean ggml_threadpool_params_match(MemorySegment p0, MemorySegment p1) {
        var mh$ = ggml_threadpool_params_match.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_threadpool_params_match", p0, p1);
            }
            return (boolean)mh$.invokeExact(p0, p1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct ggml_backend_buffer_type *ggml_backend_buffer_type_t
     * }
     */
    public static final AddressLayout ggml_backend_buffer_type_t = WhisperCpp.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct ggml_backend_buffer *ggml_backend_buffer_t
     * }
     */
    public static final AddressLayout ggml_backend_buffer_t = WhisperCpp.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct ggml_backend *ggml_backend_t
     * }
     */
    public static final AddressLayout ggml_backend_t = WhisperCpp.C_POINTER;

    private static class ggml_tallocr_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ggml_tallocr.layout(),
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_tallocr_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tallocr ggml_tallocr_new(ggml_backend_buffer_t buffer)
     * }
     */
    public static FunctionDescriptor ggml_tallocr_new$descriptor() {
        return ggml_tallocr_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tallocr ggml_tallocr_new(ggml_backend_buffer_t buffer)
     * }
     */
    public static MethodHandle ggml_tallocr_new$handle() {
        return ggml_tallocr_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tallocr ggml_tallocr_new(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_tallocr_new$address() {
        return ggml_tallocr_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tallocr ggml_tallocr_new(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_tallocr_new(SegmentAllocator allocator, MemorySegment buffer) {
        var mh$ = ggml_tallocr_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_tallocr_new", allocator, buffer);
            }
            return (MemorySegment)mh$.invokeExact(allocator, buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_tallocr_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_tallocr_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_tallocr_alloc(struct ggml_tallocr *talloc, struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_tallocr_alloc$descriptor() {
        return ggml_tallocr_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_tallocr_alloc(struct ggml_tallocr *talloc, struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_tallocr_alloc$handle() {
        return ggml_tallocr_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_tallocr_alloc(struct ggml_tallocr *talloc, struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_tallocr_alloc$address() {
        return ggml_tallocr_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_status ggml_tallocr_alloc(struct ggml_tallocr *talloc, struct ggml_tensor *tensor)
     * }
     */
    public static int ggml_tallocr_alloc(MemorySegment talloc, MemorySegment tensor) {
        var mh$ = ggml_tallocr_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_tallocr_alloc", talloc, tensor);
            }
            return (int)mh$.invokeExact(talloc, tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct ggml_gallocr *ggml_gallocr_t
     * }
     */
    public static final AddressLayout ggml_gallocr_t = WhisperCpp.C_POINTER;

    private static class ggml_gallocr_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_gallocr_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_gallocr_t ggml_gallocr_new(ggml_backend_buffer_type_t buft)
     * }
     */
    public static FunctionDescriptor ggml_gallocr_new$descriptor() {
        return ggml_gallocr_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_gallocr_t ggml_gallocr_new(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MethodHandle ggml_gallocr_new$handle() {
        return ggml_gallocr_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_gallocr_t ggml_gallocr_new(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MemorySegment ggml_gallocr_new$address() {
        return ggml_gallocr_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_gallocr_t ggml_gallocr_new(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MemorySegment ggml_gallocr_new(MemorySegment buft) {
        var mh$ = ggml_gallocr_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_gallocr_new", buft);
            }
            return (MemorySegment)mh$.invokeExact(buft);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_gallocr_new_n {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_gallocr_new_n");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_gallocr_t ggml_gallocr_new_n(ggml_backend_buffer_type_t *bufts, int n_bufs)
     * }
     */
    public static FunctionDescriptor ggml_gallocr_new_n$descriptor() {
        return ggml_gallocr_new_n.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_gallocr_t ggml_gallocr_new_n(ggml_backend_buffer_type_t *bufts, int n_bufs)
     * }
     */
    public static MethodHandle ggml_gallocr_new_n$handle() {
        return ggml_gallocr_new_n.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_gallocr_t ggml_gallocr_new_n(ggml_backend_buffer_type_t *bufts, int n_bufs)
     * }
     */
    public static MemorySegment ggml_gallocr_new_n$address() {
        return ggml_gallocr_new_n.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_gallocr_t ggml_gallocr_new_n(ggml_backend_buffer_type_t *bufts, int n_bufs)
     * }
     */
    public static MemorySegment ggml_gallocr_new_n(MemorySegment bufts, int n_bufs) {
        var mh$ = ggml_gallocr_new_n.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_gallocr_new_n", bufts, n_bufs);
            }
            return (MemorySegment)mh$.invokeExact(bufts, n_bufs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_gallocr_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_gallocr_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_gallocr_free(ggml_gallocr_t galloc)
     * }
     */
    public static FunctionDescriptor ggml_gallocr_free$descriptor() {
        return ggml_gallocr_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_gallocr_free(ggml_gallocr_t galloc)
     * }
     */
    public static MethodHandle ggml_gallocr_free$handle() {
        return ggml_gallocr_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_gallocr_free(ggml_gallocr_t galloc)
     * }
     */
    public static MemorySegment ggml_gallocr_free$address() {
        return ggml_gallocr_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_gallocr_free(ggml_gallocr_t galloc)
     * }
     */
    public static void ggml_gallocr_free(MemorySegment galloc) {
        var mh$ = ggml_gallocr_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_gallocr_free", galloc);
            }
            mh$.invokeExact(galloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_gallocr_reserve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_gallocr_reserve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_gallocr_reserve(ggml_gallocr_t galloc, struct ggml_cgraph *graph)
     * }
     */
    public static FunctionDescriptor ggml_gallocr_reserve$descriptor() {
        return ggml_gallocr_reserve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_gallocr_reserve(ggml_gallocr_t galloc, struct ggml_cgraph *graph)
     * }
     */
    public static MethodHandle ggml_gallocr_reserve$handle() {
        return ggml_gallocr_reserve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_gallocr_reserve(ggml_gallocr_t galloc, struct ggml_cgraph *graph)
     * }
     */
    public static MemorySegment ggml_gallocr_reserve$address() {
        return ggml_gallocr_reserve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_gallocr_reserve(ggml_gallocr_t galloc, struct ggml_cgraph *graph)
     * }
     */
    public static boolean ggml_gallocr_reserve(MemorySegment galloc, MemorySegment graph) {
        var mh$ = ggml_gallocr_reserve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_gallocr_reserve", galloc, graph);
            }
            return (boolean)mh$.invokeExact(galloc, graph);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_gallocr_reserve_n {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_gallocr_reserve_n");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_gallocr_reserve_n(ggml_gallocr_t galloc, struct ggml_cgraph *graph, const int *node_buffer_ids, const int *leaf_buffer_ids)
     * }
     */
    public static FunctionDescriptor ggml_gallocr_reserve_n$descriptor() {
        return ggml_gallocr_reserve_n.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_gallocr_reserve_n(ggml_gallocr_t galloc, struct ggml_cgraph *graph, const int *node_buffer_ids, const int *leaf_buffer_ids)
     * }
     */
    public static MethodHandle ggml_gallocr_reserve_n$handle() {
        return ggml_gallocr_reserve_n.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_gallocr_reserve_n(ggml_gallocr_t galloc, struct ggml_cgraph *graph, const int *node_buffer_ids, const int *leaf_buffer_ids)
     * }
     */
    public static MemorySegment ggml_gallocr_reserve_n$address() {
        return ggml_gallocr_reserve_n.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_gallocr_reserve_n(ggml_gallocr_t galloc, struct ggml_cgraph *graph, const int *node_buffer_ids, const int *leaf_buffer_ids)
     * }
     */
    public static boolean ggml_gallocr_reserve_n(MemorySegment galloc, MemorySegment graph, MemorySegment node_buffer_ids, MemorySegment leaf_buffer_ids) {
        var mh$ = ggml_gallocr_reserve_n.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_gallocr_reserve_n", galloc, graph, node_buffer_ids, leaf_buffer_ids);
            }
            return (boolean)mh$.invokeExact(galloc, graph, node_buffer_ids, leaf_buffer_ids);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_gallocr_alloc_graph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_gallocr_alloc_graph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_gallocr_alloc_graph(ggml_gallocr_t galloc, struct ggml_cgraph *graph)
     * }
     */
    public static FunctionDescriptor ggml_gallocr_alloc_graph$descriptor() {
        return ggml_gallocr_alloc_graph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_gallocr_alloc_graph(ggml_gallocr_t galloc, struct ggml_cgraph *graph)
     * }
     */
    public static MethodHandle ggml_gallocr_alloc_graph$handle() {
        return ggml_gallocr_alloc_graph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_gallocr_alloc_graph(ggml_gallocr_t galloc, struct ggml_cgraph *graph)
     * }
     */
    public static MemorySegment ggml_gallocr_alloc_graph$address() {
        return ggml_gallocr_alloc_graph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_gallocr_alloc_graph(ggml_gallocr_t galloc, struct ggml_cgraph *graph)
     * }
     */
    public static boolean ggml_gallocr_alloc_graph(MemorySegment galloc, MemorySegment graph) {
        var mh$ = ggml_gallocr_alloc_graph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_gallocr_alloc_graph", galloc, graph);
            }
            return (boolean)mh$.invokeExact(galloc, graph);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_gallocr_get_buffer_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_gallocr_get_buffer_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_gallocr_get_buffer_size(ggml_gallocr_t galloc, int buffer_id)
     * }
     */
    public static FunctionDescriptor ggml_gallocr_get_buffer_size$descriptor() {
        return ggml_gallocr_get_buffer_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_gallocr_get_buffer_size(ggml_gallocr_t galloc, int buffer_id)
     * }
     */
    public static MethodHandle ggml_gallocr_get_buffer_size$handle() {
        return ggml_gallocr_get_buffer_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_gallocr_get_buffer_size(ggml_gallocr_t galloc, int buffer_id)
     * }
     */
    public static MemorySegment ggml_gallocr_get_buffer_size$address() {
        return ggml_gallocr_get_buffer_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_gallocr_get_buffer_size(ggml_gallocr_t galloc, int buffer_id)
     * }
     */
    public static long ggml_gallocr_get_buffer_size(MemorySegment galloc, int buffer_id) {
        var mh$ = ggml_gallocr_get_buffer_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_gallocr_get_buffer_size", galloc, buffer_id);
            }
            return (long)mh$.invokeExact(galloc, buffer_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_alloc_ctx_tensors_from_buft {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_alloc_ctx_tensors_from_buft");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_backend_buffer *ggml_backend_alloc_ctx_tensors_from_buft(struct ggml_context *ctx, ggml_backend_buffer_type_t buft)
     * }
     */
    public static FunctionDescriptor ggml_backend_alloc_ctx_tensors_from_buft$descriptor() {
        return ggml_backend_alloc_ctx_tensors_from_buft.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_backend_buffer *ggml_backend_alloc_ctx_tensors_from_buft(struct ggml_context *ctx, ggml_backend_buffer_type_t buft)
     * }
     */
    public static MethodHandle ggml_backend_alloc_ctx_tensors_from_buft$handle() {
        return ggml_backend_alloc_ctx_tensors_from_buft.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_backend_buffer *ggml_backend_alloc_ctx_tensors_from_buft(struct ggml_context *ctx, ggml_backend_buffer_type_t buft)
     * }
     */
    public static MemorySegment ggml_backend_alloc_ctx_tensors_from_buft$address() {
        return ggml_backend_alloc_ctx_tensors_from_buft.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_backend_buffer *ggml_backend_alloc_ctx_tensors_from_buft(struct ggml_context *ctx, ggml_backend_buffer_type_t buft)
     * }
     */
    public static MemorySegment ggml_backend_alloc_ctx_tensors_from_buft(MemorySegment ctx, MemorySegment buft) {
        var mh$ = ggml_backend_alloc_ctx_tensors_from_buft.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_alloc_ctx_tensors_from_buft", ctx, buft);
            }
            return (MemorySegment)mh$.invokeExact(ctx, buft);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_alloc_ctx_tensors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_alloc_ctx_tensors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_backend_buffer *ggml_backend_alloc_ctx_tensors(struct ggml_context *ctx, ggml_backend_t backend)
     * }
     */
    public static FunctionDescriptor ggml_backend_alloc_ctx_tensors$descriptor() {
        return ggml_backend_alloc_ctx_tensors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_backend_buffer *ggml_backend_alloc_ctx_tensors(struct ggml_context *ctx, ggml_backend_t backend)
     * }
     */
    public static MethodHandle ggml_backend_alloc_ctx_tensors$handle() {
        return ggml_backend_alloc_ctx_tensors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_backend_buffer *ggml_backend_alloc_ctx_tensors(struct ggml_context *ctx, ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_alloc_ctx_tensors$address() {
        return ggml_backend_alloc_ctx_tensors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_backend_buffer *ggml_backend_alloc_ctx_tensors(struct ggml_context *ctx, ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_alloc_ctx_tensors(MemorySegment ctx, MemorySegment backend) {
        var mh$ = ggml_backend_alloc_ctx_tensors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_alloc_ctx_tensors", ctx, backend);
            }
            return (MemorySegment)mh$.invokeExact(ctx, backend);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct ggml_backend_event *ggml_backend_event_t
     * }
     */
    public static final AddressLayout ggml_backend_event_t = WhisperCpp.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef void *ggml_backend_graph_plan_t
     * }
     */
    public static final AddressLayout ggml_backend_graph_plan_t = WhisperCpp.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct ggml_backend_reg *ggml_backend_reg_t
     * }
     */
    public static final AddressLayout ggml_backend_reg_t = WhisperCpp.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct ggml_backend_device *ggml_backend_dev_t
     * }
     */
    public static final AddressLayout ggml_backend_dev_t = WhisperCpp.C_POINTER;

    private static class ggml_backend_buft_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buft_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_buft_name(ggml_backend_buffer_type_t buft)
     * }
     */
    public static FunctionDescriptor ggml_backend_buft_name$descriptor() {
        return ggml_backend_buft_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_buft_name(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MethodHandle ggml_backend_buft_name$handle() {
        return ggml_backend_buft_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_buft_name(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MemorySegment ggml_backend_buft_name$address() {
        return ggml_backend_buft_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ggml_backend_buft_name(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MemorySegment ggml_backend_buft_name(MemorySegment buft) {
        var mh$ = ggml_backend_buft_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buft_name", buft);
            }
            return (MemorySegment)mh$.invokeExact(buft);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buft_alloc_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buft_alloc_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_buft_alloc_buffer(ggml_backend_buffer_type_t buft, size_t size)
     * }
     */
    public static FunctionDescriptor ggml_backend_buft_alloc_buffer$descriptor() {
        return ggml_backend_buft_alloc_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_buft_alloc_buffer(ggml_backend_buffer_type_t buft, size_t size)
     * }
     */
    public static MethodHandle ggml_backend_buft_alloc_buffer$handle() {
        return ggml_backend_buft_alloc_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_buft_alloc_buffer(ggml_backend_buffer_type_t buft, size_t size)
     * }
     */
    public static MemorySegment ggml_backend_buft_alloc_buffer$address() {
        return ggml_backend_buft_alloc_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_buft_alloc_buffer(ggml_backend_buffer_type_t buft, size_t size)
     * }
     */
    public static MemorySegment ggml_backend_buft_alloc_buffer(MemorySegment buft, long size) {
        var mh$ = ggml_backend_buft_alloc_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buft_alloc_buffer", buft, size);
            }
            return (MemorySegment)mh$.invokeExact(buft, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buft_get_alignment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buft_get_alignment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buft_get_alignment(ggml_backend_buffer_type_t buft)
     * }
     */
    public static FunctionDescriptor ggml_backend_buft_get_alignment$descriptor() {
        return ggml_backend_buft_get_alignment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buft_get_alignment(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MethodHandle ggml_backend_buft_get_alignment$handle() {
        return ggml_backend_buft_get_alignment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buft_get_alignment(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MemorySegment ggml_backend_buft_get_alignment$address() {
        return ggml_backend_buft_get_alignment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_backend_buft_get_alignment(ggml_backend_buffer_type_t buft)
     * }
     */
    public static long ggml_backend_buft_get_alignment(MemorySegment buft) {
        var mh$ = ggml_backend_buft_get_alignment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buft_get_alignment", buft);
            }
            return (long)mh$.invokeExact(buft);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buft_get_max_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buft_get_max_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buft_get_max_size(ggml_backend_buffer_type_t buft)
     * }
     */
    public static FunctionDescriptor ggml_backend_buft_get_max_size$descriptor() {
        return ggml_backend_buft_get_max_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buft_get_max_size(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MethodHandle ggml_backend_buft_get_max_size$handle() {
        return ggml_backend_buft_get_max_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buft_get_max_size(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MemorySegment ggml_backend_buft_get_max_size$address() {
        return ggml_backend_buft_get_max_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_backend_buft_get_max_size(ggml_backend_buffer_type_t buft)
     * }
     */
    public static long ggml_backend_buft_get_max_size(MemorySegment buft) {
        var mh$ = ggml_backend_buft_get_max_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buft_get_max_size", buft);
            }
            return (long)mh$.invokeExact(buft);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buft_get_alloc_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buft_get_alloc_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buft_get_alloc_size(ggml_backend_buffer_type_t buft, const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_backend_buft_get_alloc_size$descriptor() {
        return ggml_backend_buft_get_alloc_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buft_get_alloc_size(ggml_backend_buffer_type_t buft, const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_backend_buft_get_alloc_size$handle() {
        return ggml_backend_buft_get_alloc_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buft_get_alloc_size(ggml_backend_buffer_type_t buft, const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_backend_buft_get_alloc_size$address() {
        return ggml_backend_buft_get_alloc_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_backend_buft_get_alloc_size(ggml_backend_buffer_type_t buft, const struct ggml_tensor *tensor)
     * }
     */
    public static long ggml_backend_buft_get_alloc_size(MemorySegment buft, MemorySegment tensor) {
        var mh$ = ggml_backend_buft_get_alloc_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buft_get_alloc_size", buft, tensor);
            }
            return (long)mh$.invokeExact(buft, tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buft_is_host {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buft_is_host");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_backend_buft_is_host(ggml_backend_buffer_type_t buft)
     * }
     */
    public static FunctionDescriptor ggml_backend_buft_is_host$descriptor() {
        return ggml_backend_buft_is_host.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_backend_buft_is_host(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MethodHandle ggml_backend_buft_is_host$handle() {
        return ggml_backend_buft_is_host.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_backend_buft_is_host(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MemorySegment ggml_backend_buft_is_host$address() {
        return ggml_backend_buft_is_host.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_backend_buft_is_host(ggml_backend_buffer_type_t buft)
     * }
     */
    public static boolean ggml_backend_buft_is_host(MemorySegment buft) {
        var mh$ = ggml_backend_buft_is_host.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buft_is_host", buft);
            }
            return (boolean)mh$.invokeExact(buft);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buft_get_device {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buft_get_device");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_buft_get_device(ggml_backend_buffer_type_t buft)
     * }
     */
    public static FunctionDescriptor ggml_backend_buft_get_device$descriptor() {
        return ggml_backend_buft_get_device.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_buft_get_device(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MethodHandle ggml_backend_buft_get_device$handle() {
        return ggml_backend_buft_get_device.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_buft_get_device(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MemorySegment ggml_backend_buft_get_device$address() {
        return ggml_backend_buft_get_device.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_buft_get_device(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MemorySegment ggml_backend_buft_get_device(MemorySegment buft) {
        var mh$ = ggml_backend_buft_get_device.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buft_get_device", buft);
            }
            return (MemorySegment)mh$.invokeExact(buft);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GGML_BACKEND_BUFFER_USAGE_ANY = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ggml_backend_buffer_usage.GGML_BACKEND_BUFFER_USAGE_ANY = 0
     * }
     */
    public static int GGML_BACKEND_BUFFER_USAGE_ANY() {
        return GGML_BACKEND_BUFFER_USAGE_ANY;
    }
    private static final int GGML_BACKEND_BUFFER_USAGE_WEIGHTS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ggml_backend_buffer_usage.GGML_BACKEND_BUFFER_USAGE_WEIGHTS = 1
     * }
     */
    public static int GGML_BACKEND_BUFFER_USAGE_WEIGHTS() {
        return GGML_BACKEND_BUFFER_USAGE_WEIGHTS;
    }
    private static final int GGML_BACKEND_BUFFER_USAGE_COMPUTE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ggml_backend_buffer_usage.GGML_BACKEND_BUFFER_USAGE_COMPUTE = 2
     * }
     */
    public static int GGML_BACKEND_BUFFER_USAGE_COMPUTE() {
        return GGML_BACKEND_BUFFER_USAGE_COMPUTE;
    }

    private static class ggml_backend_buffer_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buffer_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_buffer_name(ggml_backend_buffer_t buffer)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_name$descriptor() {
        return ggml_backend_buffer_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_buffer_name(ggml_backend_buffer_t buffer)
     * }
     */
    public static MethodHandle ggml_backend_buffer_name$handle() {
        return ggml_backend_buffer_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_buffer_name(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_backend_buffer_name$address() {
        return ggml_backend_buffer_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ggml_backend_buffer_name(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_backend_buffer_name(MemorySegment buffer) {
        var mh$ = ggml_backend_buffer_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_name", buffer);
            }
            return (MemorySegment)mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buffer_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buffer_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_free(ggml_backend_buffer_t buffer)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_free$descriptor() {
        return ggml_backend_buffer_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_free(ggml_backend_buffer_t buffer)
     * }
     */
    public static MethodHandle ggml_backend_buffer_free$handle() {
        return ggml_backend_buffer_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_free(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_backend_buffer_free$address() {
        return ggml_backend_buffer_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_free(ggml_backend_buffer_t buffer)
     * }
     */
    public static void ggml_backend_buffer_free(MemorySegment buffer) {
        var mh$ = ggml_backend_buffer_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_free", buffer);
            }
            mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buffer_get_base {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buffer_get_base");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *ggml_backend_buffer_get_base(ggml_backend_buffer_t buffer)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_get_base$descriptor() {
        return ggml_backend_buffer_get_base.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *ggml_backend_buffer_get_base(ggml_backend_buffer_t buffer)
     * }
     */
    public static MethodHandle ggml_backend_buffer_get_base$handle() {
        return ggml_backend_buffer_get_base.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *ggml_backend_buffer_get_base(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_backend_buffer_get_base$address() {
        return ggml_backend_buffer_get_base.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *ggml_backend_buffer_get_base(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_backend_buffer_get_base(MemorySegment buffer) {
        var mh$ = ggml_backend_buffer_get_base.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_get_base", buffer);
            }
            return (MemorySegment)mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buffer_get_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buffer_get_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_size(ggml_backend_buffer_t buffer)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_get_size$descriptor() {
        return ggml_backend_buffer_get_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_size(ggml_backend_buffer_t buffer)
     * }
     */
    public static MethodHandle ggml_backend_buffer_get_size$handle() {
        return ggml_backend_buffer_get_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_size(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_backend_buffer_get_size$address() {
        return ggml_backend_buffer_get_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_size(ggml_backend_buffer_t buffer)
     * }
     */
    public static long ggml_backend_buffer_get_size(MemorySegment buffer) {
        var mh$ = ggml_backend_buffer_get_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_get_size", buffer);
            }
            return (long)mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buffer_init_tensor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buffer_init_tensor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_buffer_init_tensor(ggml_backend_buffer_t buffer, struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_init_tensor$descriptor() {
        return ggml_backend_buffer_init_tensor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_buffer_init_tensor(ggml_backend_buffer_t buffer, struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_backend_buffer_init_tensor$handle() {
        return ggml_backend_buffer_init_tensor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_buffer_init_tensor(ggml_backend_buffer_t buffer, struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_backend_buffer_init_tensor$address() {
        return ggml_backend_buffer_init_tensor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_buffer_init_tensor(ggml_backend_buffer_t buffer, struct ggml_tensor *tensor)
     * }
     */
    public static int ggml_backend_buffer_init_tensor(MemorySegment buffer, MemorySegment tensor) {
        var mh$ = ggml_backend_buffer_init_tensor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_init_tensor", buffer, tensor);
            }
            return (int)mh$.invokeExact(buffer, tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buffer_get_alignment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buffer_get_alignment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_alignment(ggml_backend_buffer_t buffer)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_get_alignment$descriptor() {
        return ggml_backend_buffer_get_alignment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_alignment(ggml_backend_buffer_t buffer)
     * }
     */
    public static MethodHandle ggml_backend_buffer_get_alignment$handle() {
        return ggml_backend_buffer_get_alignment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_alignment(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_backend_buffer_get_alignment$address() {
        return ggml_backend_buffer_get_alignment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_alignment(ggml_backend_buffer_t buffer)
     * }
     */
    public static long ggml_backend_buffer_get_alignment(MemorySegment buffer) {
        var mh$ = ggml_backend_buffer_get_alignment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_get_alignment", buffer);
            }
            return (long)mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buffer_get_max_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buffer_get_max_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_max_size(ggml_backend_buffer_t buffer)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_get_max_size$descriptor() {
        return ggml_backend_buffer_get_max_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_max_size(ggml_backend_buffer_t buffer)
     * }
     */
    public static MethodHandle ggml_backend_buffer_get_max_size$handle() {
        return ggml_backend_buffer_get_max_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_max_size(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_backend_buffer_get_max_size$address() {
        return ggml_backend_buffer_get_max_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_max_size(ggml_backend_buffer_t buffer)
     * }
     */
    public static long ggml_backend_buffer_get_max_size(MemorySegment buffer) {
        var mh$ = ggml_backend_buffer_get_max_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_get_max_size", buffer);
            }
            return (long)mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buffer_get_alloc_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buffer_get_alloc_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_alloc_size(ggml_backend_buffer_t buffer, const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_get_alloc_size$descriptor() {
        return ggml_backend_buffer_get_alloc_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_alloc_size(ggml_backend_buffer_t buffer, const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_backend_buffer_get_alloc_size$handle() {
        return ggml_backend_buffer_get_alloc_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_alloc_size(ggml_backend_buffer_t buffer, const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_backend_buffer_get_alloc_size$address() {
        return ggml_backend_buffer_get_alloc_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_alloc_size(ggml_backend_buffer_t buffer, const struct ggml_tensor *tensor)
     * }
     */
    public static long ggml_backend_buffer_get_alloc_size(MemorySegment buffer, MemorySegment tensor) {
        var mh$ = ggml_backend_buffer_get_alloc_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_get_alloc_size", buffer, tensor);
            }
            return (long)mh$.invokeExact(buffer, tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buffer_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_CHAR
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buffer_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_clear(ggml_backend_buffer_t buffer, uint8_t value)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_clear$descriptor() {
        return ggml_backend_buffer_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_clear(ggml_backend_buffer_t buffer, uint8_t value)
     * }
     */
    public static MethodHandle ggml_backend_buffer_clear$handle() {
        return ggml_backend_buffer_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_clear(ggml_backend_buffer_t buffer, uint8_t value)
     * }
     */
    public static MemorySegment ggml_backend_buffer_clear$address() {
        return ggml_backend_buffer_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_clear(ggml_backend_buffer_t buffer, uint8_t value)
     * }
     */
    public static void ggml_backend_buffer_clear(MemorySegment buffer, byte value) {
        var mh$ = ggml_backend_buffer_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_clear", buffer, value);
            }
            mh$.invokeExact(buffer, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buffer_is_host {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buffer_is_host");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_backend_buffer_is_host(ggml_backend_buffer_t buffer)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_is_host$descriptor() {
        return ggml_backend_buffer_is_host.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_backend_buffer_is_host(ggml_backend_buffer_t buffer)
     * }
     */
    public static MethodHandle ggml_backend_buffer_is_host$handle() {
        return ggml_backend_buffer_is_host.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_backend_buffer_is_host(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_backend_buffer_is_host$address() {
        return ggml_backend_buffer_is_host.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_backend_buffer_is_host(ggml_backend_buffer_t buffer)
     * }
     */
    public static boolean ggml_backend_buffer_is_host(MemorySegment buffer) {
        var mh$ = ggml_backend_buffer_is_host.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_is_host", buffer);
            }
            return (boolean)mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buffer_set_usage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buffer_set_usage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_set_usage(ggml_backend_buffer_t buffer, enum ggml_backend_buffer_usage usage)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_set_usage$descriptor() {
        return ggml_backend_buffer_set_usage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_set_usage(ggml_backend_buffer_t buffer, enum ggml_backend_buffer_usage usage)
     * }
     */
    public static MethodHandle ggml_backend_buffer_set_usage$handle() {
        return ggml_backend_buffer_set_usage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_set_usage(ggml_backend_buffer_t buffer, enum ggml_backend_buffer_usage usage)
     * }
     */
    public static MemorySegment ggml_backend_buffer_set_usage$address() {
        return ggml_backend_buffer_set_usage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_set_usage(ggml_backend_buffer_t buffer, enum ggml_backend_buffer_usage usage)
     * }
     */
    public static void ggml_backend_buffer_set_usage(MemorySegment buffer, int usage) {
        var mh$ = ggml_backend_buffer_set_usage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_set_usage", buffer, usage);
            }
            mh$.invokeExact(buffer, usage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buffer_get_usage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buffer_get_usage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_backend_buffer_usage ggml_backend_buffer_get_usage(ggml_backend_buffer_t buffer)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_get_usage$descriptor() {
        return ggml_backend_buffer_get_usage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_backend_buffer_usage ggml_backend_buffer_get_usage(ggml_backend_buffer_t buffer)
     * }
     */
    public static MethodHandle ggml_backend_buffer_get_usage$handle() {
        return ggml_backend_buffer_get_usage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_backend_buffer_usage ggml_backend_buffer_get_usage(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_backend_buffer_get_usage$address() {
        return ggml_backend_buffer_get_usage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_backend_buffer_usage ggml_backend_buffer_get_usage(ggml_backend_buffer_t buffer)
     * }
     */
    public static int ggml_backend_buffer_get_usage(MemorySegment buffer) {
        var mh$ = ggml_backend_buffer_get_usage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_get_usage", buffer);
            }
            return (int)mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buffer_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buffer_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_buffer_get_type(ggml_backend_buffer_t buffer)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_get_type$descriptor() {
        return ggml_backend_buffer_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_buffer_get_type(ggml_backend_buffer_t buffer)
     * }
     */
    public static MethodHandle ggml_backend_buffer_get_type$handle() {
        return ggml_backend_buffer_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_buffer_get_type(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_backend_buffer_get_type$address() {
        return ggml_backend_buffer_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_buffer_get_type(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_backend_buffer_get_type(MemorySegment buffer) {
        var mh$ = ggml_backend_buffer_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_get_type", buffer);
            }
            return (MemorySegment)mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buffer_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buffer_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_reset(ggml_backend_buffer_t buffer)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_reset$descriptor() {
        return ggml_backend_buffer_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_reset(ggml_backend_buffer_t buffer)
     * }
     */
    public static MethodHandle ggml_backend_buffer_reset$handle() {
        return ggml_backend_buffer_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_reset(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_backend_buffer_reset$address() {
        return ggml_backend_buffer_reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_reset(ggml_backend_buffer_t buffer)
     * }
     */
    public static void ggml_backend_buffer_reset(MemorySegment buffer) {
        var mh$ = ggml_backend_buffer_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_reset", buffer);
            }
            mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_tensor_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_tensor_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_copy(struct ggml_tensor *src, struct ggml_tensor *dst)
     * }
     */
    public static FunctionDescriptor ggml_backend_tensor_copy$descriptor() {
        return ggml_backend_tensor_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_copy(struct ggml_tensor *src, struct ggml_tensor *dst)
     * }
     */
    public static MethodHandle ggml_backend_tensor_copy$handle() {
        return ggml_backend_tensor_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_copy(struct ggml_tensor *src, struct ggml_tensor *dst)
     * }
     */
    public static MemorySegment ggml_backend_tensor_copy$address() {
        return ggml_backend_tensor_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_copy(struct ggml_tensor *src, struct ggml_tensor *dst)
     * }
     */
    public static void ggml_backend_tensor_copy(MemorySegment src, MemorySegment dst) {
        var mh$ = ggml_backend_tensor_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_tensor_copy", src, dst);
            }
            mh$.invokeExact(src, dst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_guid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_guid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_guid_t ggml_backend_guid(ggml_backend_t backend)
     * }
     */
    public static FunctionDescriptor ggml_backend_guid$descriptor() {
        return ggml_backend_guid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_guid_t ggml_backend_guid(ggml_backend_t backend)
     * }
     */
    public static MethodHandle ggml_backend_guid$handle() {
        return ggml_backend_guid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_guid_t ggml_backend_guid(ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_guid$address() {
        return ggml_backend_guid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_guid_t ggml_backend_guid(ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_guid(MemorySegment backend) {
        var mh$ = ggml_backend_guid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_guid", backend);
            }
            return (MemorySegment)mh$.invokeExact(backend);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_name(ggml_backend_t backend)
     * }
     */
    public static FunctionDescriptor ggml_backend_name$descriptor() {
        return ggml_backend_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_name(ggml_backend_t backend)
     * }
     */
    public static MethodHandle ggml_backend_name$handle() {
        return ggml_backend_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_name(ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_name$address() {
        return ggml_backend_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ggml_backend_name(ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_name(MemorySegment backend) {
        var mh$ = ggml_backend_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_name", backend);
            }
            return (MemorySegment)mh$.invokeExact(backend);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_free(ggml_backend_t backend)
     * }
     */
    public static FunctionDescriptor ggml_backend_free$descriptor() {
        return ggml_backend_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_free(ggml_backend_t backend)
     * }
     */
    public static MethodHandle ggml_backend_free$handle() {
        return ggml_backend_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_free(ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_free$address() {
        return ggml_backend_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_free(ggml_backend_t backend)
     * }
     */
    public static void ggml_backend_free(MemorySegment backend) {
        var mh$ = ggml_backend_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_free", backend);
            }
            mh$.invokeExact(backend);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_get_default_buffer_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_get_default_buffer_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_get_default_buffer_type(ggml_backend_t backend)
     * }
     */
    public static FunctionDescriptor ggml_backend_get_default_buffer_type$descriptor() {
        return ggml_backend_get_default_buffer_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_get_default_buffer_type(ggml_backend_t backend)
     * }
     */
    public static MethodHandle ggml_backend_get_default_buffer_type$handle() {
        return ggml_backend_get_default_buffer_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_get_default_buffer_type(ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_get_default_buffer_type$address() {
        return ggml_backend_get_default_buffer_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_get_default_buffer_type(ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_get_default_buffer_type(MemorySegment backend) {
        var mh$ = ggml_backend_get_default_buffer_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_get_default_buffer_type", backend);
            }
            return (MemorySegment)mh$.invokeExact(backend);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_alloc_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_alloc_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_alloc_buffer(ggml_backend_t backend, size_t size)
     * }
     */
    public static FunctionDescriptor ggml_backend_alloc_buffer$descriptor() {
        return ggml_backend_alloc_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_alloc_buffer(ggml_backend_t backend, size_t size)
     * }
     */
    public static MethodHandle ggml_backend_alloc_buffer$handle() {
        return ggml_backend_alloc_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_alloc_buffer(ggml_backend_t backend, size_t size)
     * }
     */
    public static MemorySegment ggml_backend_alloc_buffer$address() {
        return ggml_backend_alloc_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_alloc_buffer(ggml_backend_t backend, size_t size)
     * }
     */
    public static MemorySegment ggml_backend_alloc_buffer(MemorySegment backend, long size) {
        var mh$ = ggml_backend_alloc_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_alloc_buffer", backend, size);
            }
            return (MemorySegment)mh$.invokeExact(backend, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_get_alignment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_get_alignment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_get_alignment(ggml_backend_t backend)
     * }
     */
    public static FunctionDescriptor ggml_backend_get_alignment$descriptor() {
        return ggml_backend_get_alignment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_get_alignment(ggml_backend_t backend)
     * }
     */
    public static MethodHandle ggml_backend_get_alignment$handle() {
        return ggml_backend_get_alignment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_get_alignment(ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_get_alignment$address() {
        return ggml_backend_get_alignment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_backend_get_alignment(ggml_backend_t backend)
     * }
     */
    public static long ggml_backend_get_alignment(MemorySegment backend) {
        var mh$ = ggml_backend_get_alignment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_get_alignment", backend);
            }
            return (long)mh$.invokeExact(backend);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_get_max_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_get_max_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_get_max_size(ggml_backend_t backend)
     * }
     */
    public static FunctionDescriptor ggml_backend_get_max_size$descriptor() {
        return ggml_backend_get_max_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_get_max_size(ggml_backend_t backend)
     * }
     */
    public static MethodHandle ggml_backend_get_max_size$handle() {
        return ggml_backend_get_max_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_get_max_size(ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_get_max_size$address() {
        return ggml_backend_get_max_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_backend_get_max_size(ggml_backend_t backend)
     * }
     */
    public static long ggml_backend_get_max_size(MemorySegment backend) {
        var mh$ = ggml_backend_get_max_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_get_max_size", backend);
            }
            return (long)mh$.invokeExact(backend);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_tensor_set_async {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_tensor_set_async");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_set_async(ggml_backend_t backend, struct ggml_tensor *tensor, const void *data, size_t offset, size_t size)
     * }
     */
    public static FunctionDescriptor ggml_backend_tensor_set_async$descriptor() {
        return ggml_backend_tensor_set_async.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_set_async(ggml_backend_t backend, struct ggml_tensor *tensor, const void *data, size_t offset, size_t size)
     * }
     */
    public static MethodHandle ggml_backend_tensor_set_async$handle() {
        return ggml_backend_tensor_set_async.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_set_async(ggml_backend_t backend, struct ggml_tensor *tensor, const void *data, size_t offset, size_t size)
     * }
     */
    public static MemorySegment ggml_backend_tensor_set_async$address() {
        return ggml_backend_tensor_set_async.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_set_async(ggml_backend_t backend, struct ggml_tensor *tensor, const void *data, size_t offset, size_t size)
     * }
     */
    public static void ggml_backend_tensor_set_async(MemorySegment backend, MemorySegment tensor, MemorySegment data, long offset, long size) {
        var mh$ = ggml_backend_tensor_set_async.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_tensor_set_async", backend, tensor, data, offset, size);
            }
            mh$.invokeExact(backend, tensor, data, offset, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_tensor_get_async {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_tensor_get_async");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_get_async(ggml_backend_t backend, const struct ggml_tensor *tensor, void *data, size_t offset, size_t size)
     * }
     */
    public static FunctionDescriptor ggml_backend_tensor_get_async$descriptor() {
        return ggml_backend_tensor_get_async.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_get_async(ggml_backend_t backend, const struct ggml_tensor *tensor, void *data, size_t offset, size_t size)
     * }
     */
    public static MethodHandle ggml_backend_tensor_get_async$handle() {
        return ggml_backend_tensor_get_async.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_get_async(ggml_backend_t backend, const struct ggml_tensor *tensor, void *data, size_t offset, size_t size)
     * }
     */
    public static MemorySegment ggml_backend_tensor_get_async$address() {
        return ggml_backend_tensor_get_async.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_get_async(ggml_backend_t backend, const struct ggml_tensor *tensor, void *data, size_t offset, size_t size)
     * }
     */
    public static void ggml_backend_tensor_get_async(MemorySegment backend, MemorySegment tensor, MemorySegment data, long offset, long size) {
        var mh$ = ggml_backend_tensor_get_async.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_tensor_get_async", backend, tensor, data, offset, size);
            }
            mh$.invokeExact(backend, tensor, data, offset, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_tensor_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_tensor_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_set(struct ggml_tensor *tensor, const void *data, size_t offset, size_t size)
     * }
     */
    public static FunctionDescriptor ggml_backend_tensor_set$descriptor() {
        return ggml_backend_tensor_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_set(struct ggml_tensor *tensor, const void *data, size_t offset, size_t size)
     * }
     */
    public static MethodHandle ggml_backend_tensor_set$handle() {
        return ggml_backend_tensor_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_set(struct ggml_tensor *tensor, const void *data, size_t offset, size_t size)
     * }
     */
    public static MemorySegment ggml_backend_tensor_set$address() {
        return ggml_backend_tensor_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_set(struct ggml_tensor *tensor, const void *data, size_t offset, size_t size)
     * }
     */
    public static void ggml_backend_tensor_set(MemorySegment tensor, MemorySegment data, long offset, long size) {
        var mh$ = ggml_backend_tensor_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_tensor_set", tensor, data, offset, size);
            }
            mh$.invokeExact(tensor, data, offset, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_tensor_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_tensor_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_get(const struct ggml_tensor *tensor, void *data, size_t offset, size_t size)
     * }
     */
    public static FunctionDescriptor ggml_backend_tensor_get$descriptor() {
        return ggml_backend_tensor_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_get(const struct ggml_tensor *tensor, void *data, size_t offset, size_t size)
     * }
     */
    public static MethodHandle ggml_backend_tensor_get$handle() {
        return ggml_backend_tensor_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_get(const struct ggml_tensor *tensor, void *data, size_t offset, size_t size)
     * }
     */
    public static MemorySegment ggml_backend_tensor_get$address() {
        return ggml_backend_tensor_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_get(const struct ggml_tensor *tensor, void *data, size_t offset, size_t size)
     * }
     */
    public static void ggml_backend_tensor_get(MemorySegment tensor, MemorySegment data, long offset, long size) {
        var mh$ = ggml_backend_tensor_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_tensor_get", tensor, data, offset, size);
            }
            mh$.invokeExact(tensor, data, offset, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_tensor_memset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_CHAR,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_tensor_memset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_memset(struct ggml_tensor *tensor, uint8_t value, size_t offset, size_t size)
     * }
     */
    public static FunctionDescriptor ggml_backend_tensor_memset$descriptor() {
        return ggml_backend_tensor_memset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_memset(struct ggml_tensor *tensor, uint8_t value, size_t offset, size_t size)
     * }
     */
    public static MethodHandle ggml_backend_tensor_memset$handle() {
        return ggml_backend_tensor_memset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_memset(struct ggml_tensor *tensor, uint8_t value, size_t offset, size_t size)
     * }
     */
    public static MemorySegment ggml_backend_tensor_memset$address() {
        return ggml_backend_tensor_memset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_memset(struct ggml_tensor *tensor, uint8_t value, size_t offset, size_t size)
     * }
     */
    public static void ggml_backend_tensor_memset(MemorySegment tensor, byte value, long offset, long size) {
        var mh$ = ggml_backend_tensor_memset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_tensor_memset", tensor, value, offset, size);
            }
            mh$.invokeExact(tensor, value, offset, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_synchronize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_synchronize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_synchronize(ggml_backend_t backend)
     * }
     */
    public static FunctionDescriptor ggml_backend_synchronize$descriptor() {
        return ggml_backend_synchronize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_synchronize(ggml_backend_t backend)
     * }
     */
    public static MethodHandle ggml_backend_synchronize$handle() {
        return ggml_backend_synchronize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_synchronize(ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_synchronize$address() {
        return ggml_backend_synchronize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_synchronize(ggml_backend_t backend)
     * }
     */
    public static void ggml_backend_synchronize(MemorySegment backend) {
        var mh$ = ggml_backend_synchronize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_synchronize", backend);
            }
            mh$.invokeExact(backend);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_graph_plan_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_graph_plan_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_graph_plan_t ggml_backend_graph_plan_create(ggml_backend_t backend, struct ggml_cgraph *cgraph)
     * }
     */
    public static FunctionDescriptor ggml_backend_graph_plan_create$descriptor() {
        return ggml_backend_graph_plan_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_graph_plan_t ggml_backend_graph_plan_create(ggml_backend_t backend, struct ggml_cgraph *cgraph)
     * }
     */
    public static MethodHandle ggml_backend_graph_plan_create$handle() {
        return ggml_backend_graph_plan_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_graph_plan_t ggml_backend_graph_plan_create(ggml_backend_t backend, struct ggml_cgraph *cgraph)
     * }
     */
    public static MemorySegment ggml_backend_graph_plan_create$address() {
        return ggml_backend_graph_plan_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_graph_plan_t ggml_backend_graph_plan_create(ggml_backend_t backend, struct ggml_cgraph *cgraph)
     * }
     */
    public static MemorySegment ggml_backend_graph_plan_create(MemorySegment backend, MemorySegment cgraph) {
        var mh$ = ggml_backend_graph_plan_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_graph_plan_create", backend, cgraph);
            }
            return (MemorySegment)mh$.invokeExact(backend, cgraph);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_graph_plan_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_graph_plan_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_graph_plan_free(ggml_backend_t backend, ggml_backend_graph_plan_t plan)
     * }
     */
    public static FunctionDescriptor ggml_backend_graph_plan_free$descriptor() {
        return ggml_backend_graph_plan_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_graph_plan_free(ggml_backend_t backend, ggml_backend_graph_plan_t plan)
     * }
     */
    public static MethodHandle ggml_backend_graph_plan_free$handle() {
        return ggml_backend_graph_plan_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_graph_plan_free(ggml_backend_t backend, ggml_backend_graph_plan_t plan)
     * }
     */
    public static MemorySegment ggml_backend_graph_plan_free$address() {
        return ggml_backend_graph_plan_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_graph_plan_free(ggml_backend_t backend, ggml_backend_graph_plan_t plan)
     * }
     */
    public static void ggml_backend_graph_plan_free(MemorySegment backend, MemorySegment plan) {
        var mh$ = ggml_backend_graph_plan_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_graph_plan_free", backend, plan);
            }
            mh$.invokeExact(backend, plan);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_graph_plan_compute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_graph_plan_compute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_graph_plan_compute(ggml_backend_t backend, ggml_backend_graph_plan_t plan)
     * }
     */
    public static FunctionDescriptor ggml_backend_graph_plan_compute$descriptor() {
        return ggml_backend_graph_plan_compute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_graph_plan_compute(ggml_backend_t backend, ggml_backend_graph_plan_t plan)
     * }
     */
    public static MethodHandle ggml_backend_graph_plan_compute$handle() {
        return ggml_backend_graph_plan_compute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_graph_plan_compute(ggml_backend_t backend, ggml_backend_graph_plan_t plan)
     * }
     */
    public static MemorySegment ggml_backend_graph_plan_compute$address() {
        return ggml_backend_graph_plan_compute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_graph_plan_compute(ggml_backend_t backend, ggml_backend_graph_plan_t plan)
     * }
     */
    public static int ggml_backend_graph_plan_compute(MemorySegment backend, MemorySegment plan) {
        var mh$ = ggml_backend_graph_plan_compute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_graph_plan_compute", backend, plan);
            }
            return (int)mh$.invokeExact(backend, plan);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_graph_compute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_graph_compute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_graph_compute(ggml_backend_t backend, struct ggml_cgraph *cgraph)
     * }
     */
    public static FunctionDescriptor ggml_backend_graph_compute$descriptor() {
        return ggml_backend_graph_compute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_graph_compute(ggml_backend_t backend, struct ggml_cgraph *cgraph)
     * }
     */
    public static MethodHandle ggml_backend_graph_compute$handle() {
        return ggml_backend_graph_compute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_graph_compute(ggml_backend_t backend, struct ggml_cgraph *cgraph)
     * }
     */
    public static MemorySegment ggml_backend_graph_compute$address() {
        return ggml_backend_graph_compute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_graph_compute(ggml_backend_t backend, struct ggml_cgraph *cgraph)
     * }
     */
    public static int ggml_backend_graph_compute(MemorySegment backend, MemorySegment cgraph) {
        var mh$ = ggml_backend_graph_compute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_graph_compute", backend, cgraph);
            }
            return (int)mh$.invokeExact(backend, cgraph);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_graph_compute_async {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_graph_compute_async");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_graph_compute_async(ggml_backend_t backend, struct ggml_cgraph *cgraph)
     * }
     */
    public static FunctionDescriptor ggml_backend_graph_compute_async$descriptor() {
        return ggml_backend_graph_compute_async.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_graph_compute_async(ggml_backend_t backend, struct ggml_cgraph *cgraph)
     * }
     */
    public static MethodHandle ggml_backend_graph_compute_async$handle() {
        return ggml_backend_graph_compute_async.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_graph_compute_async(ggml_backend_t backend, struct ggml_cgraph *cgraph)
     * }
     */
    public static MemorySegment ggml_backend_graph_compute_async$address() {
        return ggml_backend_graph_compute_async.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_graph_compute_async(ggml_backend_t backend, struct ggml_cgraph *cgraph)
     * }
     */
    public static int ggml_backend_graph_compute_async(MemorySegment backend, MemorySegment cgraph) {
        var mh$ = ggml_backend_graph_compute_async.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_graph_compute_async", backend, cgraph);
            }
            return (int)mh$.invokeExact(backend, cgraph);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_supports_op {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_supports_op");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_backend_supports_op(ggml_backend_t backend, const struct ggml_tensor *op)
     * }
     */
    public static FunctionDescriptor ggml_backend_supports_op$descriptor() {
        return ggml_backend_supports_op.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_backend_supports_op(ggml_backend_t backend, const struct ggml_tensor *op)
     * }
     */
    public static MethodHandle ggml_backend_supports_op$handle() {
        return ggml_backend_supports_op.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_backend_supports_op(ggml_backend_t backend, const struct ggml_tensor *op)
     * }
     */
    public static MemorySegment ggml_backend_supports_op$address() {
        return ggml_backend_supports_op.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_backend_supports_op(ggml_backend_t backend, const struct ggml_tensor *op)
     * }
     */
    public static boolean ggml_backend_supports_op(MemorySegment backend, MemorySegment op) {
        var mh$ = ggml_backend_supports_op.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_supports_op", backend, op);
            }
            return (boolean)mh$.invokeExact(backend, op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_supports_buft {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_supports_buft");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_backend_supports_buft(ggml_backend_t backend, ggml_backend_buffer_type_t buft)
     * }
     */
    public static FunctionDescriptor ggml_backend_supports_buft$descriptor() {
        return ggml_backend_supports_buft.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_backend_supports_buft(ggml_backend_t backend, ggml_backend_buffer_type_t buft)
     * }
     */
    public static MethodHandle ggml_backend_supports_buft$handle() {
        return ggml_backend_supports_buft.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_backend_supports_buft(ggml_backend_t backend, ggml_backend_buffer_type_t buft)
     * }
     */
    public static MemorySegment ggml_backend_supports_buft$address() {
        return ggml_backend_supports_buft.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_backend_supports_buft(ggml_backend_t backend, ggml_backend_buffer_type_t buft)
     * }
     */
    public static boolean ggml_backend_supports_buft(MemorySegment backend, MemorySegment buft) {
        var mh$ = ggml_backend_supports_buft.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_supports_buft", backend, buft);
            }
            return (boolean)mh$.invokeExact(backend, buft);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_offload_op {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_offload_op");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_backend_offload_op(ggml_backend_t backend, const struct ggml_tensor *op)
     * }
     */
    public static FunctionDescriptor ggml_backend_offload_op$descriptor() {
        return ggml_backend_offload_op.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_backend_offload_op(ggml_backend_t backend, const struct ggml_tensor *op)
     * }
     */
    public static MethodHandle ggml_backend_offload_op$handle() {
        return ggml_backend_offload_op.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_backend_offload_op(ggml_backend_t backend, const struct ggml_tensor *op)
     * }
     */
    public static MemorySegment ggml_backend_offload_op$address() {
        return ggml_backend_offload_op.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_backend_offload_op(ggml_backend_t backend, const struct ggml_tensor *op)
     * }
     */
    public static boolean ggml_backend_offload_op(MemorySegment backend, MemorySegment op) {
        var mh$ = ggml_backend_offload_op.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_offload_op", backend, op);
            }
            return (boolean)mh$.invokeExact(backend, op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_tensor_copy_async {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_tensor_copy_async");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_copy_async(ggml_backend_t backend_src, ggml_backend_t backend_dst, struct ggml_tensor *src, struct ggml_tensor *dst)
     * }
     */
    public static FunctionDescriptor ggml_backend_tensor_copy_async$descriptor() {
        return ggml_backend_tensor_copy_async.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_copy_async(ggml_backend_t backend_src, ggml_backend_t backend_dst, struct ggml_tensor *src, struct ggml_tensor *dst)
     * }
     */
    public static MethodHandle ggml_backend_tensor_copy_async$handle() {
        return ggml_backend_tensor_copy_async.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_copy_async(ggml_backend_t backend_src, ggml_backend_t backend_dst, struct ggml_tensor *src, struct ggml_tensor *dst)
     * }
     */
    public static MemorySegment ggml_backend_tensor_copy_async$address() {
        return ggml_backend_tensor_copy_async.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_copy_async(ggml_backend_t backend_src, ggml_backend_t backend_dst, struct ggml_tensor *src, struct ggml_tensor *dst)
     * }
     */
    public static void ggml_backend_tensor_copy_async(MemorySegment backend_src, MemorySegment backend_dst, MemorySegment src, MemorySegment dst) {
        var mh$ = ggml_backend_tensor_copy_async.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_tensor_copy_async", backend_src, backend_dst, src, dst);
            }
            mh$.invokeExact(backend_src, backend_dst, src, dst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_get_device {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_get_device");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_get_device(ggml_backend_t backend)
     * }
     */
    public static FunctionDescriptor ggml_backend_get_device$descriptor() {
        return ggml_backend_get_device.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_get_device(ggml_backend_t backend)
     * }
     */
    public static MethodHandle ggml_backend_get_device$handle() {
        return ggml_backend_get_device.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_get_device(ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_get_device$address() {
        return ggml_backend_get_device.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_get_device(ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_get_device(MemorySegment backend) {
        var mh$ = ggml_backend_get_device.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_get_device", backend);
            }
            return (MemorySegment)mh$.invokeExact(backend);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_event_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_event_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_event_t ggml_backend_event_new(ggml_backend_dev_t device)
     * }
     */
    public static FunctionDescriptor ggml_backend_event_new$descriptor() {
        return ggml_backend_event_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_event_t ggml_backend_event_new(ggml_backend_dev_t device)
     * }
     */
    public static MethodHandle ggml_backend_event_new$handle() {
        return ggml_backend_event_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_event_t ggml_backend_event_new(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_event_new$address() {
        return ggml_backend_event_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_event_t ggml_backend_event_new(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_event_new(MemorySegment device) {
        var mh$ = ggml_backend_event_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_event_new", device);
            }
            return (MemorySegment)mh$.invokeExact(device);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_event_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_event_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_event_free(ggml_backend_event_t event)
     * }
     */
    public static FunctionDescriptor ggml_backend_event_free$descriptor() {
        return ggml_backend_event_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_event_free(ggml_backend_event_t event)
     * }
     */
    public static MethodHandle ggml_backend_event_free$handle() {
        return ggml_backend_event_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_event_free(ggml_backend_event_t event)
     * }
     */
    public static MemorySegment ggml_backend_event_free$address() {
        return ggml_backend_event_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_event_free(ggml_backend_event_t event)
     * }
     */
    public static void ggml_backend_event_free(MemorySegment event) {
        var mh$ = ggml_backend_event_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_event_free", event);
            }
            mh$.invokeExact(event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_event_record {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_event_record");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_event_record(ggml_backend_event_t event, ggml_backend_t backend)
     * }
     */
    public static FunctionDescriptor ggml_backend_event_record$descriptor() {
        return ggml_backend_event_record.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_event_record(ggml_backend_event_t event, ggml_backend_t backend)
     * }
     */
    public static MethodHandle ggml_backend_event_record$handle() {
        return ggml_backend_event_record.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_event_record(ggml_backend_event_t event, ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_event_record$address() {
        return ggml_backend_event_record.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_event_record(ggml_backend_event_t event, ggml_backend_t backend)
     * }
     */
    public static void ggml_backend_event_record(MemorySegment event, MemorySegment backend) {
        var mh$ = ggml_backend_event_record.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_event_record", event, backend);
            }
            mh$.invokeExact(event, backend);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_event_synchronize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_event_synchronize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_event_synchronize(ggml_backend_event_t event)
     * }
     */
    public static FunctionDescriptor ggml_backend_event_synchronize$descriptor() {
        return ggml_backend_event_synchronize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_event_synchronize(ggml_backend_event_t event)
     * }
     */
    public static MethodHandle ggml_backend_event_synchronize$handle() {
        return ggml_backend_event_synchronize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_event_synchronize(ggml_backend_event_t event)
     * }
     */
    public static MemorySegment ggml_backend_event_synchronize$address() {
        return ggml_backend_event_synchronize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_event_synchronize(ggml_backend_event_t event)
     * }
     */
    public static void ggml_backend_event_synchronize(MemorySegment event) {
        var mh$ = ggml_backend_event_synchronize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_event_synchronize", event);
            }
            mh$.invokeExact(event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_event_wait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_event_wait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_event_wait(ggml_backend_t backend, ggml_backend_event_t event)
     * }
     */
    public static FunctionDescriptor ggml_backend_event_wait$descriptor() {
        return ggml_backend_event_wait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_event_wait(ggml_backend_t backend, ggml_backend_event_t event)
     * }
     */
    public static MethodHandle ggml_backend_event_wait$handle() {
        return ggml_backend_event_wait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_event_wait(ggml_backend_t backend, ggml_backend_event_t event)
     * }
     */
    public static MemorySegment ggml_backend_event_wait$address() {
        return ggml_backend_event_wait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_event_wait(ggml_backend_t backend, ggml_backend_event_t event)
     * }
     */
    public static void ggml_backend_event_wait(MemorySegment backend, MemorySegment event) {
        var mh$ = ggml_backend_event_wait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_event_wait", backend, event);
            }
            mh$.invokeExact(backend, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GGML_BACKEND_DEVICE_TYPE_CPU = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ggml_backend_dev_type.GGML_BACKEND_DEVICE_TYPE_CPU = 0
     * }
     */
    public static int GGML_BACKEND_DEVICE_TYPE_CPU() {
        return GGML_BACKEND_DEVICE_TYPE_CPU;
    }
    private static final int GGML_BACKEND_DEVICE_TYPE_GPU = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ggml_backend_dev_type.GGML_BACKEND_DEVICE_TYPE_GPU = 1
     * }
     */
    public static int GGML_BACKEND_DEVICE_TYPE_GPU() {
        return GGML_BACKEND_DEVICE_TYPE_GPU;
    }
    private static final int GGML_BACKEND_DEVICE_TYPE_ACCEL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ggml_backend_dev_type.GGML_BACKEND_DEVICE_TYPE_ACCEL = 2
     * }
     */
    public static int GGML_BACKEND_DEVICE_TYPE_ACCEL() {
        return GGML_BACKEND_DEVICE_TYPE_ACCEL;
    }

    private static class ggml_backend_dev_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_dev_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_dev_name(ggml_backend_dev_t device)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_name$descriptor() {
        return ggml_backend_dev_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_dev_name(ggml_backend_dev_t device)
     * }
     */
    public static MethodHandle ggml_backend_dev_name$handle() {
        return ggml_backend_dev_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_dev_name(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_dev_name$address() {
        return ggml_backend_dev_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ggml_backend_dev_name(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_dev_name(MemorySegment device) {
        var mh$ = ggml_backend_dev_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_name", device);
            }
            return (MemorySegment)mh$.invokeExact(device);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_description {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_dev_description");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_dev_description(ggml_backend_dev_t device)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_description$descriptor() {
        return ggml_backend_dev_description.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_dev_description(ggml_backend_dev_t device)
     * }
     */
    public static MethodHandle ggml_backend_dev_description$handle() {
        return ggml_backend_dev_description.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_dev_description(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_dev_description$address() {
        return ggml_backend_dev_description.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ggml_backend_dev_description(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_dev_description(MemorySegment device) {
        var mh$ = ggml_backend_dev_description.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_description", device);
            }
            return (MemorySegment)mh$.invokeExact(device);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_memory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_dev_memory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_dev_memory(ggml_backend_dev_t device, size_t *free, size_t *total)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_memory$descriptor() {
        return ggml_backend_dev_memory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_dev_memory(ggml_backend_dev_t device, size_t *free, size_t *total)
     * }
     */
    public static MethodHandle ggml_backend_dev_memory$handle() {
        return ggml_backend_dev_memory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_dev_memory(ggml_backend_dev_t device, size_t *free, size_t *total)
     * }
     */
    public static MemorySegment ggml_backend_dev_memory$address() {
        return ggml_backend_dev_memory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_dev_memory(ggml_backend_dev_t device, size_t *free, size_t *total)
     * }
     */
    public static void ggml_backend_dev_memory(MemorySegment device, MemorySegment free, MemorySegment total) {
        var mh$ = ggml_backend_dev_memory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_memory", device, free, total);
            }
            mh$.invokeExact(device, free, total);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_dev_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_backend_dev_type ggml_backend_dev_type(ggml_backend_dev_t device)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_type$descriptor() {
        return ggml_backend_dev_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_backend_dev_type ggml_backend_dev_type(ggml_backend_dev_t device)
     * }
     */
    public static MethodHandle ggml_backend_dev_type$handle() {
        return ggml_backend_dev_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_backend_dev_type ggml_backend_dev_type(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_dev_type$address() {
        return ggml_backend_dev_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_backend_dev_type ggml_backend_dev_type(ggml_backend_dev_t device)
     * }
     */
    public static int ggml_backend_dev_type(MemorySegment device) {
        var mh$ = ggml_backend_dev_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_type", device);
            }
            return (int)mh$.invokeExact(device);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_get_props {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_dev_get_props");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_dev_get_props(ggml_backend_dev_t device, struct ggml_backend_dev_props *props)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_get_props$descriptor() {
        return ggml_backend_dev_get_props.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_dev_get_props(ggml_backend_dev_t device, struct ggml_backend_dev_props *props)
     * }
     */
    public static MethodHandle ggml_backend_dev_get_props$handle() {
        return ggml_backend_dev_get_props.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_dev_get_props(ggml_backend_dev_t device, struct ggml_backend_dev_props *props)
     * }
     */
    public static MemorySegment ggml_backend_dev_get_props$address() {
        return ggml_backend_dev_get_props.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_dev_get_props(ggml_backend_dev_t device, struct ggml_backend_dev_props *props)
     * }
     */
    public static void ggml_backend_dev_get_props(MemorySegment device, MemorySegment props) {
        var mh$ = ggml_backend_dev_get_props.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_get_props", device, props);
            }
            mh$.invokeExact(device, props);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_backend_reg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_dev_backend_reg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_dev_backend_reg(ggml_backend_dev_t device)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_backend_reg$descriptor() {
        return ggml_backend_dev_backend_reg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_dev_backend_reg(ggml_backend_dev_t device)
     * }
     */
    public static MethodHandle ggml_backend_dev_backend_reg$handle() {
        return ggml_backend_dev_backend_reg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_dev_backend_reg(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_dev_backend_reg$address() {
        return ggml_backend_dev_backend_reg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_dev_backend_reg(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_dev_backend_reg(MemorySegment device) {
        var mh$ = ggml_backend_dev_backend_reg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_backend_reg", device);
            }
            return (MemorySegment)mh$.invokeExact(device);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_dev_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_dev_init(ggml_backend_dev_t device, const char *params)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_init$descriptor() {
        return ggml_backend_dev_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_dev_init(ggml_backend_dev_t device, const char *params)
     * }
     */
    public static MethodHandle ggml_backend_dev_init$handle() {
        return ggml_backend_dev_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_dev_init(ggml_backend_dev_t device, const char *params)
     * }
     */
    public static MemorySegment ggml_backend_dev_init$address() {
        return ggml_backend_dev_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_dev_init(ggml_backend_dev_t device, const char *params)
     * }
     */
    public static MemorySegment ggml_backend_dev_init(MemorySegment device, MemorySegment params) {
        var mh$ = ggml_backend_dev_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_init", device, params);
            }
            return (MemorySegment)mh$.invokeExact(device, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_buffer_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_dev_buffer_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_dev_buffer_type(ggml_backend_dev_t device)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_buffer_type$descriptor() {
        return ggml_backend_dev_buffer_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_dev_buffer_type(ggml_backend_dev_t device)
     * }
     */
    public static MethodHandle ggml_backend_dev_buffer_type$handle() {
        return ggml_backend_dev_buffer_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_dev_buffer_type(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_dev_buffer_type$address() {
        return ggml_backend_dev_buffer_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_dev_buffer_type(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_dev_buffer_type(MemorySegment device) {
        var mh$ = ggml_backend_dev_buffer_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_buffer_type", device);
            }
            return (MemorySegment)mh$.invokeExact(device);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_host_buffer_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_dev_host_buffer_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_dev_host_buffer_type(ggml_backend_dev_t device)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_host_buffer_type$descriptor() {
        return ggml_backend_dev_host_buffer_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_dev_host_buffer_type(ggml_backend_dev_t device)
     * }
     */
    public static MethodHandle ggml_backend_dev_host_buffer_type$handle() {
        return ggml_backend_dev_host_buffer_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_dev_host_buffer_type(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_dev_host_buffer_type$address() {
        return ggml_backend_dev_host_buffer_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_dev_host_buffer_type(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_dev_host_buffer_type(MemorySegment device) {
        var mh$ = ggml_backend_dev_host_buffer_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_host_buffer_type", device);
            }
            return (MemorySegment)mh$.invokeExact(device);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_buffer_from_host_ptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_dev_buffer_from_host_ptr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_dev_buffer_from_host_ptr(ggml_backend_dev_t device, void *ptr, size_t size, size_t max_tensor_size)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_buffer_from_host_ptr$descriptor() {
        return ggml_backend_dev_buffer_from_host_ptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_dev_buffer_from_host_ptr(ggml_backend_dev_t device, void *ptr, size_t size, size_t max_tensor_size)
     * }
     */
    public static MethodHandle ggml_backend_dev_buffer_from_host_ptr$handle() {
        return ggml_backend_dev_buffer_from_host_ptr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_dev_buffer_from_host_ptr(ggml_backend_dev_t device, void *ptr, size_t size, size_t max_tensor_size)
     * }
     */
    public static MemorySegment ggml_backend_dev_buffer_from_host_ptr$address() {
        return ggml_backend_dev_buffer_from_host_ptr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_dev_buffer_from_host_ptr(ggml_backend_dev_t device, void *ptr, size_t size, size_t max_tensor_size)
     * }
     */
    public static MemorySegment ggml_backend_dev_buffer_from_host_ptr(MemorySegment device, MemorySegment ptr, long size, long max_tensor_size) {
        var mh$ = ggml_backend_dev_buffer_from_host_ptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_buffer_from_host_ptr", device, ptr, size, max_tensor_size);
            }
            return (MemorySegment)mh$.invokeExact(device, ptr, size, max_tensor_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_supports_op {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_dev_supports_op");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_backend_dev_supports_op(ggml_backend_dev_t device, const struct ggml_tensor *op)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_supports_op$descriptor() {
        return ggml_backend_dev_supports_op.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_backend_dev_supports_op(ggml_backend_dev_t device, const struct ggml_tensor *op)
     * }
     */
    public static MethodHandle ggml_backend_dev_supports_op$handle() {
        return ggml_backend_dev_supports_op.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_backend_dev_supports_op(ggml_backend_dev_t device, const struct ggml_tensor *op)
     * }
     */
    public static MemorySegment ggml_backend_dev_supports_op$address() {
        return ggml_backend_dev_supports_op.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_backend_dev_supports_op(ggml_backend_dev_t device, const struct ggml_tensor *op)
     * }
     */
    public static boolean ggml_backend_dev_supports_op(MemorySegment device, MemorySegment op) {
        var mh$ = ggml_backend_dev_supports_op.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_supports_op", device, op);
            }
            return (boolean)mh$.invokeExact(device, op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_supports_buft {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_dev_supports_buft");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_backend_dev_supports_buft(ggml_backend_dev_t device, ggml_backend_buffer_type_t buft)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_supports_buft$descriptor() {
        return ggml_backend_dev_supports_buft.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_backend_dev_supports_buft(ggml_backend_dev_t device, ggml_backend_buffer_type_t buft)
     * }
     */
    public static MethodHandle ggml_backend_dev_supports_buft$handle() {
        return ggml_backend_dev_supports_buft.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_backend_dev_supports_buft(ggml_backend_dev_t device, ggml_backend_buffer_type_t buft)
     * }
     */
    public static MemorySegment ggml_backend_dev_supports_buft$address() {
        return ggml_backend_dev_supports_buft.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_backend_dev_supports_buft(ggml_backend_dev_t device, ggml_backend_buffer_type_t buft)
     * }
     */
    public static boolean ggml_backend_dev_supports_buft(MemorySegment device, MemorySegment buft) {
        var mh$ = ggml_backend_dev_supports_buft.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_supports_buft", device, buft);
            }
            return (boolean)mh$.invokeExact(device, buft);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_offload_op {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_dev_offload_op");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_backend_dev_offload_op(ggml_backend_dev_t device, const struct ggml_tensor *op)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_offload_op$descriptor() {
        return ggml_backend_dev_offload_op.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_backend_dev_offload_op(ggml_backend_dev_t device, const struct ggml_tensor *op)
     * }
     */
    public static MethodHandle ggml_backend_dev_offload_op$handle() {
        return ggml_backend_dev_offload_op.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_backend_dev_offload_op(ggml_backend_dev_t device, const struct ggml_tensor *op)
     * }
     */
    public static MemorySegment ggml_backend_dev_offload_op$address() {
        return ggml_backend_dev_offload_op.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_backend_dev_offload_op(ggml_backend_dev_t device, const struct ggml_tensor *op)
     * }
     */
    public static boolean ggml_backend_dev_offload_op(MemorySegment device, MemorySegment op) {
        var mh$ = ggml_backend_dev_offload_op.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_offload_op", device, op);
            }
            return (boolean)mh$.invokeExact(device, op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_reg_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_reg_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_reg_name(ggml_backend_reg_t reg)
     * }
     */
    public static FunctionDescriptor ggml_backend_reg_name$descriptor() {
        return ggml_backend_reg_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_reg_name(ggml_backend_reg_t reg)
     * }
     */
    public static MethodHandle ggml_backend_reg_name$handle() {
        return ggml_backend_reg_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_reg_name(ggml_backend_reg_t reg)
     * }
     */
    public static MemorySegment ggml_backend_reg_name$address() {
        return ggml_backend_reg_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ggml_backend_reg_name(ggml_backend_reg_t reg)
     * }
     */
    public static MemorySegment ggml_backend_reg_name(MemorySegment reg) {
        var mh$ = ggml_backend_reg_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_reg_name", reg);
            }
            return (MemorySegment)mh$.invokeExact(reg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_reg_dev_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_reg_dev_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_reg_dev_count(ggml_backend_reg_t reg)
     * }
     */
    public static FunctionDescriptor ggml_backend_reg_dev_count$descriptor() {
        return ggml_backend_reg_dev_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_reg_dev_count(ggml_backend_reg_t reg)
     * }
     */
    public static MethodHandle ggml_backend_reg_dev_count$handle() {
        return ggml_backend_reg_dev_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_reg_dev_count(ggml_backend_reg_t reg)
     * }
     */
    public static MemorySegment ggml_backend_reg_dev_count$address() {
        return ggml_backend_reg_dev_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_backend_reg_dev_count(ggml_backend_reg_t reg)
     * }
     */
    public static long ggml_backend_reg_dev_count(MemorySegment reg) {
        var mh$ = ggml_backend_reg_dev_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_reg_dev_count", reg);
            }
            return (long)mh$.invokeExact(reg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_reg_dev_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_reg_dev_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_reg_dev_get(ggml_backend_reg_t reg, size_t index)
     * }
     */
    public static FunctionDescriptor ggml_backend_reg_dev_get$descriptor() {
        return ggml_backend_reg_dev_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_reg_dev_get(ggml_backend_reg_t reg, size_t index)
     * }
     */
    public static MethodHandle ggml_backend_reg_dev_get$handle() {
        return ggml_backend_reg_dev_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_reg_dev_get(ggml_backend_reg_t reg, size_t index)
     * }
     */
    public static MemorySegment ggml_backend_reg_dev_get$address() {
        return ggml_backend_reg_dev_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_reg_dev_get(ggml_backend_reg_t reg, size_t index)
     * }
     */
    public static MemorySegment ggml_backend_reg_dev_get(MemorySegment reg, long index) {
        var mh$ = ggml_backend_reg_dev_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_reg_dev_get", reg, index);
            }
            return (MemorySegment)mh$.invokeExact(reg, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_reg_get_proc_address {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_reg_get_proc_address");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *ggml_backend_reg_get_proc_address(ggml_backend_reg_t reg, const char *name)
     * }
     */
    public static FunctionDescriptor ggml_backend_reg_get_proc_address$descriptor() {
        return ggml_backend_reg_get_proc_address.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *ggml_backend_reg_get_proc_address(ggml_backend_reg_t reg, const char *name)
     * }
     */
    public static MethodHandle ggml_backend_reg_get_proc_address$handle() {
        return ggml_backend_reg_get_proc_address.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *ggml_backend_reg_get_proc_address(ggml_backend_reg_t reg, const char *name)
     * }
     */
    public static MemorySegment ggml_backend_reg_get_proc_address$address() {
        return ggml_backend_reg_get_proc_address.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *ggml_backend_reg_get_proc_address(ggml_backend_reg_t reg, const char *name)
     * }
     */
    public static MemorySegment ggml_backend_reg_get_proc_address(MemorySegment reg, MemorySegment name) {
        var mh$ = ggml_backend_reg_get_proc_address.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_reg_get_proc_address", reg, name);
            }
            return (MemorySegment)mh$.invokeExact(reg, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_device_register {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_device_register");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_device_register(ggml_backend_dev_t device)
     * }
     */
    public static FunctionDescriptor ggml_backend_device_register$descriptor() {
        return ggml_backend_device_register.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_device_register(ggml_backend_dev_t device)
     * }
     */
    public static MethodHandle ggml_backend_device_register$handle() {
        return ggml_backend_device_register.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_device_register(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_device_register$address() {
        return ggml_backend_device_register.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_device_register(ggml_backend_dev_t device)
     * }
     */
    public static void ggml_backend_device_register(MemorySegment device) {
        var mh$ = ggml_backend_device_register.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_device_register", device);
            }
            mh$.invokeExact(device);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_reg_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_reg_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_reg_count()
     * }
     */
    public static FunctionDescriptor ggml_backend_reg_count$descriptor() {
        return ggml_backend_reg_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_reg_count()
     * }
     */
    public static MethodHandle ggml_backend_reg_count$handle() {
        return ggml_backend_reg_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_reg_count()
     * }
     */
    public static MemorySegment ggml_backend_reg_count$address() {
        return ggml_backend_reg_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_backend_reg_count()
     * }
     */
    public static long ggml_backend_reg_count() {
        var mh$ = ggml_backend_reg_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_reg_count");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_reg_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_reg_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_reg_get(size_t index)
     * }
     */
    public static FunctionDescriptor ggml_backend_reg_get$descriptor() {
        return ggml_backend_reg_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_reg_get(size_t index)
     * }
     */
    public static MethodHandle ggml_backend_reg_get$handle() {
        return ggml_backend_reg_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_reg_get(size_t index)
     * }
     */
    public static MemorySegment ggml_backend_reg_get$address() {
        return ggml_backend_reg_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_reg_get(size_t index)
     * }
     */
    public static MemorySegment ggml_backend_reg_get(long index) {
        var mh$ = ggml_backend_reg_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_reg_get", index);
            }
            return (MemorySegment)mh$.invokeExact(index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_reg_by_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_reg_by_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_reg_by_name(const char *name)
     * }
     */
    public static FunctionDescriptor ggml_backend_reg_by_name$descriptor() {
        return ggml_backend_reg_by_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_reg_by_name(const char *name)
     * }
     */
    public static MethodHandle ggml_backend_reg_by_name$handle() {
        return ggml_backend_reg_by_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_reg_by_name(const char *name)
     * }
     */
    public static MemorySegment ggml_backend_reg_by_name$address() {
        return ggml_backend_reg_by_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_reg_by_name(const char *name)
     * }
     */
    public static MemorySegment ggml_backend_reg_by_name(MemorySegment name) {
        var mh$ = ggml_backend_reg_by_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_reg_by_name", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_dev_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_dev_count()
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_count$descriptor() {
        return ggml_backend_dev_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_dev_count()
     * }
     */
    public static MethodHandle ggml_backend_dev_count$handle() {
        return ggml_backend_dev_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_dev_count()
     * }
     */
    public static MemorySegment ggml_backend_dev_count$address() {
        return ggml_backend_dev_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_backend_dev_count()
     * }
     */
    public static long ggml_backend_dev_count() {
        var mh$ = ggml_backend_dev_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_count");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_dev_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_dev_get(size_t index)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_get$descriptor() {
        return ggml_backend_dev_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_dev_get(size_t index)
     * }
     */
    public static MethodHandle ggml_backend_dev_get$handle() {
        return ggml_backend_dev_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_dev_get(size_t index)
     * }
     */
    public static MemorySegment ggml_backend_dev_get$address() {
        return ggml_backend_dev_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_dev_get(size_t index)
     * }
     */
    public static MemorySegment ggml_backend_dev_get(long index) {
        var mh$ = ggml_backend_dev_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_get", index);
            }
            return (MemorySegment)mh$.invokeExact(index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_by_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_dev_by_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_dev_by_name(const char *name)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_by_name$descriptor() {
        return ggml_backend_dev_by_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_dev_by_name(const char *name)
     * }
     */
    public static MethodHandle ggml_backend_dev_by_name$handle() {
        return ggml_backend_dev_by_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_dev_by_name(const char *name)
     * }
     */
    public static MemorySegment ggml_backend_dev_by_name$address() {
        return ggml_backend_dev_by_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_dev_by_name(const char *name)
     * }
     */
    public static MemorySegment ggml_backend_dev_by_name(MemorySegment name) {
        var mh$ = ggml_backend_dev_by_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_by_name", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_by_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_dev_by_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_dev_by_type(enum ggml_backend_dev_type type)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_by_type$descriptor() {
        return ggml_backend_dev_by_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_dev_by_type(enum ggml_backend_dev_type type)
     * }
     */
    public static MethodHandle ggml_backend_dev_by_type$handle() {
        return ggml_backend_dev_by_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_dev_by_type(enum ggml_backend_dev_type type)
     * }
     */
    public static MemorySegment ggml_backend_dev_by_type$address() {
        return ggml_backend_dev_by_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_dev_by_type(enum ggml_backend_dev_type type)
     * }
     */
    public static MemorySegment ggml_backend_dev_by_type(int type) {
        var mh$ = ggml_backend_dev_by_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_by_type", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_init_by_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_init_by_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_init_by_name(const char *name, const char *params)
     * }
     */
    public static FunctionDescriptor ggml_backend_init_by_name$descriptor() {
        return ggml_backend_init_by_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_init_by_name(const char *name, const char *params)
     * }
     */
    public static MethodHandle ggml_backend_init_by_name$handle() {
        return ggml_backend_init_by_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_init_by_name(const char *name, const char *params)
     * }
     */
    public static MemorySegment ggml_backend_init_by_name$address() {
        return ggml_backend_init_by_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_init_by_name(const char *name, const char *params)
     * }
     */
    public static MemorySegment ggml_backend_init_by_name(MemorySegment name, MemorySegment params) {
        var mh$ = ggml_backend_init_by_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_init_by_name", name, params);
            }
            return (MemorySegment)mh$.invokeExact(name, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_init_by_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_init_by_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_init_by_type(enum ggml_backend_dev_type type, const char *params)
     * }
     */
    public static FunctionDescriptor ggml_backend_init_by_type$descriptor() {
        return ggml_backend_init_by_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_init_by_type(enum ggml_backend_dev_type type, const char *params)
     * }
     */
    public static MethodHandle ggml_backend_init_by_type$handle() {
        return ggml_backend_init_by_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_init_by_type(enum ggml_backend_dev_type type, const char *params)
     * }
     */
    public static MemorySegment ggml_backend_init_by_type$address() {
        return ggml_backend_init_by_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_init_by_type(enum ggml_backend_dev_type type, const char *params)
     * }
     */
    public static MemorySegment ggml_backend_init_by_type(int type, MemorySegment params) {
        var mh$ = ggml_backend_init_by_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_init_by_type", type, params);
            }
            return (MemorySegment)mh$.invokeExact(type, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_init_best {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_init_best");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_init_best()
     * }
     */
    public static FunctionDescriptor ggml_backend_init_best$descriptor() {
        return ggml_backend_init_best.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_init_best()
     * }
     */
    public static MethodHandle ggml_backend_init_best$handle() {
        return ggml_backend_init_best.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_init_best()
     * }
     */
    public static MemorySegment ggml_backend_init_best$address() {
        return ggml_backend_init_best.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_init_best()
     * }
     */
    public static MemorySegment ggml_backend_init_best() {
        var mh$ = ggml_backend_init_best.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_init_best");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_load {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_load");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_load(const char *path)
     * }
     */
    public static FunctionDescriptor ggml_backend_load$descriptor() {
        return ggml_backend_load.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_load(const char *path)
     * }
     */
    public static MethodHandle ggml_backend_load$handle() {
        return ggml_backend_load.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_load(const char *path)
     * }
     */
    public static MemorySegment ggml_backend_load$address() {
        return ggml_backend_load.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_load(const char *path)
     * }
     */
    public static MemorySegment ggml_backend_load(MemorySegment path) {
        var mh$ = ggml_backend_load.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_load", path);
            }
            return (MemorySegment)mh$.invokeExact(path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_unload {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_unload");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_unload(ggml_backend_reg_t reg)
     * }
     */
    public static FunctionDescriptor ggml_backend_unload$descriptor() {
        return ggml_backend_unload.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_unload(ggml_backend_reg_t reg)
     * }
     */
    public static MethodHandle ggml_backend_unload$handle() {
        return ggml_backend_unload.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_unload(ggml_backend_reg_t reg)
     * }
     */
    public static MemorySegment ggml_backend_unload$address() {
        return ggml_backend_unload.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_unload(ggml_backend_reg_t reg)
     * }
     */
    public static void ggml_backend_unload(MemorySegment reg) {
        var mh$ = ggml_backend_unload.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_unload", reg);
            }
            mh$.invokeExact(reg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_load_all {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_load_all");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_load_all()
     * }
     */
    public static FunctionDescriptor ggml_backend_load_all$descriptor() {
        return ggml_backend_load_all.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_load_all()
     * }
     */
    public static MethodHandle ggml_backend_load_all$handle() {
        return ggml_backend_load_all.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_load_all()
     * }
     */
    public static MemorySegment ggml_backend_load_all$address() {
        return ggml_backend_load_all.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_load_all()
     * }
     */
    public static void ggml_backend_load_all() {
        var mh$ = ggml_backend_load_all.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_load_all");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_load_all_from_path {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_load_all_from_path");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_load_all_from_path(const char *dir_path)
     * }
     */
    public static FunctionDescriptor ggml_backend_load_all_from_path$descriptor() {
        return ggml_backend_load_all_from_path.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_load_all_from_path(const char *dir_path)
     * }
     */
    public static MethodHandle ggml_backend_load_all_from_path$handle() {
        return ggml_backend_load_all_from_path.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_load_all_from_path(const char *dir_path)
     * }
     */
    public static MemorySegment ggml_backend_load_all_from_path$address() {
        return ggml_backend_load_all_from_path.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_load_all_from_path(const char *dir_path)
     * }
     */
    public static void ggml_backend_load_all_from_path(MemorySegment dir_path) {
        var mh$ = ggml_backend_load_all_from_path.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_load_all_from_path", dir_path);
            }
            mh$.invokeExact(dir_path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct ggml_backend_sched *ggml_backend_sched_t
     * }
     */
    public static final AddressLayout ggml_backend_sched_t = WhisperCpp.C_POINTER;

    private static class ggml_backend_sched_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_BOOL,
            WhisperCpp.C_BOOL
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_sched_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_sched_t ggml_backend_sched_new(ggml_backend_t *backends, ggml_backend_buffer_type_t *bufts, int n_backends, size_t graph_size, bool parallel, bool op_offload)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_new$descriptor() {
        return ggml_backend_sched_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_sched_t ggml_backend_sched_new(ggml_backend_t *backends, ggml_backend_buffer_type_t *bufts, int n_backends, size_t graph_size, bool parallel, bool op_offload)
     * }
     */
    public static MethodHandle ggml_backend_sched_new$handle() {
        return ggml_backend_sched_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_sched_t ggml_backend_sched_new(ggml_backend_t *backends, ggml_backend_buffer_type_t *bufts, int n_backends, size_t graph_size, bool parallel, bool op_offload)
     * }
     */
    public static MemorySegment ggml_backend_sched_new$address() {
        return ggml_backend_sched_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_sched_t ggml_backend_sched_new(ggml_backend_t *backends, ggml_backend_buffer_type_t *bufts, int n_backends, size_t graph_size, bool parallel, bool op_offload)
     * }
     */
    public static MemorySegment ggml_backend_sched_new(MemorySegment backends, MemorySegment bufts, int n_backends, long graph_size, boolean parallel, boolean op_offload) {
        var mh$ = ggml_backend_sched_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_new", backends, bufts, n_backends, graph_size, parallel, op_offload);
            }
            return (MemorySegment)mh$.invokeExact(backends, bufts, n_backends, graph_size, parallel, op_offload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_sched_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_free(ggml_backend_sched_t sched)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_free$descriptor() {
        return ggml_backend_sched_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_free(ggml_backend_sched_t sched)
     * }
     */
    public static MethodHandle ggml_backend_sched_free$handle() {
        return ggml_backend_sched_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_free(ggml_backend_sched_t sched)
     * }
     */
    public static MemorySegment ggml_backend_sched_free$address() {
        return ggml_backend_sched_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_sched_free(ggml_backend_sched_t sched)
     * }
     */
    public static void ggml_backend_sched_free(MemorySegment sched) {
        var mh$ = ggml_backend_sched_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_free", sched);
            }
            mh$.invokeExact(sched);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_reserve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_sched_reserve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_backend_sched_reserve(ggml_backend_sched_t sched, struct ggml_cgraph *measure_graph)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_reserve$descriptor() {
        return ggml_backend_sched_reserve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_backend_sched_reserve(ggml_backend_sched_t sched, struct ggml_cgraph *measure_graph)
     * }
     */
    public static MethodHandle ggml_backend_sched_reserve$handle() {
        return ggml_backend_sched_reserve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_backend_sched_reserve(ggml_backend_sched_t sched, struct ggml_cgraph *measure_graph)
     * }
     */
    public static MemorySegment ggml_backend_sched_reserve$address() {
        return ggml_backend_sched_reserve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_backend_sched_reserve(ggml_backend_sched_t sched, struct ggml_cgraph *measure_graph)
     * }
     */
    public static boolean ggml_backend_sched_reserve(MemorySegment sched, MemorySegment measure_graph) {
        var mh$ = ggml_backend_sched_reserve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_reserve", sched, measure_graph);
            }
            return (boolean)mh$.invokeExact(sched, measure_graph);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_get_n_backends {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_sched_get_n_backends");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_backend_sched_get_n_backends(ggml_backend_sched_t sched)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_get_n_backends$descriptor() {
        return ggml_backend_sched_get_n_backends.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_backend_sched_get_n_backends(ggml_backend_sched_t sched)
     * }
     */
    public static MethodHandle ggml_backend_sched_get_n_backends$handle() {
        return ggml_backend_sched_get_n_backends.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_backend_sched_get_n_backends(ggml_backend_sched_t sched)
     * }
     */
    public static MemorySegment ggml_backend_sched_get_n_backends$address() {
        return ggml_backend_sched_get_n_backends.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_backend_sched_get_n_backends(ggml_backend_sched_t sched)
     * }
     */
    public static int ggml_backend_sched_get_n_backends(MemorySegment sched) {
        var mh$ = ggml_backend_sched_get_n_backends.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_get_n_backends", sched);
            }
            return (int)mh$.invokeExact(sched);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_get_backend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_sched_get_backend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_sched_get_backend(ggml_backend_sched_t sched, int i)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_get_backend$descriptor() {
        return ggml_backend_sched_get_backend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_sched_get_backend(ggml_backend_sched_t sched, int i)
     * }
     */
    public static MethodHandle ggml_backend_sched_get_backend$handle() {
        return ggml_backend_sched_get_backend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_sched_get_backend(ggml_backend_sched_t sched, int i)
     * }
     */
    public static MemorySegment ggml_backend_sched_get_backend$address() {
        return ggml_backend_sched_get_backend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_sched_get_backend(ggml_backend_sched_t sched, int i)
     * }
     */
    public static MemorySegment ggml_backend_sched_get_backend(MemorySegment sched, int i) {
        var mh$ = ggml_backend_sched_get_backend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_get_backend", sched, i);
            }
            return (MemorySegment)mh$.invokeExact(sched, i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_get_n_splits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_sched_get_n_splits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_backend_sched_get_n_splits(ggml_backend_sched_t sched)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_get_n_splits$descriptor() {
        return ggml_backend_sched_get_n_splits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_backend_sched_get_n_splits(ggml_backend_sched_t sched)
     * }
     */
    public static MethodHandle ggml_backend_sched_get_n_splits$handle() {
        return ggml_backend_sched_get_n_splits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_backend_sched_get_n_splits(ggml_backend_sched_t sched)
     * }
     */
    public static MemorySegment ggml_backend_sched_get_n_splits$address() {
        return ggml_backend_sched_get_n_splits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_backend_sched_get_n_splits(ggml_backend_sched_t sched)
     * }
     */
    public static int ggml_backend_sched_get_n_splits(MemorySegment sched) {
        var mh$ = ggml_backend_sched_get_n_splits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_get_n_splits", sched);
            }
            return (int)mh$.invokeExact(sched);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_get_n_copies {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_sched_get_n_copies");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_backend_sched_get_n_copies(ggml_backend_sched_t sched)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_get_n_copies$descriptor() {
        return ggml_backend_sched_get_n_copies.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_backend_sched_get_n_copies(ggml_backend_sched_t sched)
     * }
     */
    public static MethodHandle ggml_backend_sched_get_n_copies$handle() {
        return ggml_backend_sched_get_n_copies.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_backend_sched_get_n_copies(ggml_backend_sched_t sched)
     * }
     */
    public static MemorySegment ggml_backend_sched_get_n_copies$address() {
        return ggml_backend_sched_get_n_copies.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_backend_sched_get_n_copies(ggml_backend_sched_t sched)
     * }
     */
    public static int ggml_backend_sched_get_n_copies(MemorySegment sched) {
        var mh$ = ggml_backend_sched_get_n_copies.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_get_n_copies", sched);
            }
            return (int)mh$.invokeExact(sched);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_get_buffer_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_sched_get_buffer_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_sched_get_buffer_size(ggml_backend_sched_t sched, ggml_backend_t backend)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_get_buffer_size$descriptor() {
        return ggml_backend_sched_get_buffer_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_sched_get_buffer_size(ggml_backend_sched_t sched, ggml_backend_t backend)
     * }
     */
    public static MethodHandle ggml_backend_sched_get_buffer_size$handle() {
        return ggml_backend_sched_get_buffer_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_sched_get_buffer_size(ggml_backend_sched_t sched, ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_sched_get_buffer_size$address() {
        return ggml_backend_sched_get_buffer_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_backend_sched_get_buffer_size(ggml_backend_sched_t sched, ggml_backend_t backend)
     * }
     */
    public static long ggml_backend_sched_get_buffer_size(MemorySegment sched, MemorySegment backend) {
        var mh$ = ggml_backend_sched_get_buffer_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_get_buffer_size", sched, backend);
            }
            return (long)mh$.invokeExact(sched, backend);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_set_tensor_backend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_sched_set_tensor_backend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_set_tensor_backend(ggml_backend_sched_t sched, struct ggml_tensor *node, ggml_backend_t backend)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_set_tensor_backend$descriptor() {
        return ggml_backend_sched_set_tensor_backend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_set_tensor_backend(ggml_backend_sched_t sched, struct ggml_tensor *node, ggml_backend_t backend)
     * }
     */
    public static MethodHandle ggml_backend_sched_set_tensor_backend$handle() {
        return ggml_backend_sched_set_tensor_backend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_set_tensor_backend(ggml_backend_sched_t sched, struct ggml_tensor *node, ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_sched_set_tensor_backend$address() {
        return ggml_backend_sched_set_tensor_backend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_sched_set_tensor_backend(ggml_backend_sched_t sched, struct ggml_tensor *node, ggml_backend_t backend)
     * }
     */
    public static void ggml_backend_sched_set_tensor_backend(MemorySegment sched, MemorySegment node, MemorySegment backend) {
        var mh$ = ggml_backend_sched_set_tensor_backend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_set_tensor_backend", sched, node, backend);
            }
            mh$.invokeExact(sched, node, backend);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_get_tensor_backend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_sched_get_tensor_backend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_sched_get_tensor_backend(ggml_backend_sched_t sched, struct ggml_tensor *node)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_get_tensor_backend$descriptor() {
        return ggml_backend_sched_get_tensor_backend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_sched_get_tensor_backend(ggml_backend_sched_t sched, struct ggml_tensor *node)
     * }
     */
    public static MethodHandle ggml_backend_sched_get_tensor_backend$handle() {
        return ggml_backend_sched_get_tensor_backend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_sched_get_tensor_backend(ggml_backend_sched_t sched, struct ggml_tensor *node)
     * }
     */
    public static MemorySegment ggml_backend_sched_get_tensor_backend$address() {
        return ggml_backend_sched_get_tensor_backend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_sched_get_tensor_backend(ggml_backend_sched_t sched, struct ggml_tensor *node)
     * }
     */
    public static MemorySegment ggml_backend_sched_get_tensor_backend(MemorySegment sched, MemorySegment node) {
        var mh$ = ggml_backend_sched_get_tensor_backend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_get_tensor_backend", sched, node);
            }
            return (MemorySegment)mh$.invokeExact(sched, node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_alloc_graph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_sched_alloc_graph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_backend_sched_alloc_graph(ggml_backend_sched_t sched, struct ggml_cgraph *graph)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_alloc_graph$descriptor() {
        return ggml_backend_sched_alloc_graph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_backend_sched_alloc_graph(ggml_backend_sched_t sched, struct ggml_cgraph *graph)
     * }
     */
    public static MethodHandle ggml_backend_sched_alloc_graph$handle() {
        return ggml_backend_sched_alloc_graph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_backend_sched_alloc_graph(ggml_backend_sched_t sched, struct ggml_cgraph *graph)
     * }
     */
    public static MemorySegment ggml_backend_sched_alloc_graph$address() {
        return ggml_backend_sched_alloc_graph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_backend_sched_alloc_graph(ggml_backend_sched_t sched, struct ggml_cgraph *graph)
     * }
     */
    public static boolean ggml_backend_sched_alloc_graph(MemorySegment sched, MemorySegment graph) {
        var mh$ = ggml_backend_sched_alloc_graph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_alloc_graph", sched, graph);
            }
            return (boolean)mh$.invokeExact(sched, graph);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_graph_compute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_sched_graph_compute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_sched_graph_compute(ggml_backend_sched_t sched, struct ggml_cgraph *graph)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_graph_compute$descriptor() {
        return ggml_backend_sched_graph_compute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_sched_graph_compute(ggml_backend_sched_t sched, struct ggml_cgraph *graph)
     * }
     */
    public static MethodHandle ggml_backend_sched_graph_compute$handle() {
        return ggml_backend_sched_graph_compute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_sched_graph_compute(ggml_backend_sched_t sched, struct ggml_cgraph *graph)
     * }
     */
    public static MemorySegment ggml_backend_sched_graph_compute$address() {
        return ggml_backend_sched_graph_compute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_sched_graph_compute(ggml_backend_sched_t sched, struct ggml_cgraph *graph)
     * }
     */
    public static int ggml_backend_sched_graph_compute(MemorySegment sched, MemorySegment graph) {
        var mh$ = ggml_backend_sched_graph_compute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_graph_compute", sched, graph);
            }
            return (int)mh$.invokeExact(sched, graph);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_graph_compute_async {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_sched_graph_compute_async");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_sched_graph_compute_async(ggml_backend_sched_t sched, struct ggml_cgraph *graph)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_graph_compute_async$descriptor() {
        return ggml_backend_sched_graph_compute_async.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_sched_graph_compute_async(ggml_backend_sched_t sched, struct ggml_cgraph *graph)
     * }
     */
    public static MethodHandle ggml_backend_sched_graph_compute_async$handle() {
        return ggml_backend_sched_graph_compute_async.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_sched_graph_compute_async(ggml_backend_sched_t sched, struct ggml_cgraph *graph)
     * }
     */
    public static MemorySegment ggml_backend_sched_graph_compute_async$address() {
        return ggml_backend_sched_graph_compute_async.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_sched_graph_compute_async(ggml_backend_sched_t sched, struct ggml_cgraph *graph)
     * }
     */
    public static int ggml_backend_sched_graph_compute_async(MemorySegment sched, MemorySegment graph) {
        var mh$ = ggml_backend_sched_graph_compute_async.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_graph_compute_async", sched, graph);
            }
            return (int)mh$.invokeExact(sched, graph);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_synchronize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_sched_synchronize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_synchronize(ggml_backend_sched_t sched)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_synchronize$descriptor() {
        return ggml_backend_sched_synchronize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_synchronize(ggml_backend_sched_t sched)
     * }
     */
    public static MethodHandle ggml_backend_sched_synchronize$handle() {
        return ggml_backend_sched_synchronize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_synchronize(ggml_backend_sched_t sched)
     * }
     */
    public static MemorySegment ggml_backend_sched_synchronize$address() {
        return ggml_backend_sched_synchronize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_sched_synchronize(ggml_backend_sched_t sched)
     * }
     */
    public static void ggml_backend_sched_synchronize(MemorySegment sched) {
        var mh$ = ggml_backend_sched_synchronize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_synchronize", sched);
            }
            mh$.invokeExact(sched);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_sched_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_reset(ggml_backend_sched_t sched)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_reset$descriptor() {
        return ggml_backend_sched_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_reset(ggml_backend_sched_t sched)
     * }
     */
    public static MethodHandle ggml_backend_sched_reset$handle() {
        return ggml_backend_sched_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_reset(ggml_backend_sched_t sched)
     * }
     */
    public static MemorySegment ggml_backend_sched_reset$address() {
        return ggml_backend_sched_reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_sched_reset(ggml_backend_sched_t sched)
     * }
     */
    public static void ggml_backend_sched_reset(MemorySegment sched) {
        var mh$ = ggml_backend_sched_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_reset", sched);
            }
            mh$.invokeExact(sched);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_set_eval_callback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_sched_set_eval_callback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_set_eval_callback(ggml_backend_sched_t sched, ggml_backend_sched_eval_callback callback, void *user_data)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_set_eval_callback$descriptor() {
        return ggml_backend_sched_set_eval_callback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_set_eval_callback(ggml_backend_sched_t sched, ggml_backend_sched_eval_callback callback, void *user_data)
     * }
     */
    public static MethodHandle ggml_backend_sched_set_eval_callback$handle() {
        return ggml_backend_sched_set_eval_callback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_set_eval_callback(ggml_backend_sched_t sched, ggml_backend_sched_eval_callback callback, void *user_data)
     * }
     */
    public static MemorySegment ggml_backend_sched_set_eval_callback$address() {
        return ggml_backend_sched_set_eval_callback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_sched_set_eval_callback(ggml_backend_sched_t sched, ggml_backend_sched_eval_callback callback, void *user_data)
     * }
     */
    public static void ggml_backend_sched_set_eval_callback(MemorySegment sched, MemorySegment callback, MemorySegment user_data) {
        var mh$ = ggml_backend_sched_set_eval_callback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_set_eval_callback", sched, callback, user_data);
            }
            mh$.invokeExact(sched, callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_compare_graph_backend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_compare_graph_backend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_backend_compare_graph_backend(ggml_backend_t backend1, ggml_backend_t backend2, struct ggml_cgraph *graph, ggml_backend_eval_callback callback, void *user_data, struct ggml_tensor *test_node)
     * }
     */
    public static FunctionDescriptor ggml_backend_compare_graph_backend$descriptor() {
        return ggml_backend_compare_graph_backend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_backend_compare_graph_backend(ggml_backend_t backend1, ggml_backend_t backend2, struct ggml_cgraph *graph, ggml_backend_eval_callback callback, void *user_data, struct ggml_tensor *test_node)
     * }
     */
    public static MethodHandle ggml_backend_compare_graph_backend$handle() {
        return ggml_backend_compare_graph_backend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_backend_compare_graph_backend(ggml_backend_t backend1, ggml_backend_t backend2, struct ggml_cgraph *graph, ggml_backend_eval_callback callback, void *user_data, struct ggml_tensor *test_node)
     * }
     */
    public static MemorySegment ggml_backend_compare_graph_backend$address() {
        return ggml_backend_compare_graph_backend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_backend_compare_graph_backend(ggml_backend_t backend1, ggml_backend_t backend2, struct ggml_cgraph *graph, ggml_backend_eval_callback callback, void *user_data, struct ggml_tensor *test_node)
     * }
     */
    public static boolean ggml_backend_compare_graph_backend(MemorySegment backend1, MemorySegment backend2, MemorySegment graph, MemorySegment callback, MemorySegment user_data, MemorySegment test_node) {
        var mh$ = ggml_backend_compare_graph_backend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_compare_graph_backend", backend1, backend2, graph, callback, user_data, test_node);
            }
            return (boolean)mh$.invokeExact(backend1, backend2, graph, callback, user_data, test_node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_tensor_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_tensor_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_tensor_alloc(ggml_backend_buffer_t buffer, struct ggml_tensor *tensor, void *addr)
     * }
     */
    public static FunctionDescriptor ggml_backend_tensor_alloc$descriptor() {
        return ggml_backend_tensor_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_tensor_alloc(ggml_backend_buffer_t buffer, struct ggml_tensor *tensor, void *addr)
     * }
     */
    public static MethodHandle ggml_backend_tensor_alloc$handle() {
        return ggml_backend_tensor_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_tensor_alloc(ggml_backend_buffer_t buffer, struct ggml_tensor *tensor, void *addr)
     * }
     */
    public static MemorySegment ggml_backend_tensor_alloc$address() {
        return ggml_backend_tensor_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_tensor_alloc(ggml_backend_buffer_t buffer, struct ggml_tensor *tensor, void *addr)
     * }
     */
    public static int ggml_backend_tensor_alloc(MemorySegment buffer, MemorySegment tensor, MemorySegment addr) {
        var mh$ = ggml_backend_tensor_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_tensor_alloc", buffer, tensor, addr);
            }
            return (int)mh$.invokeExact(buffer, tensor, addr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_view_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_view_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_view_init(struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_backend_view_init$descriptor() {
        return ggml_backend_view_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_view_init(struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_backend_view_init$handle() {
        return ggml_backend_view_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_view_init(struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_backend_view_init$address() {
        return ggml_backend_view_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_view_init(struct ggml_tensor *tensor)
     * }
     */
    public static int ggml_backend_view_init(MemorySegment tensor) {
        var mh$ = ggml_backend_view_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_view_init", tensor);
            }
            return (int)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_cpu_buffer_from_ptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_cpu_buffer_from_ptr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_cpu_buffer_from_ptr(void *ptr, size_t size)
     * }
     */
    public static FunctionDescriptor ggml_backend_cpu_buffer_from_ptr$descriptor() {
        return ggml_backend_cpu_buffer_from_ptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_cpu_buffer_from_ptr(void *ptr, size_t size)
     * }
     */
    public static MethodHandle ggml_backend_cpu_buffer_from_ptr$handle() {
        return ggml_backend_cpu_buffer_from_ptr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_cpu_buffer_from_ptr(void *ptr, size_t size)
     * }
     */
    public static MemorySegment ggml_backend_cpu_buffer_from_ptr$address() {
        return ggml_backend_cpu_buffer_from_ptr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_cpu_buffer_from_ptr(void *ptr, size_t size)
     * }
     */
    public static MemorySegment ggml_backend_cpu_buffer_from_ptr(MemorySegment ptr, long size) {
        var mh$ = ggml_backend_cpu_buffer_from_ptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_cpu_buffer_from_ptr", ptr, size);
            }
            return (MemorySegment)mh$.invokeExact(ptr, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_cpu_buffer_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_cpu_buffer_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_cpu_buffer_type()
     * }
     */
    public static FunctionDescriptor ggml_backend_cpu_buffer_type$descriptor() {
        return ggml_backend_cpu_buffer_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_cpu_buffer_type()
     * }
     */
    public static MethodHandle ggml_backend_cpu_buffer_type$handle() {
        return ggml_backend_cpu_buffer_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_cpu_buffer_type()
     * }
     */
    public static MemorySegment ggml_backend_cpu_buffer_type$address() {
        return ggml_backend_cpu_buffer_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_cpu_buffer_type()
     * }
     */
    public static MemorySegment ggml_backend_cpu_buffer_type() {
        var mh$ = ggml_backend_cpu_buffer_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_cpu_buffer_type");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GGML_NUMA_STRATEGY_DISABLED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ggml_numa_strategy.GGML_NUMA_STRATEGY_DISABLED = 0
     * }
     */
    public static int GGML_NUMA_STRATEGY_DISABLED() {
        return GGML_NUMA_STRATEGY_DISABLED;
    }
    private static final int GGML_NUMA_STRATEGY_DISTRIBUTE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ggml_numa_strategy.GGML_NUMA_STRATEGY_DISTRIBUTE = 1
     * }
     */
    public static int GGML_NUMA_STRATEGY_DISTRIBUTE() {
        return GGML_NUMA_STRATEGY_DISTRIBUTE;
    }
    private static final int GGML_NUMA_STRATEGY_ISOLATE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ggml_numa_strategy.GGML_NUMA_STRATEGY_ISOLATE = 2
     * }
     */
    public static int GGML_NUMA_STRATEGY_ISOLATE() {
        return GGML_NUMA_STRATEGY_ISOLATE;
    }
    private static final int GGML_NUMA_STRATEGY_NUMACTL = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ggml_numa_strategy.GGML_NUMA_STRATEGY_NUMACTL = 3
     * }
     */
    public static int GGML_NUMA_STRATEGY_NUMACTL() {
        return GGML_NUMA_STRATEGY_NUMACTL;
    }
    private static final int GGML_NUMA_STRATEGY_MIRROR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ggml_numa_strategy.GGML_NUMA_STRATEGY_MIRROR = 4
     * }
     */
    public static int GGML_NUMA_STRATEGY_MIRROR() {
        return GGML_NUMA_STRATEGY_MIRROR;
    }
    private static final int GGML_NUMA_STRATEGY_COUNT = (int)5L;
    /**
     * {@snippet lang=c :
     * enum ggml_numa_strategy.GGML_NUMA_STRATEGY_COUNT = 5
     * }
     */
    public static int GGML_NUMA_STRATEGY_COUNT() {
        return GGML_NUMA_STRATEGY_COUNT;
    }

    private static class ggml_numa_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_numa_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_numa_init(enum ggml_numa_strategy numa)
     * }
     */
    public static FunctionDescriptor ggml_numa_init$descriptor() {
        return ggml_numa_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_numa_init(enum ggml_numa_strategy numa)
     * }
     */
    public static MethodHandle ggml_numa_init$handle() {
        return ggml_numa_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_numa_init(enum ggml_numa_strategy numa)
     * }
     */
    public static MemorySegment ggml_numa_init$address() {
        return ggml_numa_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_numa_init(enum ggml_numa_strategy numa)
     * }
     */
    public static void ggml_numa_init(int numa) {
        var mh$ = ggml_numa_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_numa_init", numa);
            }
            mh$.invokeExact(numa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_is_numa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_is_numa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_is_numa()
     * }
     */
    public static FunctionDescriptor ggml_is_numa$descriptor() {
        return ggml_is_numa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_is_numa()
     * }
     */
    public static MethodHandle ggml_is_numa$handle() {
        return ggml_is_numa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_is_numa()
     * }
     */
    public static MemorySegment ggml_is_numa$address() {
        return ggml_is_numa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_is_numa()
     * }
     */
    public static boolean ggml_is_numa() {
        var mh$ = ggml_is_numa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_is_numa");
            }
            return (boolean)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_new_i32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_new_i32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_i32(struct ggml_context *ctx, int32_t value)
     * }
     */
    public static FunctionDescriptor ggml_new_i32$descriptor() {
        return ggml_new_i32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_i32(struct ggml_context *ctx, int32_t value)
     * }
     */
    public static MethodHandle ggml_new_i32$handle() {
        return ggml_new_i32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_i32(struct ggml_context *ctx, int32_t value)
     * }
     */
    public static MemorySegment ggml_new_i32$address() {
        return ggml_new_i32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_i32(struct ggml_context *ctx, int32_t value)
     * }
     */
    public static MemorySegment ggml_new_i32(MemorySegment ctx, int value) {
        var mh$ = ggml_new_i32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_new_i32", ctx, value);
            }
            return (MemorySegment)mh$.invokeExact(ctx, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_new_f32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_new_f32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_f32(struct ggml_context *ctx, float value)
     * }
     */
    public static FunctionDescriptor ggml_new_f32$descriptor() {
        return ggml_new_f32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_f32(struct ggml_context *ctx, float value)
     * }
     */
    public static MethodHandle ggml_new_f32$handle() {
        return ggml_new_f32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_f32(struct ggml_context *ctx, float value)
     * }
     */
    public static MemorySegment ggml_new_f32$address() {
        return ggml_new_f32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_f32(struct ggml_context *ctx, float value)
     * }
     */
    public static MemorySegment ggml_new_f32(MemorySegment ctx, float value) {
        var mh$ = ggml_new_f32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_new_f32", ctx, value);
            }
            return (MemorySegment)mh$.invokeExact(ctx, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_i32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set_i32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_i32(struct ggml_tensor *tensor, int32_t value)
     * }
     */
    public static FunctionDescriptor ggml_set_i32$descriptor() {
        return ggml_set_i32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_i32(struct ggml_tensor *tensor, int32_t value)
     * }
     */
    public static MethodHandle ggml_set_i32$handle() {
        return ggml_set_i32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_i32(struct ggml_tensor *tensor, int32_t value)
     * }
     */
    public static MemorySegment ggml_set_i32$address() {
        return ggml_set_i32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_i32(struct ggml_tensor *tensor, int32_t value)
     * }
     */
    public static MemorySegment ggml_set_i32(MemorySegment tensor, int value) {
        var mh$ = ggml_set_i32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_i32", tensor, value);
            }
            return (MemorySegment)mh$.invokeExact(tensor, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_f32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set_f32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_f32(struct ggml_tensor *tensor, float value)
     * }
     */
    public static FunctionDescriptor ggml_set_f32$descriptor() {
        return ggml_set_f32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_f32(struct ggml_tensor *tensor, float value)
     * }
     */
    public static MethodHandle ggml_set_f32$handle() {
        return ggml_set_f32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_f32(struct ggml_tensor *tensor, float value)
     * }
     */
    public static MemorySegment ggml_set_f32$address() {
        return ggml_set_f32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_f32(struct ggml_tensor *tensor, float value)
     * }
     */
    public static MemorySegment ggml_set_f32(MemorySegment tensor, float value) {
        var mh$ = ggml_set_f32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_f32", tensor, value);
            }
            return (MemorySegment)mh$.invokeExact(tensor, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_i32_1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_i32_1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int32_t ggml_get_i32_1d(const struct ggml_tensor *tensor, int i)
     * }
     */
    public static FunctionDescriptor ggml_get_i32_1d$descriptor() {
        return ggml_get_i32_1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int32_t ggml_get_i32_1d(const struct ggml_tensor *tensor, int i)
     * }
     */
    public static MethodHandle ggml_get_i32_1d$handle() {
        return ggml_get_i32_1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int32_t ggml_get_i32_1d(const struct ggml_tensor *tensor, int i)
     * }
     */
    public static MemorySegment ggml_get_i32_1d$address() {
        return ggml_get_i32_1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int32_t ggml_get_i32_1d(const struct ggml_tensor *tensor, int i)
     * }
     */
    public static int ggml_get_i32_1d(MemorySegment tensor, int i) {
        var mh$ = ggml_get_i32_1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_i32_1d", tensor, i);
            }
            return (int)mh$.invokeExact(tensor, i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_i32_1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set_i32_1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_set_i32_1d(const struct ggml_tensor *tensor, int i, int32_t value)
     * }
     */
    public static FunctionDescriptor ggml_set_i32_1d$descriptor() {
        return ggml_set_i32_1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_set_i32_1d(const struct ggml_tensor *tensor, int i, int32_t value)
     * }
     */
    public static MethodHandle ggml_set_i32_1d$handle() {
        return ggml_set_i32_1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_set_i32_1d(const struct ggml_tensor *tensor, int i, int32_t value)
     * }
     */
    public static MemorySegment ggml_set_i32_1d$address() {
        return ggml_set_i32_1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_set_i32_1d(const struct ggml_tensor *tensor, int i, int32_t value)
     * }
     */
    public static void ggml_set_i32_1d(MemorySegment tensor, int i, int value) {
        var mh$ = ggml_set_i32_1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_i32_1d", tensor, i, value);
            }
            mh$.invokeExact(tensor, i, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_i32_nd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_i32_nd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int32_t ggml_get_i32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3)
     * }
     */
    public static FunctionDescriptor ggml_get_i32_nd$descriptor() {
        return ggml_get_i32_nd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int32_t ggml_get_i32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3)
     * }
     */
    public static MethodHandle ggml_get_i32_nd$handle() {
        return ggml_get_i32_nd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int32_t ggml_get_i32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3)
     * }
     */
    public static MemorySegment ggml_get_i32_nd$address() {
        return ggml_get_i32_nd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int32_t ggml_get_i32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3)
     * }
     */
    public static int ggml_get_i32_nd(MemorySegment tensor, int i0, int i1, int i2, int i3) {
        var mh$ = ggml_get_i32_nd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_i32_nd", tensor, i0, i1, i2, i3);
            }
            return (int)mh$.invokeExact(tensor, i0, i1, i2, i3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_i32_nd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set_i32_nd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_set_i32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3, int32_t value)
     * }
     */
    public static FunctionDescriptor ggml_set_i32_nd$descriptor() {
        return ggml_set_i32_nd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_set_i32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3, int32_t value)
     * }
     */
    public static MethodHandle ggml_set_i32_nd$handle() {
        return ggml_set_i32_nd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_set_i32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3, int32_t value)
     * }
     */
    public static MemorySegment ggml_set_i32_nd$address() {
        return ggml_set_i32_nd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_set_i32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3, int32_t value)
     * }
     */
    public static void ggml_set_i32_nd(MemorySegment tensor, int i0, int i1, int i2, int i3, int value) {
        var mh$ = ggml_set_i32_nd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_i32_nd", tensor, i0, i1, i2, i3, value);
            }
            mh$.invokeExact(tensor, i0, i1, i2, i3, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_f32_1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_f32_1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float ggml_get_f32_1d(const struct ggml_tensor *tensor, int i)
     * }
     */
    public static FunctionDescriptor ggml_get_f32_1d$descriptor() {
        return ggml_get_f32_1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float ggml_get_f32_1d(const struct ggml_tensor *tensor, int i)
     * }
     */
    public static MethodHandle ggml_get_f32_1d$handle() {
        return ggml_get_f32_1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float ggml_get_f32_1d(const struct ggml_tensor *tensor, int i)
     * }
     */
    public static MemorySegment ggml_get_f32_1d$address() {
        return ggml_get_f32_1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float ggml_get_f32_1d(const struct ggml_tensor *tensor, int i)
     * }
     */
    public static float ggml_get_f32_1d(MemorySegment tensor, int i) {
        var mh$ = ggml_get_f32_1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_f32_1d", tensor, i);
            }
            return (float)mh$.invokeExact(tensor, i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_f32_1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set_f32_1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_set_f32_1d(const struct ggml_tensor *tensor, int i, float value)
     * }
     */
    public static FunctionDescriptor ggml_set_f32_1d$descriptor() {
        return ggml_set_f32_1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_set_f32_1d(const struct ggml_tensor *tensor, int i, float value)
     * }
     */
    public static MethodHandle ggml_set_f32_1d$handle() {
        return ggml_set_f32_1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_set_f32_1d(const struct ggml_tensor *tensor, int i, float value)
     * }
     */
    public static MemorySegment ggml_set_f32_1d$address() {
        return ggml_set_f32_1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_set_f32_1d(const struct ggml_tensor *tensor, int i, float value)
     * }
     */
    public static void ggml_set_f32_1d(MemorySegment tensor, int i, float value) {
        var mh$ = ggml_set_f32_1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_f32_1d", tensor, i, value);
            }
            mh$.invokeExact(tensor, i, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_f32_nd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_f32_nd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float ggml_get_f32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3)
     * }
     */
    public static FunctionDescriptor ggml_get_f32_nd$descriptor() {
        return ggml_get_f32_nd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float ggml_get_f32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3)
     * }
     */
    public static MethodHandle ggml_get_f32_nd$handle() {
        return ggml_get_f32_nd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float ggml_get_f32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3)
     * }
     */
    public static MemorySegment ggml_get_f32_nd$address() {
        return ggml_get_f32_nd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float ggml_get_f32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3)
     * }
     */
    public static float ggml_get_f32_nd(MemorySegment tensor, int i0, int i1, int i2, int i3) {
        var mh$ = ggml_get_f32_nd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_f32_nd", tensor, i0, i1, i2, i3);
            }
            return (float)mh$.invokeExact(tensor, i0, i1, i2, i3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_f32_nd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set_f32_nd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_set_f32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3, float value)
     * }
     */
    public static FunctionDescriptor ggml_set_f32_nd$descriptor() {
        return ggml_set_f32_nd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_set_f32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3, float value)
     * }
     */
    public static MethodHandle ggml_set_f32_nd$handle() {
        return ggml_set_f32_nd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_set_f32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3, float value)
     * }
     */
    public static MemorySegment ggml_set_f32_nd$address() {
        return ggml_set_f32_nd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_set_f32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3, float value)
     * }
     */
    public static void ggml_set_f32_nd(MemorySegment tensor, int i0, int i1, int i2, int i3, float value) {
        var mh$ = ggml_set_f32_nd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_f32_nd", tensor, i0, i1, i2, i3, value);
            }
            mh$.invokeExact(tensor, i0, i1, i2, i3, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_threadpool_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_threadpool_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_threadpool *ggml_threadpool_new(struct ggml_threadpool_params *params)
     * }
     */
    public static FunctionDescriptor ggml_threadpool_new$descriptor() {
        return ggml_threadpool_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_threadpool *ggml_threadpool_new(struct ggml_threadpool_params *params)
     * }
     */
    public static MethodHandle ggml_threadpool_new$handle() {
        return ggml_threadpool_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_threadpool *ggml_threadpool_new(struct ggml_threadpool_params *params)
     * }
     */
    public static MemorySegment ggml_threadpool_new$address() {
        return ggml_threadpool_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_threadpool *ggml_threadpool_new(struct ggml_threadpool_params *params)
     * }
     */
    public static MemorySegment ggml_threadpool_new(MemorySegment params) {
        var mh$ = ggml_threadpool_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_threadpool_new", params);
            }
            return (MemorySegment)mh$.invokeExact(params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_threadpool_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_threadpool_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_threadpool_free(struct ggml_threadpool *threadpool)
     * }
     */
    public static FunctionDescriptor ggml_threadpool_free$descriptor() {
        return ggml_threadpool_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_threadpool_free(struct ggml_threadpool *threadpool)
     * }
     */
    public static MethodHandle ggml_threadpool_free$handle() {
        return ggml_threadpool_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_threadpool_free(struct ggml_threadpool *threadpool)
     * }
     */
    public static MemorySegment ggml_threadpool_free$address() {
        return ggml_threadpool_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_threadpool_free(struct ggml_threadpool *threadpool)
     * }
     */
    public static void ggml_threadpool_free(MemorySegment threadpool) {
        var mh$ = ggml_threadpool_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_threadpool_free", threadpool);
            }
            mh$.invokeExact(threadpool);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_threadpool_get_n_threads {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_threadpool_get_n_threads");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_threadpool_get_n_threads(struct ggml_threadpool *threadpool)
     * }
     */
    public static FunctionDescriptor ggml_threadpool_get_n_threads$descriptor() {
        return ggml_threadpool_get_n_threads.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_threadpool_get_n_threads(struct ggml_threadpool *threadpool)
     * }
     */
    public static MethodHandle ggml_threadpool_get_n_threads$handle() {
        return ggml_threadpool_get_n_threads.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_threadpool_get_n_threads(struct ggml_threadpool *threadpool)
     * }
     */
    public static MemorySegment ggml_threadpool_get_n_threads$address() {
        return ggml_threadpool_get_n_threads.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_threadpool_get_n_threads(struct ggml_threadpool *threadpool)
     * }
     */
    public static int ggml_threadpool_get_n_threads(MemorySegment threadpool) {
        var mh$ = ggml_threadpool_get_n_threads.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_threadpool_get_n_threads", threadpool);
            }
            return (int)mh$.invokeExact(threadpool);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_threadpool_pause {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_threadpool_pause");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_threadpool_pause(struct ggml_threadpool *threadpool)
     * }
     */
    public static FunctionDescriptor ggml_threadpool_pause$descriptor() {
        return ggml_threadpool_pause.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_threadpool_pause(struct ggml_threadpool *threadpool)
     * }
     */
    public static MethodHandle ggml_threadpool_pause$handle() {
        return ggml_threadpool_pause.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_threadpool_pause(struct ggml_threadpool *threadpool)
     * }
     */
    public static MemorySegment ggml_threadpool_pause$address() {
        return ggml_threadpool_pause.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_threadpool_pause(struct ggml_threadpool *threadpool)
     * }
     */
    public static void ggml_threadpool_pause(MemorySegment threadpool) {
        var mh$ = ggml_threadpool_pause.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_threadpool_pause", threadpool);
            }
            mh$.invokeExact(threadpool);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_threadpool_resume {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_threadpool_resume");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_threadpool_resume(struct ggml_threadpool *threadpool)
     * }
     */
    public static FunctionDescriptor ggml_threadpool_resume$descriptor() {
        return ggml_threadpool_resume.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_threadpool_resume(struct ggml_threadpool *threadpool)
     * }
     */
    public static MethodHandle ggml_threadpool_resume$handle() {
        return ggml_threadpool_resume.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_threadpool_resume(struct ggml_threadpool *threadpool)
     * }
     */
    public static MemorySegment ggml_threadpool_resume$address() {
        return ggml_threadpool_resume.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_threadpool_resume(struct ggml_threadpool *threadpool)
     * }
     */
    public static void ggml_threadpool_resume(MemorySegment threadpool) {
        var mh$ = ggml_threadpool_resume.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_threadpool_resume", threadpool);
            }
            mh$.invokeExact(threadpool);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_plan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ggml_cplan.layout(),
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_graph_plan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_cplan ggml_graph_plan(const struct ggml_cgraph *cgraph, int n_threads, struct ggml_threadpool *threadpool)
     * }
     */
    public static FunctionDescriptor ggml_graph_plan$descriptor() {
        return ggml_graph_plan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_cplan ggml_graph_plan(const struct ggml_cgraph *cgraph, int n_threads, struct ggml_threadpool *threadpool)
     * }
     */
    public static MethodHandle ggml_graph_plan$handle() {
        return ggml_graph_plan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_cplan ggml_graph_plan(const struct ggml_cgraph *cgraph, int n_threads, struct ggml_threadpool *threadpool)
     * }
     */
    public static MemorySegment ggml_graph_plan$address() {
        return ggml_graph_plan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_cplan ggml_graph_plan(const struct ggml_cgraph *cgraph, int n_threads, struct ggml_threadpool *threadpool)
     * }
     */
    public static MemorySegment ggml_graph_plan(SegmentAllocator allocator, MemorySegment cgraph, int n_threads, MemorySegment threadpool) {
        var mh$ = ggml_graph_plan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_plan", allocator, cgraph, n_threads, threadpool);
            }
            return (MemorySegment)mh$.invokeExact(allocator, cgraph, n_threads, threadpool);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_compute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_graph_compute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_graph_compute(struct ggml_cgraph *cgraph, struct ggml_cplan *cplan)
     * }
     */
    public static FunctionDescriptor ggml_graph_compute$descriptor() {
        return ggml_graph_compute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_graph_compute(struct ggml_cgraph *cgraph, struct ggml_cplan *cplan)
     * }
     */
    public static MethodHandle ggml_graph_compute$handle() {
        return ggml_graph_compute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_graph_compute(struct ggml_cgraph *cgraph, struct ggml_cplan *cplan)
     * }
     */
    public static MemorySegment ggml_graph_compute$address() {
        return ggml_graph_compute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_status ggml_graph_compute(struct ggml_cgraph *cgraph, struct ggml_cplan *cplan)
     * }
     */
    public static int ggml_graph_compute(MemorySegment cgraph, MemorySegment cplan) {
        var mh$ = ggml_graph_compute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_compute", cgraph, cplan);
            }
            return (int)mh$.invokeExact(cgraph, cplan);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_compute_with_ctx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_graph_compute_with_ctx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_graph_compute_with_ctx(struct ggml_context *ctx, struct ggml_cgraph *cgraph, int n_threads)
     * }
     */
    public static FunctionDescriptor ggml_graph_compute_with_ctx$descriptor() {
        return ggml_graph_compute_with_ctx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_graph_compute_with_ctx(struct ggml_context *ctx, struct ggml_cgraph *cgraph, int n_threads)
     * }
     */
    public static MethodHandle ggml_graph_compute_with_ctx$handle() {
        return ggml_graph_compute_with_ctx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_graph_compute_with_ctx(struct ggml_context *ctx, struct ggml_cgraph *cgraph, int n_threads)
     * }
     */
    public static MemorySegment ggml_graph_compute_with_ctx$address() {
        return ggml_graph_compute_with_ctx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_status ggml_graph_compute_with_ctx(struct ggml_context *ctx, struct ggml_cgraph *cgraph, int n_threads)
     * }
     */
    public static int ggml_graph_compute_with_ctx(MemorySegment ctx, MemorySegment cgraph, int n_threads) {
        var mh$ = ggml_graph_compute_with_ctx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_compute_with_ctx", ctx, cgraph, n_threads);
            }
            return (int)mh$.invokeExact(ctx, cgraph, n_threads);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_sse3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cpu_has_sse3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_sse3()
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_sse3$descriptor() {
        return ggml_cpu_has_sse3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_sse3()
     * }
     */
    public static MethodHandle ggml_cpu_has_sse3$handle() {
        return ggml_cpu_has_sse3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_sse3()
     * }
     */
    public static MemorySegment ggml_cpu_has_sse3$address() {
        return ggml_cpu_has_sse3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_sse3()
     * }
     */
    public static int ggml_cpu_has_sse3() {
        var mh$ = ggml_cpu_has_sse3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_sse3");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_ssse3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cpu_has_ssse3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_ssse3()
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_ssse3$descriptor() {
        return ggml_cpu_has_ssse3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_ssse3()
     * }
     */
    public static MethodHandle ggml_cpu_has_ssse3$handle() {
        return ggml_cpu_has_ssse3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_ssse3()
     * }
     */
    public static MemorySegment ggml_cpu_has_ssse3$address() {
        return ggml_cpu_has_ssse3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_ssse3()
     * }
     */
    public static int ggml_cpu_has_ssse3() {
        var mh$ = ggml_cpu_has_ssse3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_ssse3");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_avx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cpu_has_avx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx()
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_avx$descriptor() {
        return ggml_cpu_has_avx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx()
     * }
     */
    public static MethodHandle ggml_cpu_has_avx$handle() {
        return ggml_cpu_has_avx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx()
     * }
     */
    public static MemorySegment ggml_cpu_has_avx$address() {
        return ggml_cpu_has_avx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx()
     * }
     */
    public static int ggml_cpu_has_avx() {
        var mh$ = ggml_cpu_has_avx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_avx");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_avx_vnni {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cpu_has_avx_vnni");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx_vnni()
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_avx_vnni$descriptor() {
        return ggml_cpu_has_avx_vnni.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx_vnni()
     * }
     */
    public static MethodHandle ggml_cpu_has_avx_vnni$handle() {
        return ggml_cpu_has_avx_vnni.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx_vnni()
     * }
     */
    public static MemorySegment ggml_cpu_has_avx_vnni$address() {
        return ggml_cpu_has_avx_vnni.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx_vnni()
     * }
     */
    public static int ggml_cpu_has_avx_vnni() {
        var mh$ = ggml_cpu_has_avx_vnni.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_avx_vnni");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_avx2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cpu_has_avx2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx2()
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_avx2$descriptor() {
        return ggml_cpu_has_avx2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx2()
     * }
     */
    public static MethodHandle ggml_cpu_has_avx2$handle() {
        return ggml_cpu_has_avx2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx2()
     * }
     */
    public static MemorySegment ggml_cpu_has_avx2$address() {
        return ggml_cpu_has_avx2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx2()
     * }
     */
    public static int ggml_cpu_has_avx2() {
        var mh$ = ggml_cpu_has_avx2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_avx2");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_bmi2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cpu_has_bmi2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_bmi2()
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_bmi2$descriptor() {
        return ggml_cpu_has_bmi2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_bmi2()
     * }
     */
    public static MethodHandle ggml_cpu_has_bmi2$handle() {
        return ggml_cpu_has_bmi2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_bmi2()
     * }
     */
    public static MemorySegment ggml_cpu_has_bmi2$address() {
        return ggml_cpu_has_bmi2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_bmi2()
     * }
     */
    public static int ggml_cpu_has_bmi2() {
        var mh$ = ggml_cpu_has_bmi2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_bmi2");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_f16c {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cpu_has_f16c");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_f16c()
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_f16c$descriptor() {
        return ggml_cpu_has_f16c.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_f16c()
     * }
     */
    public static MethodHandle ggml_cpu_has_f16c$handle() {
        return ggml_cpu_has_f16c.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_f16c()
     * }
     */
    public static MemorySegment ggml_cpu_has_f16c$address() {
        return ggml_cpu_has_f16c.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_f16c()
     * }
     */
    public static int ggml_cpu_has_f16c() {
        var mh$ = ggml_cpu_has_f16c.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_f16c");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_fma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cpu_has_fma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_fma()
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_fma$descriptor() {
        return ggml_cpu_has_fma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_fma()
     * }
     */
    public static MethodHandle ggml_cpu_has_fma$handle() {
        return ggml_cpu_has_fma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_fma()
     * }
     */
    public static MemorySegment ggml_cpu_has_fma$address() {
        return ggml_cpu_has_fma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_fma()
     * }
     */
    public static int ggml_cpu_has_fma() {
        var mh$ = ggml_cpu_has_fma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_fma");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_avx512 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cpu_has_avx512");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx512()
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_avx512$descriptor() {
        return ggml_cpu_has_avx512.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx512()
     * }
     */
    public static MethodHandle ggml_cpu_has_avx512$handle() {
        return ggml_cpu_has_avx512.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx512()
     * }
     */
    public static MemorySegment ggml_cpu_has_avx512$address() {
        return ggml_cpu_has_avx512.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx512()
     * }
     */
    public static int ggml_cpu_has_avx512() {
        var mh$ = ggml_cpu_has_avx512.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_avx512");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_avx512_vbmi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cpu_has_avx512_vbmi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx512_vbmi()
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_avx512_vbmi$descriptor() {
        return ggml_cpu_has_avx512_vbmi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx512_vbmi()
     * }
     */
    public static MethodHandle ggml_cpu_has_avx512_vbmi$handle() {
        return ggml_cpu_has_avx512_vbmi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx512_vbmi()
     * }
     */
    public static MemorySegment ggml_cpu_has_avx512_vbmi$address() {
        return ggml_cpu_has_avx512_vbmi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx512_vbmi()
     * }
     */
    public static int ggml_cpu_has_avx512_vbmi() {
        var mh$ = ggml_cpu_has_avx512_vbmi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_avx512_vbmi");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_avx512_vnni {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cpu_has_avx512_vnni");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx512_vnni()
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_avx512_vnni$descriptor() {
        return ggml_cpu_has_avx512_vnni.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx512_vnni()
     * }
     */
    public static MethodHandle ggml_cpu_has_avx512_vnni$handle() {
        return ggml_cpu_has_avx512_vnni.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx512_vnni()
     * }
     */
    public static MemorySegment ggml_cpu_has_avx512_vnni$address() {
        return ggml_cpu_has_avx512_vnni.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx512_vnni()
     * }
     */
    public static int ggml_cpu_has_avx512_vnni() {
        var mh$ = ggml_cpu_has_avx512_vnni.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_avx512_vnni");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_avx512_bf16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cpu_has_avx512_bf16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx512_bf16()
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_avx512_bf16$descriptor() {
        return ggml_cpu_has_avx512_bf16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx512_bf16()
     * }
     */
    public static MethodHandle ggml_cpu_has_avx512_bf16$handle() {
        return ggml_cpu_has_avx512_bf16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx512_bf16()
     * }
     */
    public static MemorySegment ggml_cpu_has_avx512_bf16$address() {
        return ggml_cpu_has_avx512_bf16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx512_bf16()
     * }
     */
    public static int ggml_cpu_has_avx512_bf16() {
        var mh$ = ggml_cpu_has_avx512_bf16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_avx512_bf16");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_amx_int8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cpu_has_amx_int8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_amx_int8()
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_amx_int8$descriptor() {
        return ggml_cpu_has_amx_int8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_amx_int8()
     * }
     */
    public static MethodHandle ggml_cpu_has_amx_int8$handle() {
        return ggml_cpu_has_amx_int8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_amx_int8()
     * }
     */
    public static MemorySegment ggml_cpu_has_amx_int8$address() {
        return ggml_cpu_has_amx_int8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_amx_int8()
     * }
     */
    public static int ggml_cpu_has_amx_int8() {
        var mh$ = ggml_cpu_has_amx_int8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_amx_int8");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_neon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cpu_has_neon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_neon()
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_neon$descriptor() {
        return ggml_cpu_has_neon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_neon()
     * }
     */
    public static MethodHandle ggml_cpu_has_neon$handle() {
        return ggml_cpu_has_neon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_neon()
     * }
     */
    public static MemorySegment ggml_cpu_has_neon$address() {
        return ggml_cpu_has_neon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_neon()
     * }
     */
    public static int ggml_cpu_has_neon() {
        var mh$ = ggml_cpu_has_neon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_neon");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_arm_fma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cpu_has_arm_fma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_arm_fma()
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_arm_fma$descriptor() {
        return ggml_cpu_has_arm_fma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_arm_fma()
     * }
     */
    public static MethodHandle ggml_cpu_has_arm_fma$handle() {
        return ggml_cpu_has_arm_fma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_arm_fma()
     * }
     */
    public static MemorySegment ggml_cpu_has_arm_fma$address() {
        return ggml_cpu_has_arm_fma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_arm_fma()
     * }
     */
    public static int ggml_cpu_has_arm_fma() {
        var mh$ = ggml_cpu_has_arm_fma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_arm_fma");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_fp16_va {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cpu_has_fp16_va");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_fp16_va()
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_fp16_va$descriptor() {
        return ggml_cpu_has_fp16_va.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_fp16_va()
     * }
     */
    public static MethodHandle ggml_cpu_has_fp16_va$handle() {
        return ggml_cpu_has_fp16_va.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_fp16_va()
     * }
     */
    public static MemorySegment ggml_cpu_has_fp16_va$address() {
        return ggml_cpu_has_fp16_va.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_fp16_va()
     * }
     */
    public static int ggml_cpu_has_fp16_va() {
        var mh$ = ggml_cpu_has_fp16_va.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_fp16_va");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_dotprod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cpu_has_dotprod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_dotprod()
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_dotprod$descriptor() {
        return ggml_cpu_has_dotprod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_dotprod()
     * }
     */
    public static MethodHandle ggml_cpu_has_dotprod$handle() {
        return ggml_cpu_has_dotprod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_dotprod()
     * }
     */
    public static MemorySegment ggml_cpu_has_dotprod$address() {
        return ggml_cpu_has_dotprod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_dotprod()
     * }
     */
    public static int ggml_cpu_has_dotprod() {
        var mh$ = ggml_cpu_has_dotprod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_dotprod");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_matmul_int8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cpu_has_matmul_int8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_matmul_int8()
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_matmul_int8$descriptor() {
        return ggml_cpu_has_matmul_int8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_matmul_int8()
     * }
     */
    public static MethodHandle ggml_cpu_has_matmul_int8$handle() {
        return ggml_cpu_has_matmul_int8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_matmul_int8()
     * }
     */
    public static MemorySegment ggml_cpu_has_matmul_int8$address() {
        return ggml_cpu_has_matmul_int8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_matmul_int8()
     * }
     */
    public static int ggml_cpu_has_matmul_int8() {
        var mh$ = ggml_cpu_has_matmul_int8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_matmul_int8");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_sve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cpu_has_sve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_sve()
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_sve$descriptor() {
        return ggml_cpu_has_sve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_sve()
     * }
     */
    public static MethodHandle ggml_cpu_has_sve$handle() {
        return ggml_cpu_has_sve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_sve()
     * }
     */
    public static MemorySegment ggml_cpu_has_sve$address() {
        return ggml_cpu_has_sve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_sve()
     * }
     */
    public static int ggml_cpu_has_sve() {
        var mh$ = ggml_cpu_has_sve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_sve");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_get_sve_cnt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cpu_get_sve_cnt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_get_sve_cnt()
     * }
     */
    public static FunctionDescriptor ggml_cpu_get_sve_cnt$descriptor() {
        return ggml_cpu_get_sve_cnt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_get_sve_cnt()
     * }
     */
    public static MethodHandle ggml_cpu_get_sve_cnt$handle() {
        return ggml_cpu_get_sve_cnt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_get_sve_cnt()
     * }
     */
    public static MemorySegment ggml_cpu_get_sve_cnt$address() {
        return ggml_cpu_get_sve_cnt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_get_sve_cnt()
     * }
     */
    public static int ggml_cpu_get_sve_cnt() {
        var mh$ = ggml_cpu_get_sve_cnt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_get_sve_cnt");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_sme {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cpu_has_sme");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_sme()
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_sme$descriptor() {
        return ggml_cpu_has_sme.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_sme()
     * }
     */
    public static MethodHandle ggml_cpu_has_sme$handle() {
        return ggml_cpu_has_sme.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_sme()
     * }
     */
    public static MemorySegment ggml_cpu_has_sme$address() {
        return ggml_cpu_has_sme.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_sme()
     * }
     */
    public static int ggml_cpu_has_sme() {
        var mh$ = ggml_cpu_has_sme.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_sme");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_riscv_v {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cpu_has_riscv_v");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_riscv_v()
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_riscv_v$descriptor() {
        return ggml_cpu_has_riscv_v.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_riscv_v()
     * }
     */
    public static MethodHandle ggml_cpu_has_riscv_v$handle() {
        return ggml_cpu_has_riscv_v.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_riscv_v()
     * }
     */
    public static MemorySegment ggml_cpu_has_riscv_v$address() {
        return ggml_cpu_has_riscv_v.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_riscv_v()
     * }
     */
    public static int ggml_cpu_has_riscv_v() {
        var mh$ = ggml_cpu_has_riscv_v.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_riscv_v");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_vsx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cpu_has_vsx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_vsx()
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_vsx$descriptor() {
        return ggml_cpu_has_vsx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_vsx()
     * }
     */
    public static MethodHandle ggml_cpu_has_vsx$handle() {
        return ggml_cpu_has_vsx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_vsx()
     * }
     */
    public static MemorySegment ggml_cpu_has_vsx$address() {
        return ggml_cpu_has_vsx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_vsx()
     * }
     */
    public static int ggml_cpu_has_vsx() {
        var mh$ = ggml_cpu_has_vsx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_vsx");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_vxe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cpu_has_vxe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_vxe()
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_vxe$descriptor() {
        return ggml_cpu_has_vxe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_vxe()
     * }
     */
    public static MethodHandle ggml_cpu_has_vxe$handle() {
        return ggml_cpu_has_vxe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_vxe()
     * }
     */
    public static MemorySegment ggml_cpu_has_vxe$address() {
        return ggml_cpu_has_vxe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_vxe()
     * }
     */
    public static int ggml_cpu_has_vxe() {
        var mh$ = ggml_cpu_has_vxe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_vxe");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_nnpa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cpu_has_nnpa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_nnpa()
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_nnpa$descriptor() {
        return ggml_cpu_has_nnpa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_nnpa()
     * }
     */
    public static MethodHandle ggml_cpu_has_nnpa$handle() {
        return ggml_cpu_has_nnpa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_nnpa()
     * }
     */
    public static MemorySegment ggml_cpu_has_nnpa$address() {
        return ggml_cpu_has_nnpa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_nnpa()
     * }
     */
    public static int ggml_cpu_has_nnpa() {
        var mh$ = ggml_cpu_has_nnpa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_nnpa");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_wasm_simd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cpu_has_wasm_simd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_wasm_simd()
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_wasm_simd$descriptor() {
        return ggml_cpu_has_wasm_simd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_wasm_simd()
     * }
     */
    public static MethodHandle ggml_cpu_has_wasm_simd$handle() {
        return ggml_cpu_has_wasm_simd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_wasm_simd()
     * }
     */
    public static MemorySegment ggml_cpu_has_wasm_simd$address() {
        return ggml_cpu_has_wasm_simd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_wasm_simd()
     * }
     */
    public static int ggml_cpu_has_wasm_simd() {
        var mh$ = ggml_cpu_has_wasm_simd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_wasm_simd");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_llamafile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cpu_has_llamafile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_llamafile()
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_llamafile$descriptor() {
        return ggml_cpu_has_llamafile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_llamafile()
     * }
     */
    public static MethodHandle ggml_cpu_has_llamafile$handle() {
        return ggml_cpu_has_llamafile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_llamafile()
     * }
     */
    public static MemorySegment ggml_cpu_has_llamafile$address() {
        return ggml_cpu_has_llamafile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_llamafile()
     * }
     */
    public static int ggml_cpu_has_llamafile() {
        var mh$ = ggml_cpu_has_llamafile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_llamafile");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_type_traits_cpu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_type_traits_cpu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const struct ggml_type_traits_cpu *ggml_get_type_traits_cpu(enum ggml_type type)
     * }
     */
    public static FunctionDescriptor ggml_get_type_traits_cpu$descriptor() {
        return ggml_get_type_traits_cpu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const struct ggml_type_traits_cpu *ggml_get_type_traits_cpu(enum ggml_type type)
     * }
     */
    public static MethodHandle ggml_get_type_traits_cpu$handle() {
        return ggml_get_type_traits_cpu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const struct ggml_type_traits_cpu *ggml_get_type_traits_cpu(enum ggml_type type)
     * }
     */
    public static MemorySegment ggml_get_type_traits_cpu$address() {
        return ggml_get_type_traits_cpu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const struct ggml_type_traits_cpu *ggml_get_type_traits_cpu(enum ggml_type type)
     * }
     */
    public static MemorySegment ggml_get_type_traits_cpu(int type) {
        var mh$ = ggml_get_type_traits_cpu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_type_traits_cpu", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cpu_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_cpu_init()
     * }
     */
    public static FunctionDescriptor ggml_cpu_init$descriptor() {
        return ggml_cpu_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_cpu_init()
     * }
     */
    public static MethodHandle ggml_cpu_init$handle() {
        return ggml_cpu_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_cpu_init()
     * }
     */
    public static MemorySegment ggml_cpu_init$address() {
        return ggml_cpu_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_cpu_init()
     * }
     */
    public static void ggml_cpu_init() {
        var mh$ = ggml_cpu_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_init");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_cpu_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_cpu_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_cpu_init()
     * }
     */
    public static FunctionDescriptor ggml_backend_cpu_init$descriptor() {
        return ggml_backend_cpu_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_cpu_init()
     * }
     */
    public static MethodHandle ggml_backend_cpu_init$handle() {
        return ggml_backend_cpu_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_cpu_init()
     * }
     */
    public static MemorySegment ggml_backend_cpu_init$address() {
        return ggml_backend_cpu_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_cpu_init()
     * }
     */
    public static MemorySegment ggml_backend_cpu_init() {
        var mh$ = ggml_backend_cpu_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_cpu_init");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_is_cpu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_is_cpu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_backend_is_cpu(ggml_backend_t backend)
     * }
     */
    public static FunctionDescriptor ggml_backend_is_cpu$descriptor() {
        return ggml_backend_is_cpu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_backend_is_cpu(ggml_backend_t backend)
     * }
     */
    public static MethodHandle ggml_backend_is_cpu$handle() {
        return ggml_backend_is_cpu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_backend_is_cpu(ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_is_cpu$address() {
        return ggml_backend_is_cpu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_backend_is_cpu(ggml_backend_t backend)
     * }
     */
    public static boolean ggml_backend_is_cpu(MemorySegment backend) {
        var mh$ = ggml_backend_is_cpu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_is_cpu", backend);
            }
            return (boolean)mh$.invokeExact(backend);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_cpu_set_n_threads {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_cpu_set_n_threads");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_cpu_set_n_threads(ggml_backend_t backend_cpu, int n_threads)
     * }
     */
    public static FunctionDescriptor ggml_backend_cpu_set_n_threads$descriptor() {
        return ggml_backend_cpu_set_n_threads.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_cpu_set_n_threads(ggml_backend_t backend_cpu, int n_threads)
     * }
     */
    public static MethodHandle ggml_backend_cpu_set_n_threads$handle() {
        return ggml_backend_cpu_set_n_threads.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_cpu_set_n_threads(ggml_backend_t backend_cpu, int n_threads)
     * }
     */
    public static MemorySegment ggml_backend_cpu_set_n_threads$address() {
        return ggml_backend_cpu_set_n_threads.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_cpu_set_n_threads(ggml_backend_t backend_cpu, int n_threads)
     * }
     */
    public static void ggml_backend_cpu_set_n_threads(MemorySegment backend_cpu, int n_threads) {
        var mh$ = ggml_backend_cpu_set_n_threads.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_cpu_set_n_threads", backend_cpu, n_threads);
            }
            mh$.invokeExact(backend_cpu, n_threads);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_cpu_set_threadpool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_cpu_set_threadpool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_cpu_set_threadpool(ggml_backend_t backend_cpu, ggml_threadpool_t threadpool)
     * }
     */
    public static FunctionDescriptor ggml_backend_cpu_set_threadpool$descriptor() {
        return ggml_backend_cpu_set_threadpool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_cpu_set_threadpool(ggml_backend_t backend_cpu, ggml_threadpool_t threadpool)
     * }
     */
    public static MethodHandle ggml_backend_cpu_set_threadpool$handle() {
        return ggml_backend_cpu_set_threadpool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_cpu_set_threadpool(ggml_backend_t backend_cpu, ggml_threadpool_t threadpool)
     * }
     */
    public static MemorySegment ggml_backend_cpu_set_threadpool$address() {
        return ggml_backend_cpu_set_threadpool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_cpu_set_threadpool(ggml_backend_t backend_cpu, ggml_threadpool_t threadpool)
     * }
     */
    public static void ggml_backend_cpu_set_threadpool(MemorySegment backend_cpu, MemorySegment threadpool) {
        var mh$ = ggml_backend_cpu_set_threadpool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_cpu_set_threadpool", backend_cpu, threadpool);
            }
            mh$.invokeExact(backend_cpu, threadpool);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_cpu_set_abort_callback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_cpu_set_abort_callback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_cpu_set_abort_callback(ggml_backend_t backend_cpu, ggml_abort_callback abort_callback, void *abort_callback_data)
     * }
     */
    public static FunctionDescriptor ggml_backend_cpu_set_abort_callback$descriptor() {
        return ggml_backend_cpu_set_abort_callback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_cpu_set_abort_callback(ggml_backend_t backend_cpu, ggml_abort_callback abort_callback, void *abort_callback_data)
     * }
     */
    public static MethodHandle ggml_backend_cpu_set_abort_callback$handle() {
        return ggml_backend_cpu_set_abort_callback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_cpu_set_abort_callback(ggml_backend_t backend_cpu, ggml_abort_callback abort_callback, void *abort_callback_data)
     * }
     */
    public static MemorySegment ggml_backend_cpu_set_abort_callback$address() {
        return ggml_backend_cpu_set_abort_callback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_cpu_set_abort_callback(ggml_backend_t backend_cpu, ggml_abort_callback abort_callback, void *abort_callback_data)
     * }
     */
    public static void ggml_backend_cpu_set_abort_callback(MemorySegment backend_cpu, MemorySegment abort_callback, MemorySegment abort_callback_data) {
        var mh$ = ggml_backend_cpu_set_abort_callback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_cpu_set_abort_callback", backend_cpu, abort_callback, abort_callback_data);
            }
            mh$.invokeExact(backend_cpu, abort_callback, abort_callback_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_cpu_reg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_cpu_reg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_cpu_reg()
     * }
     */
    public static FunctionDescriptor ggml_backend_cpu_reg$descriptor() {
        return ggml_backend_cpu_reg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_cpu_reg()
     * }
     */
    public static MethodHandle ggml_backend_cpu_reg$handle() {
        return ggml_backend_cpu_reg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_cpu_reg()
     * }
     */
    public static MemorySegment ggml_backend_cpu_reg$address() {
        return ggml_backend_cpu_reg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_cpu_reg()
     * }
     */
    public static MemorySegment ggml_backend_cpu_reg() {
        var mh$ = ggml_backend_cpu_reg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_cpu_reg");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_fp32_to_fp32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cpu_fp32_to_fp32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_cpu_fp32_to_fp32(const float *, float *, int64_t)
     * }
     */
    public static FunctionDescriptor ggml_cpu_fp32_to_fp32$descriptor() {
        return ggml_cpu_fp32_to_fp32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_cpu_fp32_to_fp32(const float *, float *, int64_t)
     * }
     */
    public static MethodHandle ggml_cpu_fp32_to_fp32$handle() {
        return ggml_cpu_fp32_to_fp32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_cpu_fp32_to_fp32(const float *, float *, int64_t)
     * }
     */
    public static MemorySegment ggml_cpu_fp32_to_fp32$address() {
        return ggml_cpu_fp32_to_fp32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_cpu_fp32_to_fp32(const float *, float *, int64_t)
     * }
     */
    public static void ggml_cpu_fp32_to_fp32(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = ggml_cpu_fp32_to_fp32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_fp32_to_fp32", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_fp32_to_fp16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cpu_fp32_to_fp16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_cpu_fp32_to_fp16(const float *, ggml_fp16_t *, int64_t)
     * }
     */
    public static FunctionDescriptor ggml_cpu_fp32_to_fp16$descriptor() {
        return ggml_cpu_fp32_to_fp16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_cpu_fp32_to_fp16(const float *, ggml_fp16_t *, int64_t)
     * }
     */
    public static MethodHandle ggml_cpu_fp32_to_fp16$handle() {
        return ggml_cpu_fp32_to_fp16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_cpu_fp32_to_fp16(const float *, ggml_fp16_t *, int64_t)
     * }
     */
    public static MemorySegment ggml_cpu_fp32_to_fp16$address() {
        return ggml_cpu_fp32_to_fp16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_cpu_fp32_to_fp16(const float *, ggml_fp16_t *, int64_t)
     * }
     */
    public static void ggml_cpu_fp32_to_fp16(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = ggml_cpu_fp32_to_fp16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_fp32_to_fp16", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_fp16_to_fp32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cpu_fp16_to_fp32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_cpu_fp16_to_fp32(const ggml_fp16_t *, float *, int64_t)
     * }
     */
    public static FunctionDescriptor ggml_cpu_fp16_to_fp32$descriptor() {
        return ggml_cpu_fp16_to_fp32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_cpu_fp16_to_fp32(const ggml_fp16_t *, float *, int64_t)
     * }
     */
    public static MethodHandle ggml_cpu_fp16_to_fp32$handle() {
        return ggml_cpu_fp16_to_fp32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_cpu_fp16_to_fp32(const ggml_fp16_t *, float *, int64_t)
     * }
     */
    public static MemorySegment ggml_cpu_fp16_to_fp32$address() {
        return ggml_cpu_fp16_to_fp32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_cpu_fp16_to_fp32(const ggml_fp16_t *, float *, int64_t)
     * }
     */
    public static void ggml_cpu_fp16_to_fp32(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = ggml_cpu_fp16_to_fp32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_fp16_to_fp32", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_fp32_to_bf16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cpu_fp32_to_bf16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_cpu_fp32_to_bf16(const float *, ggml_bf16_t *, int64_t)
     * }
     */
    public static FunctionDescriptor ggml_cpu_fp32_to_bf16$descriptor() {
        return ggml_cpu_fp32_to_bf16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_cpu_fp32_to_bf16(const float *, ggml_bf16_t *, int64_t)
     * }
     */
    public static MethodHandle ggml_cpu_fp32_to_bf16$handle() {
        return ggml_cpu_fp32_to_bf16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_cpu_fp32_to_bf16(const float *, ggml_bf16_t *, int64_t)
     * }
     */
    public static MemorySegment ggml_cpu_fp32_to_bf16$address() {
        return ggml_cpu_fp32_to_bf16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_cpu_fp32_to_bf16(const float *, ggml_bf16_t *, int64_t)
     * }
     */
    public static void ggml_cpu_fp32_to_bf16(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = ggml_cpu_fp32_to_bf16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_fp32_to_bf16", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_bf16_to_fp32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cpu_bf16_to_fp32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_cpu_bf16_to_fp32(const ggml_bf16_t *, float *, int64_t)
     * }
     */
    public static FunctionDescriptor ggml_cpu_bf16_to_fp32$descriptor() {
        return ggml_cpu_bf16_to_fp32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_cpu_bf16_to_fp32(const ggml_bf16_t *, float *, int64_t)
     * }
     */
    public static MethodHandle ggml_cpu_bf16_to_fp32$handle() {
        return ggml_cpu_bf16_to_fp32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_cpu_bf16_to_fp32(const ggml_bf16_t *, float *, int64_t)
     * }
     */
    public static MemorySegment ggml_cpu_bf16_to_fp32$address() {
        return ggml_cpu_bf16_to_fp32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_cpu_bf16_to_fp32(const ggml_bf16_t *, float *, int64_t)
     * }
     */
    public static void ggml_cpu_bf16_to_fp32(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = ggml_cpu_bf16_to_fp32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_bf16_to_fp32", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int32_t whisper_pos
     * }
     */
    public static final OfInt whisper_pos = WhisperCpp.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int32_t whisper_token
     * }
     */
    public static final OfInt whisper_token = WhisperCpp.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int32_t whisper_seq_id
     * }
     */
    public static final OfInt whisper_seq_id = WhisperCpp.C_INT;
    private static final int WHISPER_AHEADS_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum whisper_alignment_heads_preset.WHISPER_AHEADS_NONE = 0
     * }
     */
    public static int WHISPER_AHEADS_NONE() {
        return WHISPER_AHEADS_NONE;
    }
    private static final int WHISPER_AHEADS_N_TOP_MOST = (int)1L;
    /**
     * {@snippet lang=c :
     * enum whisper_alignment_heads_preset.WHISPER_AHEADS_N_TOP_MOST = 1
     * }
     */
    public static int WHISPER_AHEADS_N_TOP_MOST() {
        return WHISPER_AHEADS_N_TOP_MOST;
    }
    private static final int WHISPER_AHEADS_CUSTOM = (int)2L;
    /**
     * {@snippet lang=c :
     * enum whisper_alignment_heads_preset.WHISPER_AHEADS_CUSTOM = 2
     * }
     */
    public static int WHISPER_AHEADS_CUSTOM() {
        return WHISPER_AHEADS_CUSTOM;
    }
    private static final int WHISPER_AHEADS_TINY_EN = (int)3L;
    /**
     * {@snippet lang=c :
     * enum whisper_alignment_heads_preset.WHISPER_AHEADS_TINY_EN = 3
     * }
     */
    public static int WHISPER_AHEADS_TINY_EN() {
        return WHISPER_AHEADS_TINY_EN;
    }
    private static final int WHISPER_AHEADS_TINY = (int)4L;
    /**
     * {@snippet lang=c :
     * enum whisper_alignment_heads_preset.WHISPER_AHEADS_TINY = 4
     * }
     */
    public static int WHISPER_AHEADS_TINY() {
        return WHISPER_AHEADS_TINY;
    }
    private static final int WHISPER_AHEADS_BASE_EN = (int)5L;
    /**
     * {@snippet lang=c :
     * enum whisper_alignment_heads_preset.WHISPER_AHEADS_BASE_EN = 5
     * }
     */
    public static int WHISPER_AHEADS_BASE_EN() {
        return WHISPER_AHEADS_BASE_EN;
    }
    private static final int WHISPER_AHEADS_BASE = (int)6L;
    /**
     * {@snippet lang=c :
     * enum whisper_alignment_heads_preset.WHISPER_AHEADS_BASE = 6
     * }
     */
    public static int WHISPER_AHEADS_BASE() {
        return WHISPER_AHEADS_BASE;
    }
    private static final int WHISPER_AHEADS_SMALL_EN = (int)7L;
    /**
     * {@snippet lang=c :
     * enum whisper_alignment_heads_preset.WHISPER_AHEADS_SMALL_EN = 7
     * }
     */
    public static int WHISPER_AHEADS_SMALL_EN() {
        return WHISPER_AHEADS_SMALL_EN;
    }
    private static final int WHISPER_AHEADS_SMALL = (int)8L;
    /**
     * {@snippet lang=c :
     * enum whisper_alignment_heads_preset.WHISPER_AHEADS_SMALL = 8
     * }
     */
    public static int WHISPER_AHEADS_SMALL() {
        return WHISPER_AHEADS_SMALL;
    }
    private static final int WHISPER_AHEADS_MEDIUM_EN = (int)9L;
    /**
     * {@snippet lang=c :
     * enum whisper_alignment_heads_preset.WHISPER_AHEADS_MEDIUM_EN = 9
     * }
     */
    public static int WHISPER_AHEADS_MEDIUM_EN() {
        return WHISPER_AHEADS_MEDIUM_EN;
    }
    private static final int WHISPER_AHEADS_MEDIUM = (int)10L;
    /**
     * {@snippet lang=c :
     * enum whisper_alignment_heads_preset.WHISPER_AHEADS_MEDIUM = 10
     * }
     */
    public static int WHISPER_AHEADS_MEDIUM() {
        return WHISPER_AHEADS_MEDIUM;
    }
    private static final int WHISPER_AHEADS_LARGE_V1 = (int)11L;
    /**
     * {@snippet lang=c :
     * enum whisper_alignment_heads_preset.WHISPER_AHEADS_LARGE_V1 = 11
     * }
     */
    public static int WHISPER_AHEADS_LARGE_V1() {
        return WHISPER_AHEADS_LARGE_V1;
    }
    private static final int WHISPER_AHEADS_LARGE_V2 = (int)12L;
    /**
     * {@snippet lang=c :
     * enum whisper_alignment_heads_preset.WHISPER_AHEADS_LARGE_V2 = 12
     * }
     */
    public static int WHISPER_AHEADS_LARGE_V2() {
        return WHISPER_AHEADS_LARGE_V2;
    }
    private static final int WHISPER_AHEADS_LARGE_V3 = (int)13L;
    /**
     * {@snippet lang=c :
     * enum whisper_alignment_heads_preset.WHISPER_AHEADS_LARGE_V3 = 13
     * }
     */
    public static int WHISPER_AHEADS_LARGE_V3() {
        return WHISPER_AHEADS_LARGE_V3;
    }
    private static final int WHISPER_AHEADS_LARGE_V3_TURBO = (int)14L;
    /**
     * {@snippet lang=c :
     * enum whisper_alignment_heads_preset.WHISPER_AHEADS_LARGE_V3_TURBO = 14
     * }
     */
    public static int WHISPER_AHEADS_LARGE_V3_TURBO() {
        return WHISPER_AHEADS_LARGE_V3_TURBO;
    }
    private static final int WHISPER_GRETYPE_END = (int)0L;
    /**
     * {@snippet lang=c :
     * enum whisper_gretype.WHISPER_GRETYPE_END = 0
     * }
     */
    public static int WHISPER_GRETYPE_END() {
        return WHISPER_GRETYPE_END;
    }
    private static final int WHISPER_GRETYPE_ALT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum whisper_gretype.WHISPER_GRETYPE_ALT = 1
     * }
     */
    public static int WHISPER_GRETYPE_ALT() {
        return WHISPER_GRETYPE_ALT;
    }
    private static final int WHISPER_GRETYPE_RULE_REF = (int)2L;
    /**
     * {@snippet lang=c :
     * enum whisper_gretype.WHISPER_GRETYPE_RULE_REF = 2
     * }
     */
    public static int WHISPER_GRETYPE_RULE_REF() {
        return WHISPER_GRETYPE_RULE_REF;
    }
}

