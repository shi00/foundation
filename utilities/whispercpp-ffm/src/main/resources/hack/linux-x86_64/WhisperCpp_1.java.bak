// Generated by jextract

package com.silong.foundation.utilities.whispercpp.generated;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class WhisperCpp_1 {

    WhisperCpp_1() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.loaderLookup()
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;
    private static final int true_ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define true 1
     * }
     */
    public static int true_() {
        return true_;
    }
    private static final int false_ = (int)0L;
    /**
     * {@snippet lang=c :
     * #define false 0
     * }
     */
    public static int false_() {
        return false_;
    }
    private static final int __bool_true_false_are_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __bool_true_false_are_defined 1
     * }
     */
    public static int __bool_true_false_are_defined() {
        return __bool_true_false_are_defined;
    }
    private static final int _STDINT_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDINT_H 1
     * }
     */
    public static int _STDINT_H() {
        return _STDINT_H;
    }
    private static final int _FEATURES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _FEATURES_H 1
     * }
     */
    public static int _FEATURES_H() {
        return _FEATURES_H;
    }
    private static final int _DEFAULT_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DEFAULT_SOURCE 1
     * }
     */
    public static int _DEFAULT_SOURCE() {
        return _DEFAULT_SOURCE;
    }
    private static final int __GLIBC_USE_ISOC2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_ISOC2X 0
     * }
     */
    public static int __GLIBC_USE_ISOC2X() {
        return __GLIBC_USE_ISOC2X;
    }
    private static final int __USE_ISOC11 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC11 1
     * }
     */
    public static int __USE_ISOC11() {
        return __USE_ISOC11;
    }
    private static final int __USE_ISOC99 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC99 1
     * }
     */
    public static int __USE_ISOC99() {
        return __USE_ISOC99;
    }
    private static final int __USE_ISOC95 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC95 1
     * }
     */
    public static int __USE_ISOC95() {
        return __USE_ISOC95;
    }
    private static final int __USE_POSIX_IMPLICITLY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX_IMPLICITLY 1
     * }
     */
    public static int __USE_POSIX_IMPLICITLY() {
        return __USE_POSIX_IMPLICITLY;
    }
    private static final int _POSIX_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SOURCE 1
     * }
     */
    public static int _POSIX_SOURCE() {
        return _POSIX_SOURCE;
    }
    private static final int __USE_POSIX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX 1
     * }
     */
    public static int __USE_POSIX() {
        return __USE_POSIX;
    }
    private static final int __USE_POSIX2 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX2 1
     * }
     */
    public static int __USE_POSIX2() {
        return __USE_POSIX2;
    }
    private static final int __USE_POSIX199309 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199309 1
     * }
     */
    public static int __USE_POSIX199309() {
        return __USE_POSIX199309;
    }
    private static final int __USE_POSIX199506 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199506 1
     * }
     */
    public static int __USE_POSIX199506() {
        return __USE_POSIX199506;
    }
    private static final int __USE_XOPEN2K = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K 1
     * }
     */
    public static int __USE_XOPEN2K() {
        return __USE_XOPEN2K;
    }
    private static final int __USE_XOPEN2K8 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K8 1
     * }
     */
    public static int __USE_XOPEN2K8() {
        return __USE_XOPEN2K8;
    }
    private static final int _ATFILE_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ATFILE_SOURCE 1
     * }
     */
    public static int _ATFILE_SOURCE() {
        return _ATFILE_SOURCE;
    }
    private static final int __WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE 64
     * }
     */
    public static int __WORDSIZE() {
        return __WORDSIZE;
    }
    private static final int __WORDSIZE_TIME64_COMPAT32 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE_TIME64_COMPAT32 1
     * }
     */
    public static int __WORDSIZE_TIME64_COMPAT32() {
        return __WORDSIZE_TIME64_COMPAT32;
    }
    private static final int __SYSCALL_WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __SYSCALL_WORDSIZE 64
     * }
     */
    public static int __SYSCALL_WORDSIZE() {
        return __SYSCALL_WORDSIZE;
    }
    private static final int __USE_MISC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_MISC 1
     * }
     */
    public static int __USE_MISC() {
        return __USE_MISC;
    }
    private static final int __USE_ATFILE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ATFILE 1
     * }
     */
    public static int __USE_ATFILE() {
        return __USE_ATFILE;
    }
    private static final int __USE_FORTIFY_LEVEL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __USE_FORTIFY_LEVEL 0
     * }
     */
    public static int __USE_FORTIFY_LEVEL() {
        return __USE_FORTIFY_LEVEL;
    }
    private static final int __GLIBC_USE_DEPRECATED_GETS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_DEPRECATED_GETS 0
     * }
     */
    public static int __GLIBC_USE_DEPRECATED_GETS() {
        return __GLIBC_USE_DEPRECATED_GETS;
    }
    private static final int __GLIBC_USE_DEPRECATED_SCANF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_DEPRECATED_SCANF 0
     * }
     */
    public static int __GLIBC_USE_DEPRECATED_SCANF() {
        return __GLIBC_USE_DEPRECATED_SCANF;
    }
    private static final int __GLIBC_USE_C2X_STRTOL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_C2X_STRTOL 0
     * }
     */
    public static int __GLIBC_USE_C2X_STRTOL() {
        return __GLIBC_USE_C2X_STRTOL;
    }
    private static final int _STDC_PREDEF_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDC_PREDEF_H 1
     * }
     */
    public static int _STDC_PREDEF_H() {
        return _STDC_PREDEF_H;
    }
    private static final int __STDC_IEC_559__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559__ 1
     * }
     */
    public static int __STDC_IEC_559__() {
        return __STDC_IEC_559__;
    }
    private static final int __STDC_IEC_559_COMPLEX__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559_COMPLEX__ 1
     * }
     */
    public static int __STDC_IEC_559_COMPLEX__() {
        return __STDC_IEC_559_COMPLEX__;
    }
    private static final int __GNU_LIBRARY__ = (int)6L;
    /**
     * {@snippet lang=c :
     * #define __GNU_LIBRARY__ 6
     * }
     */
    public static int __GNU_LIBRARY__() {
        return __GNU_LIBRARY__;
    }
    private static final int __GLIBC__ = (int)2L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC__ 2
     * }
     */
    public static int __GLIBC__() {
        return __GLIBC__;
    }
    private static final int __GLIBC_MINOR__ = (int)39L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_MINOR__ 39
     * }
     */
    public static int __GLIBC_MINOR__() {
        return __GLIBC_MINOR__;
    }
    private static final int _SYS_CDEFS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_CDEFS_H 1
     * }
     */
    public static int _SYS_CDEFS_H() {
        return _SYS_CDEFS_H;
    }
    private static final int __glibc_c99_flexarr_available = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __glibc_c99_flexarr_available 1
     * }
     */
    public static int __glibc_c99_flexarr_available() {
        return __glibc_c99_flexarr_available;
    }
    private static final int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI 0
     * }
     */
    public static int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI() {
        return __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI;
    }
    private static final int __HAVE_GENERIC_SELECTION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_GENERIC_SELECTION 1
     * }
     */
    public static int __HAVE_GENERIC_SELECTION() {
        return __HAVE_GENERIC_SELECTION;
    }
    private static final int __GLIBC_USE_LIB_EXT2 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_LIB_EXT2 0
     * }
     */
    public static int __GLIBC_USE_LIB_EXT2() {
        return __GLIBC_USE_LIB_EXT2;
    }
    private static final int __GLIBC_USE_IEC_60559_BFP_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_BFP_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_BFP_EXT() {
        return __GLIBC_USE_IEC_60559_BFP_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_BFP_EXT_C2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_BFP_EXT_C2X 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_BFP_EXT_C2X() {
        return __GLIBC_USE_IEC_60559_BFP_EXT_C2X;
    }
    private static final int __GLIBC_USE_IEC_60559_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_EXT() {
        return __GLIBC_USE_IEC_60559_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_FUNCS_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_FUNCS_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_FUNCS_EXT() {
        return __GLIBC_USE_IEC_60559_FUNCS_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X() {
        return __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X;
    }
    private static final int __GLIBC_USE_IEC_60559_TYPES_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_TYPES_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_TYPES_EXT() {
        return __GLIBC_USE_IEC_60559_TYPES_EXT;
    }
    private static final int _BITS_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES_H 1
     * }
     */
    public static int _BITS_TYPES_H() {
        return _BITS_TYPES_H;
    }
    private static final int _BITS_TYPESIZES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPESIZES_H 1
     * }
     */
    public static int _BITS_TYPESIZES_H() {
        return _BITS_TYPESIZES_H;
    }
    private static final int __OFF_T_MATCHES_OFF64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __OFF_T_MATCHES_OFF64_T 1
     * }
     */
    public static int __OFF_T_MATCHES_OFF64_T() {
        return __OFF_T_MATCHES_OFF64_T;
    }
    private static final int __INO_T_MATCHES_INO64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __INO_T_MATCHES_INO64_T 1
     * }
     */
    public static int __INO_T_MATCHES_INO64_T() {
        return __INO_T_MATCHES_INO64_T;
    }
    private static final int __RLIM_T_MATCHES_RLIM64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __RLIM_T_MATCHES_RLIM64_T 1
     * }
     */
    public static int __RLIM_T_MATCHES_RLIM64_T() {
        return __RLIM_T_MATCHES_RLIM64_T;
    }
    private static final int __STATFS_MATCHES_STATFS64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STATFS_MATCHES_STATFS64 1
     * }
     */
    public static int __STATFS_MATCHES_STATFS64() {
        return __STATFS_MATCHES_STATFS64;
    }
    private static final int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 1
     * }
     */
    public static int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64() {
        return __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64;
    }
    private static final int __FD_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define __FD_SETSIZE 1024
     * }
     */
    public static int __FD_SETSIZE() {
        return __FD_SETSIZE;
    }
    private static final int _BITS_TIME64_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TIME64_H 1
     * }
     */
    public static int _BITS_TIME64_H() {
        return _BITS_TIME64_H;
    }
    private static final int _BITS_WCHAR_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_WCHAR_H 1
     * }
     */
    public static int _BITS_WCHAR_H() {
        return _BITS_WCHAR_H;
    }
    private static final int _BITS_STDINT_INTN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDINT_INTN_H 1
     * }
     */
    public static int _BITS_STDINT_INTN_H() {
        return _BITS_STDINT_INTN_H;
    }
    private static final int _BITS_STDINT_UINTN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDINT_UINTN_H 1
     * }
     */
    public static int _BITS_STDINT_UINTN_H() {
        return _BITS_STDINT_UINTN_H;
    }
    private static final int _BITS_STDINT_LEAST_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDINT_LEAST_H 1
     * }
     */
    public static int _BITS_STDINT_LEAST_H() {
        return _BITS_STDINT_LEAST_H;
    }
    private static final int _STDIO_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDIO_H 1
     * }
     */
    public static int _STDIO_H() {
        return _STDIO_H;
    }
    private static final int __GNUC_VA_LIST = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __GNUC_VA_LIST 1
     * }
     */
    public static int __GNUC_VA_LIST() {
        return __GNUC_VA_LIST;
    }
    private static final int _____fpos_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _____fpos_t_defined 1
     * }
     */
    public static int _____fpos_t_defined() {
        return _____fpos_t_defined;
    }
    private static final int ____mbstate_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ____mbstate_t_defined 1
     * }
     */
    public static int ____mbstate_t_defined() {
        return ____mbstate_t_defined;
    }
    private static final int _____fpos64_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _____fpos64_t_defined 1
     * }
     */
    public static int _____fpos64_t_defined() {
        return _____fpos64_t_defined;
    }
    private static final int ____FILE_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ____FILE_defined 1
     * }
     */
    public static int ____FILE_defined() {
        return ____FILE_defined;
    }
    private static final int __FILE_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __FILE_defined 1
     * }
     */
    public static int __FILE_defined() {
        return __FILE_defined;
    }
    private static final int __struct_FILE_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __struct_FILE_defined 1
     * }
     */
    public static int __struct_FILE_defined() {
        return __struct_FILE_defined;
    }
    private static final int _IO_EOF_SEEN = (int)16L;
    /**
     * {@snippet lang=c :
     * #define _IO_EOF_SEEN 16
     * }
     */
    public static int _IO_EOF_SEEN() {
        return _IO_EOF_SEEN;
    }
    private static final int _IO_ERR_SEEN = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _IO_ERR_SEEN 32
     * }
     */
    public static int _IO_ERR_SEEN() {
        return _IO_ERR_SEEN;
    }
    private static final int _IO_USER_LOCK = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define _IO_USER_LOCK 32768
     * }
     */
    public static int _IO_USER_LOCK() {
        return _IO_USER_LOCK;
    }
    private static final int __cookie_io_functions_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __cookie_io_functions_t_defined 1
     * }
     */
    public static int __cookie_io_functions_t_defined() {
        return __cookie_io_functions_t_defined;
    }
    private static final int _IOFBF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _IOFBF 0
     * }
     */
    public static int _IOFBF() {
        return _IOFBF;
    }
    private static final int _IOLBF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _IOLBF 1
     * }
     */
    public static int _IOLBF() {
        return _IOLBF;
    }
    private static final int _IONBF = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _IONBF 2
     * }
     */
    public static int _IONBF() {
        return _IONBF;
    }
    private static final int BUFSIZ = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define BUFSIZ 8192
     * }
     */
    public static int BUFSIZ() {
        return BUFSIZ;
    }
    private static final int SEEK_SET = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SEEK_SET 0
     * }
     */
    public static int SEEK_SET() {
        return SEEK_SET;
    }
    private static final int SEEK_CUR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SEEK_CUR 1
     * }
     */
    public static int SEEK_CUR() {
        return SEEK_CUR;
    }
    private static final int SEEK_END = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SEEK_END 2
     * }
     */
    public static int SEEK_END() {
        return SEEK_END;
    }
    private static final int L_tmpnam = (int)20L;
    /**
     * {@snippet lang=c :
     * #define L_tmpnam 20
     * }
     */
    public static int L_tmpnam() {
        return L_tmpnam;
    }
    private static final int TMP_MAX = (int)238328L;
    /**
     * {@snippet lang=c :
     * #define TMP_MAX 238328
     * }
     */
    public static int TMP_MAX() {
        return TMP_MAX;
    }
    private static final int _BITS_STDIO_LIM_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDIO_LIM_H 1
     * }
     */
    public static int _BITS_STDIO_LIM_H() {
        return _BITS_STDIO_LIM_H;
    }
    private static final int FILENAME_MAX = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define FILENAME_MAX 4096
     * }
     */
    public static int FILENAME_MAX() {
        return FILENAME_MAX;
    }
    private static final int L_ctermid = (int)9L;
    /**
     * {@snippet lang=c :
     * #define L_ctermid 9
     * }
     */
    public static int L_ctermid() {
        return L_ctermid;
    }
    private static final int FOPEN_MAX = (int)16L;
    /**
     * {@snippet lang=c :
     * #define FOPEN_MAX 16
     * }
     */
    public static int FOPEN_MAX() {
        return FOPEN_MAX;
    }
    private static final int __HAVE_FLOAT128 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT128 0
     * }
     */
    public static int __HAVE_FLOAT128() {
        return __HAVE_FLOAT128;
    }
    private static final int __HAVE_DISTINCT_FLOAT128 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT128 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT128() {
        return __HAVE_DISTINCT_FLOAT128;
    }
    private static final int __HAVE_FLOAT64X = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64X 1
     * }
     */
    public static int __HAVE_FLOAT64X() {
        return __HAVE_FLOAT64X;
    }
    private static final int __HAVE_FLOAT64X_LONG_DOUBLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64X_LONG_DOUBLE 1
     * }
     */
    public static int __HAVE_FLOAT64X_LONG_DOUBLE() {
        return __HAVE_FLOAT64X_LONG_DOUBLE;
    }
    private static final int __HAVE_FLOAT16 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT16 0
     * }
     */
    public static int __HAVE_FLOAT16() {
        return __HAVE_FLOAT16;
    }
    private static final int __HAVE_FLOAT32 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT32 1
     * }
     */
    public static int __HAVE_FLOAT32() {
        return __HAVE_FLOAT32;
    }
    private static final int __HAVE_FLOAT64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64 1
     * }
     */
    public static int __HAVE_FLOAT64() {
        return __HAVE_FLOAT64;
    }
    private static final int __HAVE_FLOAT32X = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT32X 1
     * }
     */
    public static int __HAVE_FLOAT32X() {
        return __HAVE_FLOAT32X;
    }
    private static final int __HAVE_FLOAT128X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT128X 0
     * }
     */
    public static int __HAVE_FLOAT128X() {
        return __HAVE_FLOAT128X;
    }
    private static final int __HAVE_DISTINCT_FLOAT32 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT32 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT32() {
        return __HAVE_DISTINCT_FLOAT32;
    }
    private static final int __HAVE_DISTINCT_FLOAT64 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT64 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT64() {
        return __HAVE_DISTINCT_FLOAT64;
    }
    private static final int __HAVE_DISTINCT_FLOAT32X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT32X 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT32X() {
        return __HAVE_DISTINCT_FLOAT32X;
    }
    private static final int __HAVE_DISTINCT_FLOAT64X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT64X 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT64X() {
        return __HAVE_DISTINCT_FLOAT64X;
    }
    private static final int __HAVE_FLOATN_NOT_TYPEDEF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOATN_NOT_TYPEDEF 0
     * }
     */
    public static int __HAVE_FLOATN_NOT_TYPEDEF() {
        return __HAVE_FLOATN_NOT_TYPEDEF;
    }
    private static final int GGML_FILE_MAGIC = (int)1734831468L;
    /**
     * {@snippet lang=c :
     * #define GGML_FILE_MAGIC 1734831468
     * }
     */
    public static int GGML_FILE_MAGIC() {
        return GGML_FILE_MAGIC;
    }
    private static final int GGML_FILE_VERSION = (int)2L;
    /**
     * {@snippet lang=c :
     * #define GGML_FILE_VERSION 2
     * }
     */
    public static int GGML_FILE_VERSION() {
        return GGML_FILE_VERSION;
    }
    private static final int GGML_QNT_VERSION = (int)2L;
    /**
     * {@snippet lang=c :
     * #define GGML_QNT_VERSION 2
     * }
     */
    public static int GGML_QNT_VERSION() {
        return GGML_QNT_VERSION;
    }
    private static final int GGML_QNT_VERSION_FACTOR = (int)1000L;
    /**
     * {@snippet lang=c :
     * #define GGML_QNT_VERSION_FACTOR 1000
     * }
     */
    public static int GGML_QNT_VERSION_FACTOR() {
        return GGML_QNT_VERSION_FACTOR;
    }
    private static final int GGML_MAX_DIMS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define GGML_MAX_DIMS 4
     * }
     */
    public static int GGML_MAX_DIMS() {
        return GGML_MAX_DIMS;
    }
    private static final int GGML_MAX_PARAMS = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define GGML_MAX_PARAMS 2048
     * }
     */
    public static int GGML_MAX_PARAMS() {
        return GGML_MAX_PARAMS;
    }
    private static final int GGML_MAX_SRC = (int)10L;
    /**
     * {@snippet lang=c :
     * #define GGML_MAX_SRC 10
     * }
     */
    public static int GGML_MAX_SRC() {
        return GGML_MAX_SRC;
    }
    private static final int GGML_MAX_N_THREADS = (int)512L;
    /**
     * {@snippet lang=c :
     * #define GGML_MAX_N_THREADS 512
     * }
     */
    public static int GGML_MAX_N_THREADS() {
        return GGML_MAX_N_THREADS;
    }
    private static final int GGML_MAX_OP_PARAMS = (int)64L;
    /**
     * {@snippet lang=c :
     * #define GGML_MAX_OP_PARAMS 64
     * }
     */
    public static int GGML_MAX_OP_PARAMS() {
        return GGML_MAX_OP_PARAMS;
    }
    private static final int GGML_MAX_NAME = (int)64L;
    /**
     * {@snippet lang=c :
     * #define GGML_MAX_NAME 64
     * }
     */
    public static int GGML_MAX_NAME() {
        return GGML_MAX_NAME;
    }
    private static final int GGML_DEFAULT_N_THREADS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define GGML_DEFAULT_N_THREADS 4
     * }
     */
    public static int GGML_DEFAULT_N_THREADS() {
        return GGML_DEFAULT_N_THREADS;
    }
    private static final int GGML_DEFAULT_GRAPH_SIZE = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define GGML_DEFAULT_GRAPH_SIZE 2048
     * }
     */
    public static int GGML_DEFAULT_GRAPH_SIZE() {
        return GGML_DEFAULT_GRAPH_SIZE;
    }
    private static final int GGML_MEM_ALIGN = (int)16L;
    /**
     * {@snippet lang=c :
     * #define GGML_MEM_ALIGN 16
     * }
     */
    public static int GGML_MEM_ALIGN() {
        return GGML_MEM_ALIGN;
    }
    private static final int GGML_EXIT_SUCCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define GGML_EXIT_SUCCESS 0
     * }
     */
    public static int GGML_EXIT_SUCCESS() {
        return GGML_EXIT_SUCCESS;
    }
    private static final int GGML_EXIT_ABORTED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define GGML_EXIT_ABORTED 1
     * }
     */
    public static int GGML_EXIT_ABORTED() {
        return GGML_EXIT_ABORTED;
    }
    private static final int GGML_ROPE_TYPE_NEOX = (int)2L;
    /**
     * {@snippet lang=c :
     * #define GGML_ROPE_TYPE_NEOX 2
     * }
     */
    public static int GGML_ROPE_TYPE_NEOX() {
        return GGML_ROPE_TYPE_NEOX;
    }
    private static final int GGML_ROPE_TYPE_MROPE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define GGML_ROPE_TYPE_MROPE 8
     * }
     */
    public static int GGML_ROPE_TYPE_MROPE() {
        return GGML_ROPE_TYPE_MROPE;
    }
    private static final int GGML_ROPE_TYPE_VISION = (int)24L;
    /**
     * {@snippet lang=c :
     * #define GGML_ROPE_TYPE_VISION 24
     * }
     */
    public static int GGML_ROPE_TYPE_VISION() {
        return GGML_ROPE_TYPE_VISION;
    }
    private static final int GGML_MROPE_SECTIONS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define GGML_MROPE_SECTIONS 4
     * }
     */
    public static int GGML_MROPE_SECTIONS() {
        return GGML_MROPE_SECTIONS;
    }
    private static final int GGML_KQ_MASK_PAD = (int)64L;
    /**
     * {@snippet lang=c :
     * #define GGML_KQ_MASK_PAD 64
     * }
     */
    public static int GGML_KQ_MASK_PAD() {
        return GGML_KQ_MASK_PAD;
    }
    private static final int WHISPER_SAMPLE_RATE = (int)16000L;
    /**
     * {@snippet lang=c :
     * #define WHISPER_SAMPLE_RATE 16000
     * }
     */
    public static int WHISPER_SAMPLE_RATE() {
        return WHISPER_SAMPLE_RATE;
    }
    private static final int WHISPER_N_FFT = (int)400L;
    /**
     * {@snippet lang=c :
     * #define WHISPER_N_FFT 400
     * }
     */
    public static int WHISPER_N_FFT() {
        return WHISPER_N_FFT;
    }
    private static final int WHISPER_HOP_LENGTH = (int)160L;
    /**
     * {@snippet lang=c :
     * #define WHISPER_HOP_LENGTH 160
     * }
     */
    public static int WHISPER_HOP_LENGTH() {
        return WHISPER_HOP_LENGTH;
    }
    private static final int WHISPER_CHUNK_SIZE = (int)30L;
    /**
     * {@snippet lang=c :
     * #define WHISPER_CHUNK_SIZE 30
     * }
     */
    public static int WHISPER_CHUNK_SIZE() {
        return WHISPER_CHUNK_SIZE;
    }
    /**
     * {@snippet lang=c :
     * typedef long ptrdiff_t
     * }
     */
    public static final OfLong ptrdiff_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long size_t
     * }
     */
    public static final OfLong size_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int wchar_t
     * }
     */
    public static final OfInt wchar_t = WhisperCpp.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __u_char
     * }
     */
    public static final OfByte __u_char = WhisperCpp.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __u_short
     * }
     */
    public static final OfShort __u_short = WhisperCpp.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __u_int
     * }
     */
    public static final OfInt __u_int = WhisperCpp.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_long
     * }
     */
    public static final OfLong __u_long = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char __int8_t
     * }
     */
    public static final OfByte __int8_t = WhisperCpp.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __uint8_t
     * }
     */
    public static final OfByte __uint8_t = WhisperCpp.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short __int16_t
     * }
     */
    public static final OfShort __int16_t = WhisperCpp.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __uint16_t
     * }
     */
    public static final OfShort __uint16_t = WhisperCpp.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int __int32_t
     * }
     */
    public static final OfInt __int32_t = WhisperCpp.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uint32_t
     * }
     */
    public static final OfInt __uint32_t = WhisperCpp.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __int64_t
     * }
     */
    public static final OfLong __int64_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uint64_t
     * }
     */
    public static final OfLong __uint64_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int8_t __int_least8_t
     * }
     */
    public static final OfByte __int_least8_t = WhisperCpp.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t __uint_least8_t
     * }
     */
    public static final OfByte __uint_least8_t = WhisperCpp.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t __int_least16_t
     * }
     */
    public static final OfShort __int_least16_t = WhisperCpp.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t __uint_least16_t
     * }
     */
    public static final OfShort __uint_least16_t = WhisperCpp.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __int_least32_t
     * }
     */
    public static final OfInt __int_least32_t = WhisperCpp.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __uint_least32_t
     * }
     */
    public static final OfInt __uint_least32_t = WhisperCpp.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __int_least64_t
     * }
     */
    public static final OfLong __int_least64_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t __uint_least64_t
     * }
     */
    public static final OfLong __uint_least64_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __quad_t
     * }
     */
    public static final OfLong __quad_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_quad_t
     * }
     */
    public static final OfLong __u_quad_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __intmax_t
     * }
     */
    public static final OfLong __intmax_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uintmax_t
     * }
     */
    public static final OfLong __uintmax_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __dev_t
     * }
     */
    public static final OfLong __dev_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uid_t
     * }
     */
    public static final OfInt __uid_t = WhisperCpp.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __gid_t
     * }
     */
    public static final OfInt __gid_t = WhisperCpp.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino_t
     * }
     */
    public static final OfLong __ino_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino64_t
     * }
     */
    public static final OfLong __ino64_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __mode_t
     * }
     */
    public static final OfInt __mode_t = WhisperCpp.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __nlink_t
     * }
     */
    public static final OfLong __nlink_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off_t
     * }
     */
    public static final OfLong __off_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off64_t
     * }
     */
    public static final OfLong __off64_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __pid_t
     * }
     */
    public static final OfInt __pid_t = WhisperCpp.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __clock_t
     * }
     */
    public static final OfLong __clock_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim_t
     * }
     */
    public static final OfLong __rlim_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim64_t
     * }
     */
    public static final OfLong __rlim64_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __id_t
     * }
     */
    public static final OfInt __id_t = WhisperCpp.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __time_t
     * }
     */
    public static final OfLong __time_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __useconds_t
     * }
     */
    public static final OfInt __useconds_t = WhisperCpp.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds_t
     * }
     */
    public static final OfLong __suseconds_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds64_t
     * }
     */
    public static final OfLong __suseconds64_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __daddr_t
     * }
     */
    public static final OfInt __daddr_t = WhisperCpp.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __key_t
     * }
     */
    public static final OfInt __key_t = WhisperCpp.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __clockid_t
     * }
     */
    public static final OfInt __clockid_t = WhisperCpp.C_INT;
    /**
     * {@snippet lang=c :
     * typedef void *__timer_t
     * }
     */
    public static final AddressLayout __timer_t = WhisperCpp.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __blksize_t
     * }
     */
    public static final OfLong __blksize_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt_t
     * }
     */
    public static final OfLong __blkcnt_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt64_t
     * }
     */
    public static final OfLong __blkcnt64_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt_t
     * }
     */
    public static final OfLong __fsblkcnt_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt64_t
     * }
     */
    public static final OfLong __fsblkcnt64_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt_t
     * }
     */
    public static final OfLong __fsfilcnt_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt64_t
     * }
     */
    public static final OfLong __fsfilcnt64_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fsword_t
     * }
     */
    public static final OfLong __fsword_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __ssize_t
     * }
     */
    public static final OfLong __ssize_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __syscall_slong_t
     * }
     */
    public static final OfLong __syscall_slong_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __syscall_ulong_t
     * }
     */
    public static final OfLong __syscall_ulong_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __off64_t __loff_t
     * }
     */
    public static final OfLong __loff_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef char *__caddr_t
     * }
     */
    public static final AddressLayout __caddr_t = WhisperCpp.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __intptr_t
     * }
     */
    public static final OfLong __intptr_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __socklen_t
     * }
     */
    public static final OfInt __socklen_t = WhisperCpp.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __sig_atomic_t
     * }
     */
    public static final OfInt __sig_atomic_t = WhisperCpp.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int8_t int8_t
     * }
     */
    public static final OfByte int8_t = WhisperCpp.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t int16_t
     * }
     */
    public static final OfShort int16_t = WhisperCpp.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t int32_t
     * }
     */
    public static final OfInt int32_t = WhisperCpp.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t int64_t
     * }
     */
    public static final OfLong int64_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t uint8_t
     * }
     */
    public static final OfByte uint8_t = WhisperCpp.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t uint16_t
     * }
     */
    public static final OfShort uint16_t = WhisperCpp.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t uint32_t
     * }
     */
    public static final OfInt uint32_t = WhisperCpp.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t uint64_t
     * }
     */
    public static final OfLong uint64_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int_least8_t int_least8_t
     * }
     */
    public static final OfByte int_least8_t = WhisperCpp.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int_least16_t int_least16_t
     * }
     */
    public static final OfShort int_least16_t = WhisperCpp.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int_least32_t int_least32_t
     * }
     */
    public static final OfInt int_least32_t = WhisperCpp.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int_least64_t int_least64_t
     * }
     */
    public static final OfLong int_least64_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint_least8_t uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = WhisperCpp.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint_least16_t uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = WhisperCpp.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least32_t uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = WhisperCpp.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least64_t uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = WhisperCpp.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef long int_fast16_t
     * }
     */
    public static final OfLong int_fast16_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast32_t
     * }
     */
    public static final OfLong int_fast32_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = WhisperCpp.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast16_t
     * }
     */
    public static final OfLong uint_fast16_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast32_t
     * }
     */
    public static final OfLong uint_fast32_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long intptr_t
     * }
     */
    public static final OfLong intptr_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __intmax_t intmax_t
     * }
     */
    public static final OfLong intmax_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uintmax_t uintmax_t
     * }
     */
    public static final OfLong uintmax_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __off_t off_t
     * }
     */
    public static final OfLong off_t = WhisperCpp.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __ssize_t ssize_t
     * }
     */
    public static final OfLong ssize_t = WhisperCpp.C_LONG;

    private static class stdin$constants {
        public static final AddressLayout LAYOUT = WhisperCpp.C_POINTER;
        public static final MemorySegment SEGMENT = WhisperCpp.findOrThrow("stdin").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static AddressLayout stdin$layout() {
        return stdin$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static MemorySegment stdin$segment() {
        return stdin$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static MemorySegment stdin() {
        return stdin$constants.SEGMENT.get(stdin$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static void stdin(MemorySegment varValue) {
        stdin$constants.SEGMENT.set(stdin$constants.LAYOUT, 0L, varValue);
    }

    private static class stdout$constants {
        public static final AddressLayout LAYOUT = WhisperCpp.C_POINTER;
        public static final MemorySegment SEGMENT = WhisperCpp.findOrThrow("stdout").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static AddressLayout stdout$layout() {
        return stdout$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static MemorySegment stdout$segment() {
        return stdout$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static MemorySegment stdout() {
        return stdout$constants.SEGMENT.get(stdout$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static void stdout(MemorySegment varValue) {
        stdout$constants.SEGMENT.set(stdout$constants.LAYOUT, 0L, varValue);
    }

    private static class stderr$constants {
        public static final AddressLayout LAYOUT = WhisperCpp.C_POINTER;
        public static final MemorySegment SEGMENT = WhisperCpp.findOrThrow("stderr").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static AddressLayout stderr$layout() {
        return stderr$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static MemorySegment stderr$segment() {
        return stderr$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static MemorySegment stderr() {
        return stderr$constants.SEGMENT.get(stderr$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static void stderr(MemorySegment varValue) {
        stderr$constants.SEGMENT.set(stderr$constants.LAYOUT, 0L, varValue);
    }

    private static class remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static FunctionDescriptor remove$descriptor() {
        return remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static MethodHandle remove$handle() {
        return remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static MemorySegment remove$address() {
        return remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static int remove(MemorySegment __filename) {
        var mh$ = remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remove", __filename);
            }
            return (int)mh$.invokeExact(__filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("rename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static FunctionDescriptor rename$descriptor() {
        return rename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static MethodHandle rename$handle() {
        return rename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static MemorySegment rename$address() {
        return rename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static int rename(MemorySegment __old, MemorySegment __new) {
        var mh$ = rename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rename", __old, __new);
            }
            return (int)mh$.invokeExact(__old, __new);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class renameat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("renameat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static FunctionDescriptor renameat$descriptor() {
        return renameat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static MethodHandle renameat$handle() {
        return renameat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static MemorySegment renameat$address() {
        return renameat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static int renameat(int __oldfd, MemorySegment __old, int __newfd, MemorySegment __new) {
        var mh$ = renameat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("renameat", __oldfd, __old, __newfd, __new);
            }
            return (int)mh$.invokeExact(__oldfd, __old, __newfd, __new);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fclose$descriptor() {
        return fclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static MethodHandle fclose$handle() {
        return fclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static MemorySegment fclose$address() {
        return fclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static int fclose(MemorySegment __stream) {
        var mh$ = fclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fclose", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("tmpfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static FunctionDescriptor tmpfile$descriptor() {
        return tmpfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MethodHandle tmpfile$handle() {
        return tmpfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile$address() {
        return tmpfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile() {
        var mh$ = tmpfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpfile");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("tmpnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static FunctionDescriptor tmpnam$descriptor() {
        return tmpnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static MethodHandle tmpnam$handle() {
        return tmpnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static MemorySegment tmpnam$address() {
        return tmpnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static MemorySegment tmpnam(MemorySegment x0) {
        var mh$ = tmpnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("tmpnam_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static FunctionDescriptor tmpnam_r$descriptor() {
        return tmpnam_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static MethodHandle tmpnam_r$handle() {
        return tmpnam_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static MemorySegment tmpnam_r$address() {
        return tmpnam_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static MemorySegment tmpnam_r(MemorySegment __s) {
        var mh$ = tmpnam_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam_r", __s);
            }
            return (MemorySegment)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tempnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("tempnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static FunctionDescriptor tempnam$descriptor() {
        return tempnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MethodHandle tempnam$handle() {
        return tempnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MemorySegment tempnam$address() {
        return tempnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MemorySegment tempnam(MemorySegment __dir, MemorySegment __pfx) {
        var mh$ = tempnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tempnam", __dir, __pfx);
            }
            return (MemorySegment)mh$.invokeExact(__dir, __pfx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fflush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fflush$descriptor() {
        return fflush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static MethodHandle fflush$handle() {
        return fflush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static MemorySegment fflush$address() {
        return fflush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static int fflush(MemorySegment __stream) {
        var mh$ = fflush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fflush_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fflush_unlocked$descriptor() {
        return fflush_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fflush_unlocked$handle() {
        return fflush_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment fflush_unlocked$address() {
        return fflush_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static int fflush_unlocked(MemorySegment __stream) {
        var mh$ = fflush_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static FunctionDescriptor fopen$descriptor() {
        return fopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MethodHandle fopen$handle() {
        return fopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MemorySegment fopen$address() {
        return fopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MemorySegment fopen(MemorySegment __filename, MemorySegment __modes) {
        var mh$ = fopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fopen", __filename, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__filename, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class freopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("freopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor freopen$descriptor() {
        return freopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MethodHandle freopen$handle() {
        return freopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MemorySegment freopen$address() {
        return freopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MemorySegment freopen(MemorySegment __filename, MemorySegment __modes, MemorySegment __stream) {
        var mh$ = freopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("freopen", __filename, __modes, __stream);
            }
            return (MemorySegment)mh$.invokeExact(__filename, __modes, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fdopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static FunctionDescriptor fdopen$descriptor() {
        return fdopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MethodHandle fdopen$handle() {
        return fdopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MemorySegment fdopen$address() {
        return fdopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MemorySegment fdopen(int __fd, MemorySegment __modes) {
        var mh$ = fdopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdopen", __fd, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__fd, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fopencookie {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            _IO_cookie_io_functions_t.layout()
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fopencookie");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fopencookie(void *restrict __magic_cookie, const char *restrict __modes, cookie_io_functions_t __io_funcs)
     * }
     */
    public static FunctionDescriptor fopencookie$descriptor() {
        return fopencookie.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fopencookie(void *restrict __magic_cookie, const char *restrict __modes, cookie_io_functions_t __io_funcs)
     * }
     */
    public static MethodHandle fopencookie$handle() {
        return fopencookie.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fopencookie(void *restrict __magic_cookie, const char *restrict __modes, cookie_io_functions_t __io_funcs)
     * }
     */
    public static MemorySegment fopencookie$address() {
        return fopencookie.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fopencookie(void *restrict __magic_cookie, const char *restrict __modes, cookie_io_functions_t __io_funcs)
     * }
     */
    public static MemorySegment fopencookie(MemorySegment __magic_cookie, MemorySegment __modes, MemorySegment __io_funcs) {
        var mh$ = fopencookie.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fopencookie", __magic_cookie, __modes, __io_funcs);
            }
            return (MemorySegment)mh$.invokeExact(__magic_cookie, __modes, __io_funcs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmemopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fmemopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static FunctionDescriptor fmemopen$descriptor() {
        return fmemopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MethodHandle fmemopen$handle() {
        return fmemopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MemorySegment fmemopen$address() {
        return fmemopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MemorySegment fmemopen(MemorySegment __s, long __len, MemorySegment __modes) {
        var mh$ = fmemopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmemopen", __s, __len, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__s, __len, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class open_memstream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("open_memstream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static FunctionDescriptor open_memstream$descriptor() {
        return open_memstream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MethodHandle open_memstream$handle() {
        return open_memstream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MemorySegment open_memstream$address() {
        return open_memstream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MemorySegment open_memstream(MemorySegment __bufloc, MemorySegment __sizeloc) {
        var mh$ = open_memstream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("open_memstream", __bufloc, __sizeloc);
            }
            return (MemorySegment)mh$.invokeExact(__bufloc, __sizeloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("setbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static FunctionDescriptor setbuf$descriptor() {
        return setbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static MethodHandle setbuf$handle() {
        return setbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static MemorySegment setbuf$address() {
        return setbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static void setbuf(MemorySegment __stream, MemorySegment __buf) {
        var mh$ = setbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuf", __stream, __buf);
            }
            mh$.invokeExact(__stream, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setvbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("setvbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static FunctionDescriptor setvbuf$descriptor() {
        return setvbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static MethodHandle setvbuf$handle() {
        return setvbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static MemorySegment setvbuf$address() {
        return setvbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static int setvbuf(MemorySegment __stream, MemorySegment __buf, int __modes, long __n) {
        var mh$ = setvbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setvbuf", __stream, __buf, __modes, __n);
            }
            return (int)mh$.invokeExact(__stream, __buf, __modes, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("setbuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static FunctionDescriptor setbuffer$descriptor() {
        return setbuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static MethodHandle setbuffer$handle() {
        return setbuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static MemorySegment setbuffer$address() {
        return setbuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static void setbuffer(MemorySegment __stream, MemorySegment __buf, long __size) {
        var mh$ = setbuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuffer", __stream, __buf, __size);
            }
            mh$.invokeExact(__stream, __buf, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setlinebuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("setlinebuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static FunctionDescriptor setlinebuf$descriptor() {
        return setlinebuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static MethodHandle setlinebuf$handle() {
        return setlinebuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static MemorySegment setlinebuf$address() {
        return setlinebuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static void setlinebuf(MemorySegment __stream) {
        var mh$ = setlinebuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setlinebuf", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int fprintf(FILE *restrict __stream, const char *restrict __format, ...)
     * }
     */
    public static class fprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                WhisperCpp.C_INT,
                WhisperCpp.C_POINTER,
                WhisperCpp.C_POINTER
            );
        private static final MemorySegment ADDR = WhisperCpp.findOrThrow("fprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int fprintf(FILE *restrict __stream, const char *restrict __format, ...)
         * }
         */
        public static fprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __stream, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fprintf", __stream, __format, x2);
                }
                return (int) spreader.invokeExact(__stream, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int printf(const char *restrict __format, ...)
     * }
     */
    public static class printf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                WhisperCpp.C_INT,
                WhisperCpp.C_POINTER
            );
        private static final MemorySegment ADDR = WhisperCpp.findOrThrow("printf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private printf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int printf(const char *restrict __format, ...)
         * }
         */
        public static printf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new printf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("printf", __format, x1);
                }
                return (int) spreader.invokeExact(__format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int sprintf(char *restrict __s, const char *restrict __format, ...)
     * }
     */
    public static class sprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                WhisperCpp.C_INT,
                WhisperCpp.C_POINTER,
                WhisperCpp.C_POINTER
            );
        private static final MemorySegment ADDR = WhisperCpp.findOrThrow("sprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int sprintf(char *restrict __s, const char *restrict __format, ...)
         * }
         */
        public static sprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sprintf", __s, __format, x2);
                }
                return (int) spreader.invokeExact(__s, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vfprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("vfprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vfprintf$descriptor() {
        return vfprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vfprintf$handle() {
        return vfprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vfprintf$address() {
        return vfprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vfprintf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vfprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfprintf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("vprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vprintf$descriptor() {
        return vprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vprintf$handle() {
        return vprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vprintf$address() {
        return vprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vprintf(MemorySegment __format, MemorySegment __arg) {
        var mh$ = vprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vprintf", __format, __arg);
            }
            return (int)mh$.invokeExact(__format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("vsprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsprintf$descriptor() {
        return vsprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsprintf$handle() {
        return vsprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vsprintf$address() {
        return vsprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsprintf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsprintf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int snprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, ...)
     * }
     */
    public static class snprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                WhisperCpp.C_INT,
                WhisperCpp.C_POINTER,
                WhisperCpp.C_LONG,
                WhisperCpp.C_POINTER
            );
        private static final MemorySegment ADDR = WhisperCpp.findOrThrow("snprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private snprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int snprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, ...)
         * }
         */
        public static snprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new snprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, long __maxlen, MemorySegment __format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("snprintf", __s, __maxlen, __format, x3);
                }
                return (int) spreader.invokeExact(__s, __maxlen, __format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vsnprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("vsnprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsnprintf$descriptor() {
        return vsnprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsnprintf$handle() {
        return vsnprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vsnprintf$address() {
        return vsnprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsnprintf(MemorySegment __s, long __maxlen, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsnprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsnprintf", __s, __maxlen, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __maxlen, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vasprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("vasprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vasprintf(char **restrict __ptr, const char *restrict __f, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vasprintf$descriptor() {
        return vasprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vasprintf(char **restrict __ptr, const char *restrict __f, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vasprintf$handle() {
        return vasprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vasprintf(char **restrict __ptr, const char *restrict __f, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vasprintf$address() {
        return vasprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vasprintf(char **restrict __ptr, const char *restrict __f, __gnuc_va_list __arg)
     * }
     */
    public static int vasprintf(MemorySegment __ptr, MemorySegment __f, MemorySegment __arg) {
        var mh$ = vasprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vasprintf", __ptr, __f, __arg);
            }
            return (int)mh$.invokeExact(__ptr, __f, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int __asprintf(char **restrict __ptr, const char *restrict __fmt, ...)
     * }
     */
    public static class __asprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                WhisperCpp.C_INT,
                WhisperCpp.C_POINTER,
                WhisperCpp.C_POINTER
            );
        private static final MemorySegment ADDR = WhisperCpp.findOrThrow("__asprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __asprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int __asprintf(char **restrict __ptr, const char *restrict __fmt, ...)
         * }
         */
        public static __asprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __asprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __ptr, MemorySegment __fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__asprintf", __ptr, __fmt, x2);
                }
                return (int) spreader.invokeExact(__ptr, __fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int asprintf(char **restrict __ptr, const char *restrict __fmt, ...)
     * }
     */
    public static class asprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                WhisperCpp.C_INT,
                WhisperCpp.C_POINTER,
                WhisperCpp.C_POINTER
            );
        private static final MemorySegment ADDR = WhisperCpp.findOrThrow("asprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private asprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int asprintf(char **restrict __ptr, const char *restrict __fmt, ...)
         * }
         */
        public static asprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new asprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __ptr, MemorySegment __fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("asprintf", __ptr, __fmt, x2);
                }
                return (int) spreader.invokeExact(__ptr, __fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vdprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("vdprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vdprintf$descriptor() {
        return vdprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vdprintf$handle() {
        return vdprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vdprintf$address() {
        return vdprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static int vdprintf(int __fd, MemorySegment __fmt, MemorySegment __arg) {
        var mh$ = vdprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vdprintf", __fd, __fmt, __arg);
            }
            return (int)mh$.invokeExact(__fd, __fmt, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int dprintf(int __fd, const char *restrict __fmt, ...)
     * }
     */
    public static class dprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                WhisperCpp.C_INT,
                WhisperCpp.C_INT,
                WhisperCpp.C_POINTER
            );
        private static final MemorySegment ADDR = WhisperCpp.findOrThrow("dprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private dprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int dprintf(int __fd, const char *restrict __fmt, ...)
         * }
         */
        public static dprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new dprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(int __fd, MemorySegment __fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("dprintf", __fd, __fmt, x2);
                }
                return (int) spreader.invokeExact(__fd, __fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int fscanf(FILE *restrict __stream, const char *restrict __format, ...)
     * }
     */
    public static class fscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                WhisperCpp.C_INT,
                WhisperCpp.C_POINTER,
                WhisperCpp.C_POINTER
            );
        private static final MemorySegment ADDR = WhisperCpp.findOrThrow("fscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int fscanf(FILE *restrict __stream, const char *restrict __format, ...)
         * }
         */
        public static fscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __stream, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fscanf", __stream, __format, x2);
                }
                return (int) spreader.invokeExact(__stream, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int scanf(const char *restrict __format, ...)
     * }
     */
    public static class scanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                WhisperCpp.C_INT,
                WhisperCpp.C_POINTER
            );
        private static final MemorySegment ADDR = WhisperCpp.findOrThrow("scanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private scanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int scanf(const char *restrict __format, ...)
         * }
         */
        public static scanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new scanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("scanf", __format, x1);
                }
                return (int) spreader.invokeExact(__format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int sscanf(const char *restrict __s, const char *restrict __format, ...)
     * }
     */
    public static class sscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                WhisperCpp.C_INT,
                WhisperCpp.C_POINTER,
                WhisperCpp.C_POINTER
            );
        private static final MemorySegment ADDR = WhisperCpp.findOrThrow("sscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int sscanf(const char *restrict __s, const char *restrict __format, ...)
         * }
         */
        public static sscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sscanf", __s, __format, x2);
                }
                return (int) spreader.invokeExact(__s, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }
    /**
     * {@snippet lang=c :
     * typedef float _Float32
     * }
     */
    public static final OfFloat _Float32 = WhisperCpp.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef double _Float64
     * }
     */
    public static final OfDouble _Float64 = WhisperCpp.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef double _Float32x
     * }
     */
    public static final OfDouble _Float32x = WhisperCpp.C_DOUBLE;

    private static class vfscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("vfscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vfscanf$descriptor() {
        return vfscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vfscanf$handle() {
        return vfscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vfscanf$address() {
        return vfscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vfscanf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vfscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfscanf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("vscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vscanf$descriptor() {
        return vscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vscanf$handle() {
        return vscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vscanf$address() {
        return vscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vscanf(MemorySegment __format, MemorySegment __arg) {
        var mh$ = vscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vscanf", __format, __arg);
            }
            return (int)mh$.invokeExact(__format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("vsscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsscanf$descriptor() {
        return vsscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsscanf$handle() {
        return vsscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vsscanf$address() {
        return vsscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsscanf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsscanf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fgetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fgetc$descriptor() {
        return fgetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static MethodHandle fgetc$handle() {
        return fgetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static MemorySegment fgetc$address() {
        return fgetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static int fgetc(MemorySegment __stream) {
        var mh$ = fgetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("getc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getc$descriptor() {
        return getc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static MethodHandle getc$handle() {
        return getc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static MemorySegment getc$address() {
        return getc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static int getc(MemorySegment __stream) {
        var mh$ = getc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("getchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static FunctionDescriptor getchar$descriptor() {
        return getchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static MethodHandle getchar$handle() {
        return getchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static MemorySegment getchar$address() {
        return getchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static int getchar() {
        var mh$ = getchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("getc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getc_unlocked$descriptor() {
        return getc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle getc_unlocked$handle() {
        return getc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment getc_unlocked$address() {
        return getc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static int getc_unlocked(MemorySegment __stream) {
        var mh$ = getc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("getchar_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static FunctionDescriptor getchar_unlocked$descriptor() {
        return getchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static MethodHandle getchar_unlocked$handle() {
        return getchar_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static MemorySegment getchar_unlocked$address() {
        return getchar_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static int getchar_unlocked() {
        var mh$ = getchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar_unlocked");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fgetc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fgetc_unlocked$descriptor() {
        return fgetc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fgetc_unlocked$handle() {
        return fgetc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment fgetc_unlocked$address() {
        return fgetc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static int fgetc_unlocked(MemorySegment __stream) {
        var mh$ = fgetc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fputc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor fputc$descriptor() {
        return fputc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle fputc$handle() {
        return fputc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment fputc$address() {
        return fputc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static int fputc(int __c, MemorySegment __stream) {
        var mh$ = fputc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("putc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putc$descriptor() {
        return putc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle putc$handle() {
        return putc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment putc$address() {
        return putc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static int putc(int __c, MemorySegment __stream) {
        var mh$ = putc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("putchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static FunctionDescriptor putchar$descriptor() {
        return putchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static MethodHandle putchar$handle() {
        return putchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static MemorySegment putchar$address() {
        return putchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static int putchar(int __c) {
        var mh$ = putchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar", __c);
            }
            return (int)mh$.invokeExact(__c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fputc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor fputc_unlocked$descriptor() {
        return fputc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle fputc_unlocked$handle() {
        return fputc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment fputc_unlocked$address() {
        return fputc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static int fputc_unlocked(int __c, MemorySegment __stream) {
        var mh$ = fputc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc_unlocked", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("putc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putc_unlocked$descriptor() {
        return putc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle putc_unlocked$handle() {
        return putc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment putc_unlocked$address() {
        return putc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static int putc_unlocked(int __c, MemorySegment __stream) {
        var mh$ = putc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc_unlocked", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("putchar_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static FunctionDescriptor putchar_unlocked$descriptor() {
        return putchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static MethodHandle putchar_unlocked$handle() {
        return putchar_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static MemorySegment putchar_unlocked$address() {
        return putchar_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static int putchar_unlocked(int __c) {
        var mh$ = putchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar_unlocked", __c);
            }
            return (int)mh$.invokeExact(__c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("getw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getw$descriptor() {
        return getw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static MethodHandle getw$handle() {
        return getw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static MemorySegment getw$address() {
        return getw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static int getw(MemorySegment __stream) {
        var mh$ = getw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getw", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("putw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putw$descriptor() {
        return putw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static MethodHandle putw$handle() {
        return putw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static MemorySegment putw$address() {
        return putw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static int putw(int __w, MemorySegment __stream) {
        var mh$ = putw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putw", __w, __stream);
            }
            return (int)mh$.invokeExact(__w, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fgets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fgets$descriptor() {
        return fgets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fgets$handle() {
        return fgets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fgets$address() {
        return fgets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fgets(MemorySegment __s, int __n, MemorySegment __stream) {
        var mh$ = fgets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgets", __s, __n, __stream);
            }
            return (MemorySegment)mh$.invokeExact(__s, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __getdelim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("__getdelim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor __getdelim$descriptor() {
        return __getdelim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MethodHandle __getdelim$handle() {
        return __getdelim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MemorySegment __getdelim$address() {
        return __getdelim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static long __getdelim(MemorySegment __lineptr, MemorySegment __n, int __delimiter, MemorySegment __stream) {
        var mh$ = __getdelim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__getdelim", __lineptr, __n, __delimiter, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __delimiter, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdelim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("getdelim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getdelim$descriptor() {
        return getdelim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getdelim$handle() {
        return getdelim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MemorySegment getdelim$address() {
        return getdelim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static long getdelim(MemorySegment __lineptr, MemorySegment __n, int __delimiter, MemorySegment __stream) {
        var mh$ = getdelim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdelim", __lineptr, __n, __delimiter, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __delimiter, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("getline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getline$descriptor() {
        return getline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getline$handle() {
        return getline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment getline$address() {
        return getline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static long getline(MemorySegment __lineptr, MemorySegment __n, MemorySegment __stream) {
        var mh$ = getline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getline", __lineptr, __n, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fputs$descriptor() {
        return fputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fputs$handle() {
        return fputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fputs$address() {
        return fputs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static int fputs(MemorySegment __s, MemorySegment __stream) {
        var mh$ = fputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputs", __s, __stream);
            }
            return (int)mh$.invokeExact(__s, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class puts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("puts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static FunctionDescriptor puts$descriptor() {
        return puts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static MethodHandle puts$handle() {
        return puts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static MemorySegment puts$address() {
        return puts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static int puts(MemorySegment __s) {
        var mh$ = puts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("puts", __s);
            }
            return (int)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ungetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ungetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor ungetc$descriptor() {
        return ungetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle ungetc$handle() {
        return ungetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment ungetc$address() {
        return ungetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static int ungetc(int __c, MemorySegment __stream) {
        var mh$ = ungetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ungetc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fread$descriptor() {
        return fread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fread$handle() {
        return fread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fread$address() {
        return fread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fread(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fwrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static FunctionDescriptor fwrite$descriptor() {
        return fwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static MethodHandle fwrite$handle() {
        return fwrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static MemorySegment fwrite$address() {
        return fwrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static long fwrite(MemorySegment __ptr, long __size, long __n, MemorySegment __s) {
        var mh$ = fwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite", __ptr, __size, __n, __s);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fread_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fread_unlocked$descriptor() {
        return fread_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fread_unlocked$handle() {
        return fread_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fread_unlocked$address() {
        return fread_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fread_unlocked(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fread_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread_unlocked", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fwrite_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fwrite_unlocked$descriptor() {
        return fwrite_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fwrite_unlocked$handle() {
        return fwrite_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fwrite_unlocked$address() {
        return fwrite_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fwrite_unlocked(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fwrite_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite_unlocked", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fseek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fseek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static FunctionDescriptor fseek$descriptor() {
        return fseek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static MethodHandle fseek$handle() {
        return fseek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static MemorySegment fseek$address() {
        return fseek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static int fseek(MemorySegment __stream, long __off, int __whence) {
        var mh$ = fseek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseek", __stream, __off, __whence);
            }
            return (int)mh$.invokeExact(__stream, __off, __whence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ftell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftell$descriptor() {
        return ftell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static MethodHandle ftell$handle() {
        return ftell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static MemorySegment ftell$address() {
        return ftell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static long ftell(MemorySegment __stream) {
        var mh$ = ftell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftell", __stream);
            }
            return (long)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rewind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("rewind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static FunctionDescriptor rewind$descriptor() {
        return rewind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static MethodHandle rewind$handle() {
        return rewind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static MemorySegment rewind$address() {
        return rewind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static void rewind(MemorySegment __stream) {
        var mh$ = rewind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rewind", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fseeko {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fseeko");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static FunctionDescriptor fseeko$descriptor() {
        return fseeko.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static MethodHandle fseeko$handle() {
        return fseeko.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static MemorySegment fseeko$address() {
        return fseeko.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static int fseeko(MemorySegment __stream, long __off, int __whence) {
        var mh$ = fseeko.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseeko", __stream, __off, __whence);
            }
            return (int)mh$.invokeExact(__stream, __off, __whence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftello {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ftello");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftello$descriptor() {
        return ftello.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static MethodHandle ftello$handle() {
        return ftello.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static MemorySegment ftello$address() {
        return ftello.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static long ftello(MemorySegment __stream) {
        var mh$ = ftello.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftello", __stream);
            }
            return (long)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fgetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static FunctionDescriptor fgetpos$descriptor() {
        return fgetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static MethodHandle fgetpos$handle() {
        return fgetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static MemorySegment fgetpos$address() {
        return fgetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static int fgetpos(MemorySegment __stream, MemorySegment __pos) {
        var mh$ = fgetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetpos", __stream, __pos);
            }
            return (int)mh$.invokeExact(__stream, __pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fsetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static FunctionDescriptor fsetpos$descriptor() {
        return fsetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static MethodHandle fsetpos$handle() {
        return fsetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static MemorySegment fsetpos$address() {
        return fsetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static int fsetpos(MemorySegment __stream, MemorySegment __pos) {
        var mh$ = fsetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsetpos", __stream, __pos);
            }
            return (int)mh$.invokeExact(__stream, __pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearerr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("clearerr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static FunctionDescriptor clearerr$descriptor() {
        return clearerr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static MethodHandle clearerr$handle() {
        return clearerr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static MemorySegment clearerr$address() {
        return clearerr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static void clearerr(MemorySegment __stream) {
        var mh$ = clearerr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("feof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static FunctionDescriptor feof$descriptor() {
        return feof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static MethodHandle feof$handle() {
        return feof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static MemorySegment feof$address() {
        return feof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static int feof(MemorySegment __stream) {
        var mh$ = feof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ferror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ferror$descriptor() {
        return ferror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static MethodHandle ferror$handle() {
        return ferror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static MemorySegment ferror$address() {
        return ferror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static int ferror(MemorySegment __stream) {
        var mh$ = ferror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearerr_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("clearerr_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor clearerr_unlocked$descriptor() {
        return clearerr_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle clearerr_unlocked$handle() {
        return clearerr_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment clearerr_unlocked$address() {
        return clearerr_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static void clearerr_unlocked(MemorySegment __stream) {
        var mh$ = clearerr_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr_unlocked", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("feof_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor feof_unlocked$descriptor() {
        return feof_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle feof_unlocked$handle() {
        return feof_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment feof_unlocked$address() {
        return feof_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static int feof_unlocked(MemorySegment __stream) {
        var mh$ = feof_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ferror_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ferror_unlocked$descriptor() {
        return ferror_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle ferror_unlocked$handle() {
        return ferror_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment ferror_unlocked$address() {
        return ferror_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static int ferror_unlocked(MemorySegment __stream) {
        var mh$ = ferror_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class perror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("perror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static FunctionDescriptor perror$descriptor() {
        return perror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static MethodHandle perror$handle() {
        return perror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static MemorySegment perror$address() {
        return perror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static void perror(MemorySegment __s) {
        var mh$ = perror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("perror", __s);
            }
            mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fileno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fileno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fileno$descriptor() {
        return fileno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static MethodHandle fileno$handle() {
        return fileno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static MemorySegment fileno$address() {
        return fileno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static int fileno(MemorySegment __stream) {
        var mh$ = fileno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fileno_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("fileno_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fileno_unlocked$descriptor() {
        return fileno_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fileno_unlocked$handle() {
        return fileno_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment fileno_unlocked$address() {
        return fileno_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static int fileno_unlocked(MemorySegment __stream) {
        var mh$ = fileno_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("pclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static FunctionDescriptor pclose$descriptor() {
        return pclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static MethodHandle pclose$handle() {
        return pclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static MemorySegment pclose$address() {
        return pclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static int pclose(MemorySegment __stream) {
        var mh$ = pclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pclose", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class popen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("popen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static FunctionDescriptor popen$descriptor() {
        return popen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MethodHandle popen$handle() {
        return popen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MemorySegment popen$address() {
        return popen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MemorySegment popen(MemorySegment __command, MemorySegment __modes) {
        var mh$ = popen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("popen", __command, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__command, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctermid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ctermid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static FunctionDescriptor ctermid$descriptor() {
        return ctermid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MethodHandle ctermid$handle() {
        return ctermid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MemorySegment ctermid$address() {
        return ctermid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MemorySegment ctermid(MemorySegment __s) {
        var mh$ = ctermid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctermid", __s);
            }
            return (MemorySegment)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("flockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor flockfile$descriptor() {
        return flockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static MethodHandle flockfile$handle() {
        return flockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static MemorySegment flockfile$address() {
        return flockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static void flockfile(MemorySegment __stream) {
        var mh$ = flockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flockfile", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftrylockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ftrylockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftrylockfile$descriptor() {
        return ftrylockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static MethodHandle ftrylockfile$handle() {
        return ftrylockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static MemorySegment ftrylockfile$address() {
        return ftrylockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static int ftrylockfile(MemorySegment __stream) {
        var mh$ = ftrylockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftrylockfile", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class funlockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("funlockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor funlockfile$descriptor() {
        return funlockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static MethodHandle funlockfile$handle() {
        return funlockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static MemorySegment funlockfile$address() {
        return funlockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static void funlockfile(MemorySegment __stream) {
        var mh$ = funlockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("funlockfile", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __uflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("__uflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static FunctionDescriptor __uflow$descriptor() {
        return __uflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static MethodHandle __uflow$handle() {
        return __uflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static MemorySegment __uflow$address() {
        return __uflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static int __uflow(MemorySegment x0) {
        var mh$ = __uflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__uflow", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __overflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("__overflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static FunctionDescriptor __overflow$descriptor() {
        return __overflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static MethodHandle __overflow$handle() {
        return __overflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static MemorySegment __overflow$address() {
        return __overflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static int __overflow(MemorySegment x0, int x1) {
        var mh$ = __overflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__overflow", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_abort_callback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set_abort_callback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_abort_callback_t ggml_set_abort_callback(ggml_abort_callback_t callback)
     * }
     */
    public static FunctionDescriptor ggml_set_abort_callback$descriptor() {
        return ggml_set_abort_callback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_abort_callback_t ggml_set_abort_callback(ggml_abort_callback_t callback)
     * }
     */
    public static MethodHandle ggml_set_abort_callback$handle() {
        return ggml_set_abort_callback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_abort_callback_t ggml_set_abort_callback(ggml_abort_callback_t callback)
     * }
     */
    public static MemorySegment ggml_set_abort_callback$address() {
        return ggml_set_abort_callback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_abort_callback_t ggml_set_abort_callback(ggml_abort_callback_t callback)
     * }
     */
    public static MemorySegment ggml_set_abort_callback(MemorySegment callback) {
        var mh$ = ggml_set_abort_callback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_abort_callback", callback);
            }
            return (MemorySegment)mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern void ggml_abort(const char *file, int line, const char *fmt, ...)
     * }
     */
    public static class ggml_abort {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                WhisperCpp.C_POINTER,
                WhisperCpp.C_INT,
                WhisperCpp.C_POINTER
            );
        private static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_abort");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private ggml_abort(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern void ggml_abort(const char *file, int line, const char *fmt, ...)
         * }
         */
        public static ggml_abort makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new ggml_abort(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment file, int line, MemorySegment fmt, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("ggml_abort", file, line, fmt, x3);
                }
                 spreader.invokeExact(file, line, fmt, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }
    private static final int GGML_STATUS_ALLOC_FAILED = (int)-2L;
    /**
     * {@snippet lang=c :
     * enum ggml_status.GGML_STATUS_ALLOC_FAILED = -2
     * }
     */
    public static int GGML_STATUS_ALLOC_FAILED() {
        return GGML_STATUS_ALLOC_FAILED;
    }
    private static final int GGML_STATUS_FAILED = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum ggml_status.GGML_STATUS_FAILED = -1
     * }
     */
    public static int GGML_STATUS_FAILED() {
        return GGML_STATUS_FAILED;
    }
    private static final int GGML_STATUS_SUCCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ggml_status.GGML_STATUS_SUCCESS = 0
     * }
     */
    public static int GGML_STATUS_SUCCESS() {
        return GGML_STATUS_SUCCESS;
    }
    private static final int GGML_STATUS_ABORTED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ggml_status.GGML_STATUS_ABORTED = 1
     * }
     */
    public static int GGML_STATUS_ABORTED() {
        return GGML_STATUS_ABORTED;
    }

    private static class ggml_status_to_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_status_to_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ggml_status_to_string(enum ggml_status status)
     * }
     */
    public static FunctionDescriptor ggml_status_to_string$descriptor() {
        return ggml_status_to_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ggml_status_to_string(enum ggml_status status)
     * }
     */
    public static MethodHandle ggml_status_to_string$handle() {
        return ggml_status_to_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ggml_status_to_string(enum ggml_status status)
     * }
     */
    public static MemorySegment ggml_status_to_string$address() {
        return ggml_status_to_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ggml_status_to_string(enum ggml_status status)
     * }
     */
    public static MemorySegment ggml_status_to_string(int status) {
        var mh$ = ggml_status_to_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_status_to_string", status);
            }
            return (MemorySegment)mh$.invokeExact(status);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef uint16_t ggml_fp16_t
     * }
     */
    public static final OfShort ggml_fp16_t = WhisperCpp.C_SHORT;

    private static class ggml_fp16_to_fp32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_SHORT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_fp16_to_fp32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float ggml_fp16_to_fp32(ggml_fp16_t)
     * }
     */
    public static FunctionDescriptor ggml_fp16_to_fp32$descriptor() {
        return ggml_fp16_to_fp32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float ggml_fp16_to_fp32(ggml_fp16_t)
     * }
     */
    public static MethodHandle ggml_fp16_to_fp32$handle() {
        return ggml_fp16_to_fp32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float ggml_fp16_to_fp32(ggml_fp16_t)
     * }
     */
    public static MemorySegment ggml_fp16_to_fp32$address() {
        return ggml_fp16_to_fp32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float ggml_fp16_to_fp32(ggml_fp16_t)
     * }
     */
    public static float ggml_fp16_to_fp32(short x0) {
        var mh$ = ggml_fp16_to_fp32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_fp16_to_fp32", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_fp32_to_fp16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_SHORT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_fp32_to_fp16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_fp16_t ggml_fp32_to_fp16(float)
     * }
     */
    public static FunctionDescriptor ggml_fp32_to_fp16$descriptor() {
        return ggml_fp32_to_fp16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_fp16_t ggml_fp32_to_fp16(float)
     * }
     */
    public static MethodHandle ggml_fp32_to_fp16$handle() {
        return ggml_fp32_to_fp16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_fp16_t ggml_fp32_to_fp16(float)
     * }
     */
    public static MemorySegment ggml_fp32_to_fp16$address() {
        return ggml_fp32_to_fp16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_fp16_t ggml_fp32_to_fp16(float)
     * }
     */
    public static short ggml_fp32_to_fp16(float x0) {
        var mh$ = ggml_fp32_to_fp16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_fp32_to_fp16", x0);
            }
            return (short)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_fp16_to_fp32_row {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_fp16_to_fp32_row");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_fp16_to_fp32_row(const ggml_fp16_t *, float *, int64_t)
     * }
     */
    public static FunctionDescriptor ggml_fp16_to_fp32_row$descriptor() {
        return ggml_fp16_to_fp32_row.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_fp16_to_fp32_row(const ggml_fp16_t *, float *, int64_t)
     * }
     */
    public static MethodHandle ggml_fp16_to_fp32_row$handle() {
        return ggml_fp16_to_fp32_row.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_fp16_to_fp32_row(const ggml_fp16_t *, float *, int64_t)
     * }
     */
    public static MemorySegment ggml_fp16_to_fp32_row$address() {
        return ggml_fp16_to_fp32_row.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_fp16_to_fp32_row(const ggml_fp16_t *, float *, int64_t)
     * }
     */
    public static void ggml_fp16_to_fp32_row(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = ggml_fp16_to_fp32_row.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_fp16_to_fp32_row", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_fp32_to_fp16_row {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_fp32_to_fp16_row");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_fp32_to_fp16_row(const float *, ggml_fp16_t *, int64_t)
     * }
     */
    public static FunctionDescriptor ggml_fp32_to_fp16_row$descriptor() {
        return ggml_fp32_to_fp16_row.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_fp32_to_fp16_row(const float *, ggml_fp16_t *, int64_t)
     * }
     */
    public static MethodHandle ggml_fp32_to_fp16_row$handle() {
        return ggml_fp32_to_fp16_row.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_fp32_to_fp16_row(const float *, ggml_fp16_t *, int64_t)
     * }
     */
    public static MemorySegment ggml_fp32_to_fp16_row$address() {
        return ggml_fp32_to_fp16_row.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_fp32_to_fp16_row(const float *, ggml_fp16_t *, int64_t)
     * }
     */
    public static void ggml_fp32_to_fp16_row(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = ggml_fp32_to_fp16_row.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_fp32_to_fp16_row", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_fp32_to_bf16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ggml_bf16_t.layout(),
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_fp32_to_bf16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_bf16_t ggml_fp32_to_bf16(float)
     * }
     */
    public static FunctionDescriptor ggml_fp32_to_bf16$descriptor() {
        return ggml_fp32_to_bf16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_bf16_t ggml_fp32_to_bf16(float)
     * }
     */
    public static MethodHandle ggml_fp32_to_bf16$handle() {
        return ggml_fp32_to_bf16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_bf16_t ggml_fp32_to_bf16(float)
     * }
     */
    public static MemorySegment ggml_fp32_to_bf16$address() {
        return ggml_fp32_to_bf16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_bf16_t ggml_fp32_to_bf16(float)
     * }
     */
    public static MemorySegment ggml_fp32_to_bf16(SegmentAllocator allocator, float x0) {
        var mh$ = ggml_fp32_to_bf16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_fp32_to_bf16", allocator, x0);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_bf16_to_fp32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_FLOAT,
            ggml_bf16_t.layout()
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_bf16_to_fp32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float ggml_bf16_to_fp32(ggml_bf16_t)
     * }
     */
    public static FunctionDescriptor ggml_bf16_to_fp32$descriptor() {
        return ggml_bf16_to_fp32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float ggml_bf16_to_fp32(ggml_bf16_t)
     * }
     */
    public static MethodHandle ggml_bf16_to_fp32$handle() {
        return ggml_bf16_to_fp32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float ggml_bf16_to_fp32(ggml_bf16_t)
     * }
     */
    public static MemorySegment ggml_bf16_to_fp32$address() {
        return ggml_bf16_to_fp32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float ggml_bf16_to_fp32(ggml_bf16_t)
     * }
     */
    public static float ggml_bf16_to_fp32(MemorySegment x0) {
        var mh$ = ggml_bf16_to_fp32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_bf16_to_fp32", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_bf16_to_fp32_row {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_bf16_to_fp32_row");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_bf16_to_fp32_row(const ggml_bf16_t *, float *, int64_t)
     * }
     */
    public static FunctionDescriptor ggml_bf16_to_fp32_row$descriptor() {
        return ggml_bf16_to_fp32_row.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_bf16_to_fp32_row(const ggml_bf16_t *, float *, int64_t)
     * }
     */
    public static MethodHandle ggml_bf16_to_fp32_row$handle() {
        return ggml_bf16_to_fp32_row.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_bf16_to_fp32_row(const ggml_bf16_t *, float *, int64_t)
     * }
     */
    public static MemorySegment ggml_bf16_to_fp32_row$address() {
        return ggml_bf16_to_fp32_row.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_bf16_to_fp32_row(const ggml_bf16_t *, float *, int64_t)
     * }
     */
    public static void ggml_bf16_to_fp32_row(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = ggml_bf16_to_fp32_row.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_bf16_to_fp32_row", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_fp32_to_bf16_row_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_fp32_to_bf16_row_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_fp32_to_bf16_row_ref(const float *, ggml_bf16_t *, int64_t)
     * }
     */
    public static FunctionDescriptor ggml_fp32_to_bf16_row_ref$descriptor() {
        return ggml_fp32_to_bf16_row_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_fp32_to_bf16_row_ref(const float *, ggml_bf16_t *, int64_t)
     * }
     */
    public static MethodHandle ggml_fp32_to_bf16_row_ref$handle() {
        return ggml_fp32_to_bf16_row_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_fp32_to_bf16_row_ref(const float *, ggml_bf16_t *, int64_t)
     * }
     */
    public static MemorySegment ggml_fp32_to_bf16_row_ref$address() {
        return ggml_fp32_to_bf16_row_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_fp32_to_bf16_row_ref(const float *, ggml_bf16_t *, int64_t)
     * }
     */
    public static void ggml_fp32_to_bf16_row_ref(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = ggml_fp32_to_bf16_row_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_fp32_to_bf16_row_ref", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_fp32_to_bf16_row {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_fp32_to_bf16_row");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_fp32_to_bf16_row(const float *, ggml_bf16_t *, int64_t)
     * }
     */
    public static FunctionDescriptor ggml_fp32_to_bf16_row$descriptor() {
        return ggml_fp32_to_bf16_row.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_fp32_to_bf16_row(const float *, ggml_bf16_t *, int64_t)
     * }
     */
    public static MethodHandle ggml_fp32_to_bf16_row$handle() {
        return ggml_fp32_to_bf16_row.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_fp32_to_bf16_row(const float *, ggml_bf16_t *, int64_t)
     * }
     */
    public static MemorySegment ggml_fp32_to_bf16_row$address() {
        return ggml_fp32_to_bf16_row.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_fp32_to_bf16_row(const float *, ggml_bf16_t *, int64_t)
     * }
     */
    public static void ggml_fp32_to_bf16_row(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = ggml_fp32_to_bf16_row.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_fp32_to_bf16_row", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GGML_TYPE_F32 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_F32 = 0
     * }
     */
    public static int GGML_TYPE_F32() {
        return GGML_TYPE_F32;
    }
    private static final int GGML_TYPE_F16 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_F16 = 1
     * }
     */
    public static int GGML_TYPE_F16() {
        return GGML_TYPE_F16;
    }
    private static final int GGML_TYPE_Q4_0 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_Q4_0 = 2
     * }
     */
    public static int GGML_TYPE_Q4_0() {
        return GGML_TYPE_Q4_0;
    }
    private static final int GGML_TYPE_Q4_1 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_Q4_1 = 3
     * }
     */
    public static int GGML_TYPE_Q4_1() {
        return GGML_TYPE_Q4_1;
    }
    private static final int GGML_TYPE_Q5_0 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_Q5_0 = 6
     * }
     */
    public static int GGML_TYPE_Q5_0() {
        return GGML_TYPE_Q5_0;
    }
    private static final int GGML_TYPE_Q5_1 = (int)7L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_Q5_1 = 7
     * }
     */
    public static int GGML_TYPE_Q5_1() {
        return GGML_TYPE_Q5_1;
    }
    private static final int GGML_TYPE_Q8_0 = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_Q8_0 = 8
     * }
     */
    public static int GGML_TYPE_Q8_0() {
        return GGML_TYPE_Q8_0;
    }
    private static final int GGML_TYPE_Q8_1 = (int)9L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_Q8_1 = 9
     * }
     */
    public static int GGML_TYPE_Q8_1() {
        return GGML_TYPE_Q8_1;
    }
    private static final int GGML_TYPE_Q2_K = (int)10L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_Q2_K = 10
     * }
     */
    public static int GGML_TYPE_Q2_K() {
        return GGML_TYPE_Q2_K;
    }
    private static final int GGML_TYPE_Q3_K = (int)11L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_Q3_K = 11
     * }
     */
    public static int GGML_TYPE_Q3_K() {
        return GGML_TYPE_Q3_K;
    }
    private static final int GGML_TYPE_Q4_K = (int)12L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_Q4_K = 12
     * }
     */
    public static int GGML_TYPE_Q4_K() {
        return GGML_TYPE_Q4_K;
    }
    private static final int GGML_TYPE_Q5_K = (int)13L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_Q5_K = 13
     * }
     */
    public static int GGML_TYPE_Q5_K() {
        return GGML_TYPE_Q5_K;
    }
    private static final int GGML_TYPE_Q6_K = (int)14L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_Q6_K = 14
     * }
     */
    public static int GGML_TYPE_Q6_K() {
        return GGML_TYPE_Q6_K;
    }
    private static final int GGML_TYPE_Q8_K = (int)15L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_Q8_K = 15
     * }
     */
    public static int GGML_TYPE_Q8_K() {
        return GGML_TYPE_Q8_K;
    }
    private static final int GGML_TYPE_IQ2_XXS = (int)16L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_IQ2_XXS = 16
     * }
     */
    public static int GGML_TYPE_IQ2_XXS() {
        return GGML_TYPE_IQ2_XXS;
    }
    private static final int GGML_TYPE_IQ2_XS = (int)17L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_IQ2_XS = 17
     * }
     */
    public static int GGML_TYPE_IQ2_XS() {
        return GGML_TYPE_IQ2_XS;
    }
    private static final int GGML_TYPE_IQ3_XXS = (int)18L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_IQ3_XXS = 18
     * }
     */
    public static int GGML_TYPE_IQ3_XXS() {
        return GGML_TYPE_IQ3_XXS;
    }
    private static final int GGML_TYPE_IQ1_S = (int)19L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_IQ1_S = 19
     * }
     */
    public static int GGML_TYPE_IQ1_S() {
        return GGML_TYPE_IQ1_S;
    }
    private static final int GGML_TYPE_IQ4_NL = (int)20L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_IQ4_NL = 20
     * }
     */
    public static int GGML_TYPE_IQ4_NL() {
        return GGML_TYPE_IQ4_NL;
    }
    private static final int GGML_TYPE_IQ3_S = (int)21L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_IQ3_S = 21
     * }
     */
    public static int GGML_TYPE_IQ3_S() {
        return GGML_TYPE_IQ3_S;
    }
    private static final int GGML_TYPE_IQ2_S = (int)22L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_IQ2_S = 22
     * }
     */
    public static int GGML_TYPE_IQ2_S() {
        return GGML_TYPE_IQ2_S;
    }
    private static final int GGML_TYPE_IQ4_XS = (int)23L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_IQ4_XS = 23
     * }
     */
    public static int GGML_TYPE_IQ4_XS() {
        return GGML_TYPE_IQ4_XS;
    }
    private static final int GGML_TYPE_I8 = (int)24L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_I8 = 24
     * }
     */
    public static int GGML_TYPE_I8() {
        return GGML_TYPE_I8;
    }
    private static final int GGML_TYPE_I16 = (int)25L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_I16 = 25
     * }
     */
    public static int GGML_TYPE_I16() {
        return GGML_TYPE_I16;
    }
    private static final int GGML_TYPE_I32 = (int)26L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_I32 = 26
     * }
     */
    public static int GGML_TYPE_I32() {
        return GGML_TYPE_I32;
    }
    private static final int GGML_TYPE_I64 = (int)27L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_I64 = 27
     * }
     */
    public static int GGML_TYPE_I64() {
        return GGML_TYPE_I64;
    }
    private static final int GGML_TYPE_F64 = (int)28L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_F64 = 28
     * }
     */
    public static int GGML_TYPE_F64() {
        return GGML_TYPE_F64;
    }
    private static final int GGML_TYPE_IQ1_M = (int)29L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_IQ1_M = 29
     * }
     */
    public static int GGML_TYPE_IQ1_M() {
        return GGML_TYPE_IQ1_M;
    }
    private static final int GGML_TYPE_BF16 = (int)30L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_BF16 = 30
     * }
     */
    public static int GGML_TYPE_BF16() {
        return GGML_TYPE_BF16;
    }
    private static final int GGML_TYPE_TQ1_0 = (int)34L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_TQ1_0 = 34
     * }
     */
    public static int GGML_TYPE_TQ1_0() {
        return GGML_TYPE_TQ1_0;
    }
    private static final int GGML_TYPE_TQ2_0 = (int)35L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_TQ2_0 = 35
     * }
     */
    public static int GGML_TYPE_TQ2_0() {
        return GGML_TYPE_TQ2_0;
    }
    private static final int GGML_TYPE_MXFP4 = (int)39L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_MXFP4 = 39
     * }
     */
    public static int GGML_TYPE_MXFP4() {
        return GGML_TYPE_MXFP4;
    }
    private static final int GGML_TYPE_COUNT = (int)40L;
    /**
     * {@snippet lang=c :
     * enum ggml_type.GGML_TYPE_COUNT = 40
     * }
     */
    public static int GGML_TYPE_COUNT() {
        return GGML_TYPE_COUNT;
    }
    private static final int GGML_PREC_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ggml_prec.GGML_PREC_DEFAULT = 0
     * }
     */
    public static int GGML_PREC_DEFAULT() {
        return GGML_PREC_DEFAULT;
    }
    private static final int GGML_PREC_F32 = (int)10L;
    /**
     * {@snippet lang=c :
     * enum ggml_prec.GGML_PREC_F32 = 10
     * }
     */
    public static int GGML_PREC_F32() {
        return GGML_PREC_F32;
    }
    private static final int GGML_FTYPE_UNKNOWN = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_UNKNOWN = -1
     * }
     */
    public static int GGML_FTYPE_UNKNOWN() {
        return GGML_FTYPE_UNKNOWN;
    }
    private static final int GGML_FTYPE_ALL_F32 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_ALL_F32 = 0
     * }
     */
    public static int GGML_FTYPE_ALL_F32() {
        return GGML_FTYPE_ALL_F32;
    }
    private static final int GGML_FTYPE_MOSTLY_F16 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_F16 = 1
     * }
     */
    public static int GGML_FTYPE_MOSTLY_F16() {
        return GGML_FTYPE_MOSTLY_F16;
    }
    private static final int GGML_FTYPE_MOSTLY_Q4_0 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_Q4_0 = 2
     * }
     */
    public static int GGML_FTYPE_MOSTLY_Q4_0() {
        return GGML_FTYPE_MOSTLY_Q4_0;
    }
    private static final int GGML_FTYPE_MOSTLY_Q4_1 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_Q4_1 = 3
     * }
     */
    public static int GGML_FTYPE_MOSTLY_Q4_1() {
        return GGML_FTYPE_MOSTLY_Q4_1;
    }
    private static final int GGML_FTYPE_MOSTLY_Q4_1_SOME_F16 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_Q4_1_SOME_F16 = 4
     * }
     */
    public static int GGML_FTYPE_MOSTLY_Q4_1_SOME_F16() {
        return GGML_FTYPE_MOSTLY_Q4_1_SOME_F16;
    }
    private static final int GGML_FTYPE_MOSTLY_Q8_0 = (int)7L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_Q8_0 = 7
     * }
     */
    public static int GGML_FTYPE_MOSTLY_Q8_0() {
        return GGML_FTYPE_MOSTLY_Q8_0;
    }
    private static final int GGML_FTYPE_MOSTLY_Q5_0 = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_Q5_0 = 8
     * }
     */
    public static int GGML_FTYPE_MOSTLY_Q5_0() {
        return GGML_FTYPE_MOSTLY_Q5_0;
    }
    private static final int GGML_FTYPE_MOSTLY_Q5_1 = (int)9L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_Q5_1 = 9
     * }
     */
    public static int GGML_FTYPE_MOSTLY_Q5_1() {
        return GGML_FTYPE_MOSTLY_Q5_1;
    }
    private static final int GGML_FTYPE_MOSTLY_Q2_K = (int)10L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_Q2_K = 10
     * }
     */
    public static int GGML_FTYPE_MOSTLY_Q2_K() {
        return GGML_FTYPE_MOSTLY_Q2_K;
    }
    private static final int GGML_FTYPE_MOSTLY_Q3_K = (int)11L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_Q3_K = 11
     * }
     */
    public static int GGML_FTYPE_MOSTLY_Q3_K() {
        return GGML_FTYPE_MOSTLY_Q3_K;
    }
    private static final int GGML_FTYPE_MOSTLY_Q4_K = (int)12L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_Q4_K = 12
     * }
     */
    public static int GGML_FTYPE_MOSTLY_Q4_K() {
        return GGML_FTYPE_MOSTLY_Q4_K;
    }
    private static final int GGML_FTYPE_MOSTLY_Q5_K = (int)13L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_Q5_K = 13
     * }
     */
    public static int GGML_FTYPE_MOSTLY_Q5_K() {
        return GGML_FTYPE_MOSTLY_Q5_K;
    }
    private static final int GGML_FTYPE_MOSTLY_Q6_K = (int)14L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_Q6_K = 14
     * }
     */
    public static int GGML_FTYPE_MOSTLY_Q6_K() {
        return GGML_FTYPE_MOSTLY_Q6_K;
    }
    private static final int GGML_FTYPE_MOSTLY_IQ2_XXS = (int)15L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_IQ2_XXS = 15
     * }
     */
    public static int GGML_FTYPE_MOSTLY_IQ2_XXS() {
        return GGML_FTYPE_MOSTLY_IQ2_XXS;
    }
    private static final int GGML_FTYPE_MOSTLY_IQ2_XS = (int)16L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_IQ2_XS = 16
     * }
     */
    public static int GGML_FTYPE_MOSTLY_IQ2_XS() {
        return GGML_FTYPE_MOSTLY_IQ2_XS;
    }
    private static final int GGML_FTYPE_MOSTLY_IQ3_XXS = (int)17L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_IQ3_XXS = 17
     * }
     */
    public static int GGML_FTYPE_MOSTLY_IQ3_XXS() {
        return GGML_FTYPE_MOSTLY_IQ3_XXS;
    }
    private static final int GGML_FTYPE_MOSTLY_IQ1_S = (int)18L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_IQ1_S = 18
     * }
     */
    public static int GGML_FTYPE_MOSTLY_IQ1_S() {
        return GGML_FTYPE_MOSTLY_IQ1_S;
    }
    private static final int GGML_FTYPE_MOSTLY_IQ4_NL = (int)19L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_IQ4_NL = 19
     * }
     */
    public static int GGML_FTYPE_MOSTLY_IQ4_NL() {
        return GGML_FTYPE_MOSTLY_IQ4_NL;
    }
    private static final int GGML_FTYPE_MOSTLY_IQ3_S = (int)20L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_IQ3_S = 20
     * }
     */
    public static int GGML_FTYPE_MOSTLY_IQ3_S() {
        return GGML_FTYPE_MOSTLY_IQ3_S;
    }
    private static final int GGML_FTYPE_MOSTLY_IQ2_S = (int)21L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_IQ2_S = 21
     * }
     */
    public static int GGML_FTYPE_MOSTLY_IQ2_S() {
        return GGML_FTYPE_MOSTLY_IQ2_S;
    }
    private static final int GGML_FTYPE_MOSTLY_IQ4_XS = (int)22L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_IQ4_XS = 22
     * }
     */
    public static int GGML_FTYPE_MOSTLY_IQ4_XS() {
        return GGML_FTYPE_MOSTLY_IQ4_XS;
    }
    private static final int GGML_FTYPE_MOSTLY_IQ1_M = (int)23L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_IQ1_M = 23
     * }
     */
    public static int GGML_FTYPE_MOSTLY_IQ1_M() {
        return GGML_FTYPE_MOSTLY_IQ1_M;
    }
    private static final int GGML_FTYPE_MOSTLY_BF16 = (int)24L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_BF16 = 24
     * }
     */
    public static int GGML_FTYPE_MOSTLY_BF16() {
        return GGML_FTYPE_MOSTLY_BF16;
    }
    private static final int GGML_FTYPE_MOSTLY_MXFP4 = (int)25L;
    /**
     * {@snippet lang=c :
     * enum ggml_ftype.GGML_FTYPE_MOSTLY_MXFP4 = 25
     * }
     */
    public static int GGML_FTYPE_MOSTLY_MXFP4() {
        return GGML_FTYPE_MOSTLY_MXFP4;
    }
    private static final int GGML_OP_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_NONE = 0
     * }
     */
    public static int GGML_OP_NONE() {
        return GGML_OP_NONE;
    }
    private static final int GGML_OP_DUP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_DUP = 1
     * }
     */
    public static int GGML_OP_DUP() {
        return GGML_OP_DUP;
    }
    private static final int GGML_OP_ADD = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_ADD = 2
     * }
     */
    public static int GGML_OP_ADD() {
        return GGML_OP_ADD;
    }
    private static final int GGML_OP_ADD_ID = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_ADD_ID = 3
     * }
     */
    public static int GGML_OP_ADD_ID() {
        return GGML_OP_ADD_ID;
    }
    private static final int GGML_OP_ADD1 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_ADD1 = 4
     * }
     */
    public static int GGML_OP_ADD1() {
        return GGML_OP_ADD1;
    }
    private static final int GGML_OP_ACC = (int)5L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_ACC = 5
     * }
     */
    public static int GGML_OP_ACC() {
        return GGML_OP_ACC;
    }
    private static final int GGML_OP_SUB = (int)6L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_SUB = 6
     * }
     */
    public static int GGML_OP_SUB() {
        return GGML_OP_SUB;
    }
    private static final int GGML_OP_MUL = (int)7L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_MUL = 7
     * }
     */
    public static int GGML_OP_MUL() {
        return GGML_OP_MUL;
    }
    private static final int GGML_OP_DIV = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_DIV = 8
     * }
     */
    public static int GGML_OP_DIV() {
        return GGML_OP_DIV;
    }
    private static final int GGML_OP_SQR = (int)9L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_SQR = 9
     * }
     */
    public static int GGML_OP_SQR() {
        return GGML_OP_SQR;
    }
    private static final int GGML_OP_SQRT = (int)10L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_SQRT = 10
     * }
     */
    public static int GGML_OP_SQRT() {
        return GGML_OP_SQRT;
    }
    private static final int GGML_OP_LOG = (int)11L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_LOG = 11
     * }
     */
    public static int GGML_OP_LOG() {
        return GGML_OP_LOG;
    }
    private static final int GGML_OP_SIN = (int)12L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_SIN = 12
     * }
     */
    public static int GGML_OP_SIN() {
        return GGML_OP_SIN;
    }
    private static final int GGML_OP_COS = (int)13L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_COS = 13
     * }
     */
    public static int GGML_OP_COS() {
        return GGML_OP_COS;
    }
    private static final int GGML_OP_SUM = (int)14L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_SUM = 14
     * }
     */
    public static int GGML_OP_SUM() {
        return GGML_OP_SUM;
    }
    private static final int GGML_OP_SUM_ROWS = (int)15L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_SUM_ROWS = 15
     * }
     */
    public static int GGML_OP_SUM_ROWS() {
        return GGML_OP_SUM_ROWS;
    }
    private static final int GGML_OP_MEAN = (int)16L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_MEAN = 16
     * }
     */
    public static int GGML_OP_MEAN() {
        return GGML_OP_MEAN;
    }
    private static final int GGML_OP_ARGMAX = (int)17L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_ARGMAX = 17
     * }
     */
    public static int GGML_OP_ARGMAX() {
        return GGML_OP_ARGMAX;
    }
    private static final int GGML_OP_COUNT_EQUAL = (int)18L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_COUNT_EQUAL = 18
     * }
     */
    public static int GGML_OP_COUNT_EQUAL() {
        return GGML_OP_COUNT_EQUAL;
    }
    private static final int GGML_OP_REPEAT = (int)19L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_REPEAT = 19
     * }
     */
    public static int GGML_OP_REPEAT() {
        return GGML_OP_REPEAT;
    }
    private static final int GGML_OP_REPEAT_BACK = (int)20L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_REPEAT_BACK = 20
     * }
     */
    public static int GGML_OP_REPEAT_BACK() {
        return GGML_OP_REPEAT_BACK;
    }
    private static final int GGML_OP_CONCAT = (int)21L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_CONCAT = 21
     * }
     */
    public static int GGML_OP_CONCAT() {
        return GGML_OP_CONCAT;
    }
    private static final int GGML_OP_SILU_BACK = (int)22L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_SILU_BACK = 22
     * }
     */
    public static int GGML_OP_SILU_BACK() {
        return GGML_OP_SILU_BACK;
    }
    private static final int GGML_OP_NORM = (int)23L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_NORM = 23
     * }
     */
    public static int GGML_OP_NORM() {
        return GGML_OP_NORM;
    }
    private static final int GGML_OP_RMS_NORM = (int)24L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_RMS_NORM = 24
     * }
     */
    public static int GGML_OP_RMS_NORM() {
        return GGML_OP_RMS_NORM;
    }
    private static final int GGML_OP_RMS_NORM_BACK = (int)25L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_RMS_NORM_BACK = 25
     * }
     */
    public static int GGML_OP_RMS_NORM_BACK() {
        return GGML_OP_RMS_NORM_BACK;
    }
    private static final int GGML_OP_GROUP_NORM = (int)26L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_GROUP_NORM = 26
     * }
     */
    public static int GGML_OP_GROUP_NORM() {
        return GGML_OP_GROUP_NORM;
    }
    private static final int GGML_OP_L2_NORM = (int)27L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_L2_NORM = 27
     * }
     */
    public static int GGML_OP_L2_NORM() {
        return GGML_OP_L2_NORM;
    }
    private static final int GGML_OP_MUL_MAT = (int)28L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_MUL_MAT = 28
     * }
     */
    public static int GGML_OP_MUL_MAT() {
        return GGML_OP_MUL_MAT;
    }
    private static final int GGML_OP_MUL_MAT_ID = (int)29L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_MUL_MAT_ID = 29
     * }
     */
    public static int GGML_OP_MUL_MAT_ID() {
        return GGML_OP_MUL_MAT_ID;
    }
    private static final int GGML_OP_OUT_PROD = (int)30L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_OUT_PROD = 30
     * }
     */
    public static int GGML_OP_OUT_PROD() {
        return GGML_OP_OUT_PROD;
    }
    private static final int GGML_OP_SCALE = (int)31L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_SCALE = 31
     * }
     */
    public static int GGML_OP_SCALE() {
        return GGML_OP_SCALE;
    }
    private static final int GGML_OP_SET = (int)32L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_SET = 32
     * }
     */
    public static int GGML_OP_SET() {
        return GGML_OP_SET;
    }
    private static final int GGML_OP_CPY = (int)33L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_CPY = 33
     * }
     */
    public static int GGML_OP_CPY() {
        return GGML_OP_CPY;
    }
    private static final int GGML_OP_CONT = (int)34L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_CONT = 34
     * }
     */
    public static int GGML_OP_CONT() {
        return GGML_OP_CONT;
    }
    private static final int GGML_OP_RESHAPE = (int)35L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_RESHAPE = 35
     * }
     */
    public static int GGML_OP_RESHAPE() {
        return GGML_OP_RESHAPE;
    }
    private static final int GGML_OP_VIEW = (int)36L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_VIEW = 36
     * }
     */
    public static int GGML_OP_VIEW() {
        return GGML_OP_VIEW;
    }
    private static final int GGML_OP_PERMUTE = (int)37L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_PERMUTE = 37
     * }
     */
    public static int GGML_OP_PERMUTE() {
        return GGML_OP_PERMUTE;
    }
    private static final int GGML_OP_TRANSPOSE = (int)38L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_TRANSPOSE = 38
     * }
     */
    public static int GGML_OP_TRANSPOSE() {
        return GGML_OP_TRANSPOSE;
    }
    private static final int GGML_OP_GET_ROWS = (int)39L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_GET_ROWS = 39
     * }
     */
    public static int GGML_OP_GET_ROWS() {
        return GGML_OP_GET_ROWS;
    }
    private static final int GGML_OP_GET_ROWS_BACK = (int)40L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_GET_ROWS_BACK = 40
     * }
     */
    public static int GGML_OP_GET_ROWS_BACK() {
        return GGML_OP_GET_ROWS_BACK;
    }
    private static final int GGML_OP_SET_ROWS = (int)41L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_SET_ROWS = 41
     * }
     */
    public static int GGML_OP_SET_ROWS() {
        return GGML_OP_SET_ROWS;
    }
    private static final int GGML_OP_DIAG = (int)42L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_DIAG = 42
     * }
     */
    public static int GGML_OP_DIAG() {
        return GGML_OP_DIAG;
    }
    private static final int GGML_OP_DIAG_MASK_INF = (int)43L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_DIAG_MASK_INF = 43
     * }
     */
    public static int GGML_OP_DIAG_MASK_INF() {
        return GGML_OP_DIAG_MASK_INF;
    }
    private static final int GGML_OP_DIAG_MASK_ZERO = (int)44L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_DIAG_MASK_ZERO = 44
     * }
     */
    public static int GGML_OP_DIAG_MASK_ZERO() {
        return GGML_OP_DIAG_MASK_ZERO;
    }
    private static final int GGML_OP_SOFT_MAX = (int)45L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_SOFT_MAX = 45
     * }
     */
    public static int GGML_OP_SOFT_MAX() {
        return GGML_OP_SOFT_MAX;
    }
    private static final int GGML_OP_SOFT_MAX_BACK = (int)46L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_SOFT_MAX_BACK = 46
     * }
     */
    public static int GGML_OP_SOFT_MAX_BACK() {
        return GGML_OP_SOFT_MAX_BACK;
    }
    private static final int GGML_OP_ROPE = (int)47L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_ROPE = 47
     * }
     */
    public static int GGML_OP_ROPE() {
        return GGML_OP_ROPE;
    }
    private static final int GGML_OP_ROPE_BACK = (int)48L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_ROPE_BACK = 48
     * }
     */
    public static int GGML_OP_ROPE_BACK() {
        return GGML_OP_ROPE_BACK;
    }
    private static final int GGML_OP_CLAMP = (int)49L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_CLAMP = 49
     * }
     */
    public static int GGML_OP_CLAMP() {
        return GGML_OP_CLAMP;
    }
    private static final int GGML_OP_CONV_TRANSPOSE_1D = (int)50L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_CONV_TRANSPOSE_1D = 50
     * }
     */
    public static int GGML_OP_CONV_TRANSPOSE_1D() {
        return GGML_OP_CONV_TRANSPOSE_1D;
    }
    private static final int GGML_OP_IM2COL = (int)51L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_IM2COL = 51
     * }
     */
    public static int GGML_OP_IM2COL() {
        return GGML_OP_IM2COL;
    }
    private static final int GGML_OP_IM2COL_BACK = (int)52L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_IM2COL_BACK = 52
     * }
     */
    public static int GGML_OP_IM2COL_BACK() {
        return GGML_OP_IM2COL_BACK;
    }
    private static final int GGML_OP_CONV_2D = (int)53L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_CONV_2D = 53
     * }
     */
    public static int GGML_OP_CONV_2D() {
        return GGML_OP_CONV_2D;
    }
    private static final int GGML_OP_CONV_2D_DW = (int)54L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_CONV_2D_DW = 54
     * }
     */
    public static int GGML_OP_CONV_2D_DW() {
        return GGML_OP_CONV_2D_DW;
    }
    private static final int GGML_OP_CONV_TRANSPOSE_2D = (int)55L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_CONV_TRANSPOSE_2D = 55
     * }
     */
    public static int GGML_OP_CONV_TRANSPOSE_2D() {
        return GGML_OP_CONV_TRANSPOSE_2D;
    }
    private static final int GGML_OP_POOL_1D = (int)56L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_POOL_1D = 56
     * }
     */
    public static int GGML_OP_POOL_1D() {
        return GGML_OP_POOL_1D;
    }
    private static final int GGML_OP_POOL_2D = (int)57L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_POOL_2D = 57
     * }
     */
    public static int GGML_OP_POOL_2D() {
        return GGML_OP_POOL_2D;
    }
    private static final int GGML_OP_POOL_2D_BACK = (int)58L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_POOL_2D_BACK = 58
     * }
     */
    public static int GGML_OP_POOL_2D_BACK() {
        return GGML_OP_POOL_2D_BACK;
    }
    private static final int GGML_OP_UPSCALE = (int)59L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_UPSCALE = 59
     * }
     */
    public static int GGML_OP_UPSCALE() {
        return GGML_OP_UPSCALE;
    }
    private static final int GGML_OP_PAD = (int)60L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_PAD = 60
     * }
     */
    public static int GGML_OP_PAD() {
        return GGML_OP_PAD;
    }
    private static final int GGML_OP_PAD_REFLECT_1D = (int)61L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_PAD_REFLECT_1D = 61
     * }
     */
    public static int GGML_OP_PAD_REFLECT_1D() {
        return GGML_OP_PAD_REFLECT_1D;
    }
    private static final int GGML_OP_ROLL = (int)62L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_ROLL = 62
     * }
     */
    public static int GGML_OP_ROLL() {
        return GGML_OP_ROLL;
    }
    private static final int GGML_OP_ARANGE = (int)63L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_ARANGE = 63
     * }
     */
    public static int GGML_OP_ARANGE() {
        return GGML_OP_ARANGE;
    }
    private static final int GGML_OP_TIMESTEP_EMBEDDING = (int)64L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_TIMESTEP_EMBEDDING = 64
     * }
     */
    public static int GGML_OP_TIMESTEP_EMBEDDING() {
        return GGML_OP_TIMESTEP_EMBEDDING;
    }
    private static final int GGML_OP_ARGSORT = (int)65L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_ARGSORT = 65
     * }
     */
    public static int GGML_OP_ARGSORT() {
        return GGML_OP_ARGSORT;
    }
    private static final int GGML_OP_LEAKY_RELU = (int)66L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_LEAKY_RELU = 66
     * }
     */
    public static int GGML_OP_LEAKY_RELU() {
        return GGML_OP_LEAKY_RELU;
    }
    private static final int GGML_OP_FLASH_ATTN_EXT = (int)67L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_FLASH_ATTN_EXT = 67
     * }
     */
    public static int GGML_OP_FLASH_ATTN_EXT() {
        return GGML_OP_FLASH_ATTN_EXT;
    }
    private static final int GGML_OP_FLASH_ATTN_BACK = (int)68L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_FLASH_ATTN_BACK = 68
     * }
     */
    public static int GGML_OP_FLASH_ATTN_BACK() {
        return GGML_OP_FLASH_ATTN_BACK;
    }
    private static final int GGML_OP_SSM_CONV = (int)69L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_SSM_CONV = 69
     * }
     */
    public static int GGML_OP_SSM_CONV() {
        return GGML_OP_SSM_CONV;
    }
    private static final int GGML_OP_SSM_SCAN = (int)70L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_SSM_SCAN = 70
     * }
     */
    public static int GGML_OP_SSM_SCAN() {
        return GGML_OP_SSM_SCAN;
    }
    private static final int GGML_OP_WIN_PART = (int)71L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_WIN_PART = 71
     * }
     */
    public static int GGML_OP_WIN_PART() {
        return GGML_OP_WIN_PART;
    }
    private static final int GGML_OP_WIN_UNPART = (int)72L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_WIN_UNPART = 72
     * }
     */
    public static int GGML_OP_WIN_UNPART() {
        return GGML_OP_WIN_UNPART;
    }
    private static final int GGML_OP_GET_REL_POS = (int)73L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_GET_REL_POS = 73
     * }
     */
    public static int GGML_OP_GET_REL_POS() {
        return GGML_OP_GET_REL_POS;
    }
    private static final int GGML_OP_ADD_REL_POS = (int)74L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_ADD_REL_POS = 74
     * }
     */
    public static int GGML_OP_ADD_REL_POS() {
        return GGML_OP_ADD_REL_POS;
    }
    private static final int GGML_OP_RWKV_WKV6 = (int)75L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_RWKV_WKV6 = 75
     * }
     */
    public static int GGML_OP_RWKV_WKV6() {
        return GGML_OP_RWKV_WKV6;
    }
    private static final int GGML_OP_GATED_LINEAR_ATTN = (int)76L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_GATED_LINEAR_ATTN = 76
     * }
     */
    public static int GGML_OP_GATED_LINEAR_ATTN() {
        return GGML_OP_GATED_LINEAR_ATTN;
    }
    private static final int GGML_OP_RWKV_WKV7 = (int)77L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_RWKV_WKV7 = 77
     * }
     */
    public static int GGML_OP_RWKV_WKV7() {
        return GGML_OP_RWKV_WKV7;
    }
    private static final int GGML_OP_UNARY = (int)78L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_UNARY = 78
     * }
     */
    public static int GGML_OP_UNARY() {
        return GGML_OP_UNARY;
    }
    private static final int GGML_OP_MAP_CUSTOM1 = (int)79L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_MAP_CUSTOM1 = 79
     * }
     */
    public static int GGML_OP_MAP_CUSTOM1() {
        return GGML_OP_MAP_CUSTOM1;
    }
    private static final int GGML_OP_MAP_CUSTOM2 = (int)80L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_MAP_CUSTOM2 = 80
     * }
     */
    public static int GGML_OP_MAP_CUSTOM2() {
        return GGML_OP_MAP_CUSTOM2;
    }
    private static final int GGML_OP_MAP_CUSTOM3 = (int)81L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_MAP_CUSTOM3 = 81
     * }
     */
    public static int GGML_OP_MAP_CUSTOM3() {
        return GGML_OP_MAP_CUSTOM3;
    }
    private static final int GGML_OP_CUSTOM = (int)82L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_CUSTOM = 82
     * }
     */
    public static int GGML_OP_CUSTOM() {
        return GGML_OP_CUSTOM;
    }
    private static final int GGML_OP_CROSS_ENTROPY_LOSS = (int)83L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_CROSS_ENTROPY_LOSS = 83
     * }
     */
    public static int GGML_OP_CROSS_ENTROPY_LOSS() {
        return GGML_OP_CROSS_ENTROPY_LOSS;
    }
    private static final int GGML_OP_CROSS_ENTROPY_LOSS_BACK = (int)84L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_CROSS_ENTROPY_LOSS_BACK = 84
     * }
     */
    public static int GGML_OP_CROSS_ENTROPY_LOSS_BACK() {
        return GGML_OP_CROSS_ENTROPY_LOSS_BACK;
    }
    private static final int GGML_OP_OPT_STEP_ADAMW = (int)85L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_OPT_STEP_ADAMW = 85
     * }
     */
    public static int GGML_OP_OPT_STEP_ADAMW() {
        return GGML_OP_OPT_STEP_ADAMW;
    }
    private static final int GGML_OP_OPT_STEP_SGD = (int)86L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_OPT_STEP_SGD = 86
     * }
     */
    public static int GGML_OP_OPT_STEP_SGD() {
        return GGML_OP_OPT_STEP_SGD;
    }
    private static final int GGML_OP_GLU = (int)87L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_GLU = 87
     * }
     */
    public static int GGML_OP_GLU() {
        return GGML_OP_GLU;
    }
    private static final int GGML_OP_COUNT = (int)88L;
    /**
     * {@snippet lang=c :
     * enum ggml_op.GGML_OP_COUNT = 88
     * }
     */
    public static int GGML_OP_COUNT() {
        return GGML_OP_COUNT;
    }
    private static final int GGML_UNARY_OP_ABS = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ggml_unary_op.GGML_UNARY_OP_ABS = 0
     * }
     */
    public static int GGML_UNARY_OP_ABS() {
        return GGML_UNARY_OP_ABS;
    }
    private static final int GGML_UNARY_OP_SGN = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ggml_unary_op.GGML_UNARY_OP_SGN = 1
     * }
     */
    public static int GGML_UNARY_OP_SGN() {
        return GGML_UNARY_OP_SGN;
    }
    private static final int GGML_UNARY_OP_NEG = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ggml_unary_op.GGML_UNARY_OP_NEG = 2
     * }
     */
    public static int GGML_UNARY_OP_NEG() {
        return GGML_UNARY_OP_NEG;
    }
    private static final int GGML_UNARY_OP_STEP = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ggml_unary_op.GGML_UNARY_OP_STEP = 3
     * }
     */
    public static int GGML_UNARY_OP_STEP() {
        return GGML_UNARY_OP_STEP;
    }
    private static final int GGML_UNARY_OP_TANH = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ggml_unary_op.GGML_UNARY_OP_TANH = 4
     * }
     */
    public static int GGML_UNARY_OP_TANH() {
        return GGML_UNARY_OP_TANH;
    }
    private static final int GGML_UNARY_OP_ELU = (int)5L;
    /**
     * {@snippet lang=c :
     * enum ggml_unary_op.GGML_UNARY_OP_ELU = 5
     * }
     */
    public static int GGML_UNARY_OP_ELU() {
        return GGML_UNARY_OP_ELU;
    }
    private static final int GGML_UNARY_OP_RELU = (int)6L;
    /**
     * {@snippet lang=c :
     * enum ggml_unary_op.GGML_UNARY_OP_RELU = 6
     * }
     */
    public static int GGML_UNARY_OP_RELU() {
        return GGML_UNARY_OP_RELU;
    }
    private static final int GGML_UNARY_OP_SIGMOID = (int)7L;
    /**
     * {@snippet lang=c :
     * enum ggml_unary_op.GGML_UNARY_OP_SIGMOID = 7
     * }
     */
    public static int GGML_UNARY_OP_SIGMOID() {
        return GGML_UNARY_OP_SIGMOID;
    }
    private static final int GGML_UNARY_OP_GELU = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ggml_unary_op.GGML_UNARY_OP_GELU = 8
     * }
     */
    public static int GGML_UNARY_OP_GELU() {
        return GGML_UNARY_OP_GELU;
    }
    private static final int GGML_UNARY_OP_GELU_QUICK = (int)9L;
    /**
     * {@snippet lang=c :
     * enum ggml_unary_op.GGML_UNARY_OP_GELU_QUICK = 9
     * }
     */
    public static int GGML_UNARY_OP_GELU_QUICK() {
        return GGML_UNARY_OP_GELU_QUICK;
    }
    private static final int GGML_UNARY_OP_SILU = (int)10L;
    /**
     * {@snippet lang=c :
     * enum ggml_unary_op.GGML_UNARY_OP_SILU = 10
     * }
     */
    public static int GGML_UNARY_OP_SILU() {
        return GGML_UNARY_OP_SILU;
    }
    private static final int GGML_UNARY_OP_HARDSWISH = (int)11L;
    /**
     * {@snippet lang=c :
     * enum ggml_unary_op.GGML_UNARY_OP_HARDSWISH = 11
     * }
     */
    public static int GGML_UNARY_OP_HARDSWISH() {
        return GGML_UNARY_OP_HARDSWISH;
    }
    private static final int GGML_UNARY_OP_HARDSIGMOID = (int)12L;
    /**
     * {@snippet lang=c :
     * enum ggml_unary_op.GGML_UNARY_OP_HARDSIGMOID = 12
     * }
     */
    public static int GGML_UNARY_OP_HARDSIGMOID() {
        return GGML_UNARY_OP_HARDSIGMOID;
    }
    private static final int GGML_UNARY_OP_EXP = (int)13L;
    /**
     * {@snippet lang=c :
     * enum ggml_unary_op.GGML_UNARY_OP_EXP = 13
     * }
     */
    public static int GGML_UNARY_OP_EXP() {
        return GGML_UNARY_OP_EXP;
    }
    private static final int GGML_UNARY_OP_GELU_ERF = (int)14L;
    /**
     * {@snippet lang=c :
     * enum ggml_unary_op.GGML_UNARY_OP_GELU_ERF = 14
     * }
     */
    public static int GGML_UNARY_OP_GELU_ERF() {
        return GGML_UNARY_OP_GELU_ERF;
    }
    private static final int GGML_UNARY_OP_COUNT = (int)15L;
    /**
     * {@snippet lang=c :
     * enum ggml_unary_op.GGML_UNARY_OP_COUNT = 15
     * }
     */
    public static int GGML_UNARY_OP_COUNT() {
        return GGML_UNARY_OP_COUNT;
    }
    private static final int GGML_GLU_OP_REGLU = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ggml_glu_op.GGML_GLU_OP_REGLU = 0
     * }
     */
    public static int GGML_GLU_OP_REGLU() {
        return GGML_GLU_OP_REGLU;
    }
    private static final int GGML_GLU_OP_GEGLU = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ggml_glu_op.GGML_GLU_OP_GEGLU = 1
     * }
     */
    public static int GGML_GLU_OP_GEGLU() {
        return GGML_GLU_OP_GEGLU;
    }
    private static final int GGML_GLU_OP_SWIGLU = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ggml_glu_op.GGML_GLU_OP_SWIGLU = 2
     * }
     */
    public static int GGML_GLU_OP_SWIGLU() {
        return GGML_GLU_OP_SWIGLU;
    }
    private static final int GGML_GLU_OP_SWIGLU_OAI = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ggml_glu_op.GGML_GLU_OP_SWIGLU_OAI = 3
     * }
     */
    public static int GGML_GLU_OP_SWIGLU_OAI() {
        return GGML_GLU_OP_SWIGLU_OAI;
    }
    private static final int GGML_GLU_OP_GEGLU_ERF = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ggml_glu_op.GGML_GLU_OP_GEGLU_ERF = 4
     * }
     */
    public static int GGML_GLU_OP_GEGLU_ERF() {
        return GGML_GLU_OP_GEGLU_ERF;
    }
    private static final int GGML_GLU_OP_GEGLU_QUICK = (int)5L;
    /**
     * {@snippet lang=c :
     * enum ggml_glu_op.GGML_GLU_OP_GEGLU_QUICK = 5
     * }
     */
    public static int GGML_GLU_OP_GEGLU_QUICK() {
        return GGML_GLU_OP_GEGLU_QUICK;
    }
    private static final int GGML_GLU_OP_COUNT = (int)6L;
    /**
     * {@snippet lang=c :
     * enum ggml_glu_op.GGML_GLU_OP_COUNT = 6
     * }
     */
    public static int GGML_GLU_OP_COUNT() {
        return GGML_GLU_OP_COUNT;
    }
    private static final int GGML_OBJECT_TYPE_TENSOR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ggml_object_type.GGML_OBJECT_TYPE_TENSOR = 0
     * }
     */
    public static int GGML_OBJECT_TYPE_TENSOR() {
        return GGML_OBJECT_TYPE_TENSOR;
    }
    private static final int GGML_OBJECT_TYPE_GRAPH = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ggml_object_type.GGML_OBJECT_TYPE_GRAPH = 1
     * }
     */
    public static int GGML_OBJECT_TYPE_GRAPH() {
        return GGML_OBJECT_TYPE_GRAPH;
    }
    private static final int GGML_OBJECT_TYPE_WORK_BUFFER = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ggml_object_type.GGML_OBJECT_TYPE_WORK_BUFFER = 2
     * }
     */
    public static int GGML_OBJECT_TYPE_WORK_BUFFER() {
        return GGML_OBJECT_TYPE_WORK_BUFFER;
    }
    private static final int GGML_LOG_LEVEL_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ggml_log_level.GGML_LOG_LEVEL_NONE = 0
     * }
     */
    public static int GGML_LOG_LEVEL_NONE() {
        return GGML_LOG_LEVEL_NONE;
    }
    private static final int GGML_LOG_LEVEL_DEBUG = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ggml_log_level.GGML_LOG_LEVEL_DEBUG = 1
     * }
     */
    public static int GGML_LOG_LEVEL_DEBUG() {
        return GGML_LOG_LEVEL_DEBUG;
    }
    private static final int GGML_LOG_LEVEL_INFO = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ggml_log_level.GGML_LOG_LEVEL_INFO = 2
     * }
     */
    public static int GGML_LOG_LEVEL_INFO() {
        return GGML_LOG_LEVEL_INFO;
    }
    private static final int GGML_LOG_LEVEL_WARN = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ggml_log_level.GGML_LOG_LEVEL_WARN = 3
     * }
     */
    public static int GGML_LOG_LEVEL_WARN() {
        return GGML_LOG_LEVEL_WARN;
    }
    private static final int GGML_LOG_LEVEL_ERROR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ggml_log_level.GGML_LOG_LEVEL_ERROR = 4
     * }
     */
    public static int GGML_LOG_LEVEL_ERROR() {
        return GGML_LOG_LEVEL_ERROR;
    }
    private static final int GGML_LOG_LEVEL_CONT = (int)5L;
    /**
     * {@snippet lang=c :
     * enum ggml_log_level.GGML_LOG_LEVEL_CONT = 5
     * }
     */
    public static int GGML_LOG_LEVEL_CONT() {
        return GGML_LOG_LEVEL_CONT;
    }
    private static final int GGML_TENSOR_FLAG_INPUT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ggml_tensor_flag.GGML_TENSOR_FLAG_INPUT = 1
     * }
     */
    public static int GGML_TENSOR_FLAG_INPUT() {
        return GGML_TENSOR_FLAG_INPUT;
    }
    private static final int GGML_TENSOR_FLAG_OUTPUT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ggml_tensor_flag.GGML_TENSOR_FLAG_OUTPUT = 2
     * }
     */
    public static int GGML_TENSOR_FLAG_OUTPUT() {
        return GGML_TENSOR_FLAG_OUTPUT;
    }
    private static final int GGML_TENSOR_FLAG_PARAM = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ggml_tensor_flag.GGML_TENSOR_FLAG_PARAM = 4
     * }
     */
    public static int GGML_TENSOR_FLAG_PARAM() {
        return GGML_TENSOR_FLAG_PARAM;
    }
    private static final int GGML_TENSOR_FLAG_LOSS = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ggml_tensor_flag.GGML_TENSOR_FLAG_LOSS = 8
     * }
     */
    public static int GGML_TENSOR_FLAG_LOSS() {
        return GGML_TENSOR_FLAG_LOSS;
    }
    /**
     * {@snippet lang=c :
     * typedef ggml_guid *ggml_guid_t
     * }
     */
    public static final AddressLayout ggml_guid_t = WhisperCpp.C_POINTER;

    private static class ggml_guid_matches {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_guid_matches");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_guid_matches(ggml_guid_t guid_a, ggml_guid_t guid_b)
     * }
     */
    public static FunctionDescriptor ggml_guid_matches$descriptor() {
        return ggml_guid_matches.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_guid_matches(ggml_guid_t guid_a, ggml_guid_t guid_b)
     * }
     */
    public static MethodHandle ggml_guid_matches$handle() {
        return ggml_guid_matches.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_guid_matches(ggml_guid_t guid_a, ggml_guid_t guid_b)
     * }
     */
    public static MemorySegment ggml_guid_matches$address() {
        return ggml_guid_matches.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_guid_matches(ggml_guid_t guid_a, ggml_guid_t guid_b)
     * }
     */
    public static boolean ggml_guid_matches(MemorySegment guid_a, MemorySegment guid_b) {
        var mh$ = ggml_guid_matches.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_guid_matches", guid_a, guid_b);
            }
            return (boolean)mh$.invokeExact(guid_a, guid_b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ggml_version()
     * }
     */
    public static FunctionDescriptor ggml_version$descriptor() {
        return ggml_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ggml_version()
     * }
     */
    public static MethodHandle ggml_version$handle() {
        return ggml_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ggml_version()
     * }
     */
    public static MemorySegment ggml_version$address() {
        return ggml_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ggml_version()
     * }
     */
    public static MemorySegment ggml_version() {
        var mh$ = ggml_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_version");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_commit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_commit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ggml_commit()
     * }
     */
    public static FunctionDescriptor ggml_commit$descriptor() {
        return ggml_commit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ggml_commit()
     * }
     */
    public static MethodHandle ggml_commit$handle() {
        return ggml_commit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ggml_commit()
     * }
     */
    public static MemorySegment ggml_commit$address() {
        return ggml_commit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ggml_commit()
     * }
     */
    public static MemorySegment ggml_commit() {
        var mh$ = ggml_commit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_commit");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_time_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_time_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_time_init()
     * }
     */
    public static FunctionDescriptor ggml_time_init$descriptor() {
        return ggml_time_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_time_init()
     * }
     */
    public static MethodHandle ggml_time_init$handle() {
        return ggml_time_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_time_init()
     * }
     */
    public static MemorySegment ggml_time_init$address() {
        return ggml_time_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_time_init()
     * }
     */
    public static void ggml_time_init() {
        var mh$ = ggml_time_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_time_init");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_time_ms {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_time_ms");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int64_t ggml_time_ms()
     * }
     */
    public static FunctionDescriptor ggml_time_ms$descriptor() {
        return ggml_time_ms.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int64_t ggml_time_ms()
     * }
     */
    public static MethodHandle ggml_time_ms$handle() {
        return ggml_time_ms.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int64_t ggml_time_ms()
     * }
     */
    public static MemorySegment ggml_time_ms$address() {
        return ggml_time_ms.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int64_t ggml_time_ms()
     * }
     */
    public static long ggml_time_ms() {
        var mh$ = ggml_time_ms.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_time_ms");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_time_us {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_time_us");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int64_t ggml_time_us()
     * }
     */
    public static FunctionDescriptor ggml_time_us$descriptor() {
        return ggml_time_us.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int64_t ggml_time_us()
     * }
     */
    public static MethodHandle ggml_time_us$handle() {
        return ggml_time_us.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int64_t ggml_time_us()
     * }
     */
    public static MemorySegment ggml_time_us$address() {
        return ggml_time_us.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int64_t ggml_time_us()
     * }
     */
    public static long ggml_time_us() {
        var mh$ = ggml_time_us.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_time_us");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cycles {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cycles");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int64_t ggml_cycles()
     * }
     */
    public static FunctionDescriptor ggml_cycles$descriptor() {
        return ggml_cycles.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int64_t ggml_cycles()
     * }
     */
    public static MethodHandle ggml_cycles$handle() {
        return ggml_cycles.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int64_t ggml_cycles()
     * }
     */
    public static MemorySegment ggml_cycles$address() {
        return ggml_cycles.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int64_t ggml_cycles()
     * }
     */
    public static long ggml_cycles() {
        var mh$ = ggml_cycles.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cycles");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cycles_per_ms {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cycles_per_ms");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int64_t ggml_cycles_per_ms()
     * }
     */
    public static FunctionDescriptor ggml_cycles_per_ms$descriptor() {
        return ggml_cycles_per_ms.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int64_t ggml_cycles_per_ms()
     * }
     */
    public static MethodHandle ggml_cycles_per_ms$handle() {
        return ggml_cycles_per_ms.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int64_t ggml_cycles_per_ms()
     * }
     */
    public static MemorySegment ggml_cycles_per_ms$address() {
        return ggml_cycles_per_ms.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int64_t ggml_cycles_per_ms()
     * }
     */
    public static long ggml_cycles_per_ms() {
        var mh$ = ggml_cycles_per_ms.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cycles_per_ms");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_fopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_fopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *ggml_fopen(const char *fname, const char *mode)
     * }
     */
    public static FunctionDescriptor ggml_fopen$descriptor() {
        return ggml_fopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *ggml_fopen(const char *fname, const char *mode)
     * }
     */
    public static MethodHandle ggml_fopen$handle() {
        return ggml_fopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *ggml_fopen(const char *fname, const char *mode)
     * }
     */
    public static MemorySegment ggml_fopen$address() {
        return ggml_fopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *ggml_fopen(const char *fname, const char *mode)
     * }
     */
    public static MemorySegment ggml_fopen(MemorySegment fname, MemorySegment mode) {
        var mh$ = ggml_fopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_fopen", fname, mode);
            }
            return (MemorySegment)mh$.invokeExact(fname, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_print_object {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_print_object");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_print_object(const struct ggml_object *obj)
     * }
     */
    public static FunctionDescriptor ggml_print_object$descriptor() {
        return ggml_print_object.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_print_object(const struct ggml_object *obj)
     * }
     */
    public static MethodHandle ggml_print_object$handle() {
        return ggml_print_object.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_print_object(const struct ggml_object *obj)
     * }
     */
    public static MemorySegment ggml_print_object$address() {
        return ggml_print_object.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_print_object(const struct ggml_object *obj)
     * }
     */
    public static void ggml_print_object(MemorySegment obj) {
        var mh$ = ggml_print_object.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_print_object", obj);
            }
            mh$.invokeExact(obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_print_objects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_print_objects");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_print_objects(const struct ggml_context *ctx)
     * }
     */
    public static FunctionDescriptor ggml_print_objects$descriptor() {
        return ggml_print_objects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_print_objects(const struct ggml_context *ctx)
     * }
     */
    public static MethodHandle ggml_print_objects$handle() {
        return ggml_print_objects.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_print_objects(const struct ggml_context *ctx)
     * }
     */
    public static MemorySegment ggml_print_objects$address() {
        return ggml_print_objects.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_print_objects(const struct ggml_context *ctx)
     * }
     */
    public static void ggml_print_objects(MemorySegment ctx) {
        var mh$ = ggml_print_objects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_print_objects", ctx);
            }
            mh$.invokeExact(ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_nelements {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_nelements");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int64_t ggml_nelements(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_nelements$descriptor() {
        return ggml_nelements.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int64_t ggml_nelements(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_nelements$handle() {
        return ggml_nelements.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int64_t ggml_nelements(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_nelements$address() {
        return ggml_nelements.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int64_t ggml_nelements(const struct ggml_tensor *tensor)
     * }
     */
    public static long ggml_nelements(MemorySegment tensor) {
        var mh$ = ggml_nelements.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_nelements", tensor);
            }
            return (long)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_nrows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_nrows");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int64_t ggml_nrows(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_nrows$descriptor() {
        return ggml_nrows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int64_t ggml_nrows(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_nrows$handle() {
        return ggml_nrows.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int64_t ggml_nrows(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_nrows$address() {
        return ggml_nrows.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int64_t ggml_nrows(const struct ggml_tensor *tensor)
     * }
     */
    public static long ggml_nrows(MemorySegment tensor) {
        var mh$ = ggml_nrows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_nrows", tensor);
            }
            return (long)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_nbytes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_nbytes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_nbytes(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_nbytes$descriptor() {
        return ggml_nbytes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_nbytes(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_nbytes$handle() {
        return ggml_nbytes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_nbytes(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_nbytes$address() {
        return ggml_nbytes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_nbytes(const struct ggml_tensor *tensor)
     * }
     */
    public static long ggml_nbytes(MemorySegment tensor) {
        var mh$ = ggml_nbytes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_nbytes", tensor);
            }
            return (long)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_nbytes_pad {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_nbytes_pad");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_nbytes_pad(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_nbytes_pad$descriptor() {
        return ggml_nbytes_pad.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_nbytes_pad(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_nbytes_pad$handle() {
        return ggml_nbytes_pad.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_nbytes_pad(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_nbytes_pad$address() {
        return ggml_nbytes_pad.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_nbytes_pad(const struct ggml_tensor *tensor)
     * }
     */
    public static long ggml_nbytes_pad(MemorySegment tensor) {
        var mh$ = ggml_nbytes_pad.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_nbytes_pad", tensor);
            }
            return (long)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_blck_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_blck_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int64_t ggml_blck_size(enum ggml_type type)
     * }
     */
    public static FunctionDescriptor ggml_blck_size$descriptor() {
        return ggml_blck_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int64_t ggml_blck_size(enum ggml_type type)
     * }
     */
    public static MethodHandle ggml_blck_size$handle() {
        return ggml_blck_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int64_t ggml_blck_size(enum ggml_type type)
     * }
     */
    public static MemorySegment ggml_blck_size$address() {
        return ggml_blck_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int64_t ggml_blck_size(enum ggml_type type)
     * }
     */
    public static long ggml_blck_size(int type) {
        var mh$ = ggml_blck_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_blck_size", type);
            }
            return (long)mh$.invokeExact(type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_type_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_type_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_type_size(enum ggml_type type)
     * }
     */
    public static FunctionDescriptor ggml_type_size$descriptor() {
        return ggml_type_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_type_size(enum ggml_type type)
     * }
     */
    public static MethodHandle ggml_type_size$handle() {
        return ggml_type_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_type_size(enum ggml_type type)
     * }
     */
    public static MemorySegment ggml_type_size$address() {
        return ggml_type_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_type_size(enum ggml_type type)
     * }
     */
    public static long ggml_type_size(int type) {
        var mh$ = ggml_type_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_type_size", type);
            }
            return (long)mh$.invokeExact(type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_row_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG,
            WhisperCpp.C_INT,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_row_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_row_size(enum ggml_type type, int64_t ne)
     * }
     */
    public static FunctionDescriptor ggml_row_size$descriptor() {
        return ggml_row_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_row_size(enum ggml_type type, int64_t ne)
     * }
     */
    public static MethodHandle ggml_row_size$handle() {
        return ggml_row_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_row_size(enum ggml_type type, int64_t ne)
     * }
     */
    public static MemorySegment ggml_row_size$address() {
        return ggml_row_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_row_size(enum ggml_type type, int64_t ne)
     * }
     */
    public static long ggml_row_size(int type, long ne) {
        var mh$ = ggml_row_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_row_size", type, ne);
            }
            return (long)mh$.invokeExact(type, ne);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_type_sizef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_DOUBLE,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_type_sizef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double ggml_type_sizef(enum ggml_type type)
     * }
     */
    public static FunctionDescriptor ggml_type_sizef$descriptor() {
        return ggml_type_sizef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double ggml_type_sizef(enum ggml_type type)
     * }
     */
    public static MethodHandle ggml_type_sizef$handle() {
        return ggml_type_sizef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double ggml_type_sizef(enum ggml_type type)
     * }
     */
    public static MemorySegment ggml_type_sizef$address() {
        return ggml_type_sizef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double ggml_type_sizef(enum ggml_type type)
     * }
     */
    public static double ggml_type_sizef(int type) {
        var mh$ = ggml_type_sizef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_type_sizef", type);
            }
            return (double)mh$.invokeExact(type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_type_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_type_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ggml_type_name(enum ggml_type type)
     * }
     */
    public static FunctionDescriptor ggml_type_name$descriptor() {
        return ggml_type_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ggml_type_name(enum ggml_type type)
     * }
     */
    public static MethodHandle ggml_type_name$handle() {
        return ggml_type_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ggml_type_name(enum ggml_type type)
     * }
     */
    public static MemorySegment ggml_type_name$address() {
        return ggml_type_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ggml_type_name(enum ggml_type type)
     * }
     */
    public static MemorySegment ggml_type_name(int type) {
        var mh$ = ggml_type_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_type_name", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_op_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_op_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ggml_op_name(enum ggml_op op)
     * }
     */
    public static FunctionDescriptor ggml_op_name$descriptor() {
        return ggml_op_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ggml_op_name(enum ggml_op op)
     * }
     */
    public static MethodHandle ggml_op_name$handle() {
        return ggml_op_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ggml_op_name(enum ggml_op op)
     * }
     */
    public static MemorySegment ggml_op_name$address() {
        return ggml_op_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ggml_op_name(enum ggml_op op)
     * }
     */
    public static MemorySegment ggml_op_name(int op) {
        var mh$ = ggml_op_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_op_name", op);
            }
            return (MemorySegment)mh$.invokeExact(op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_op_symbol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_op_symbol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ggml_op_symbol(enum ggml_op op)
     * }
     */
    public static FunctionDescriptor ggml_op_symbol$descriptor() {
        return ggml_op_symbol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ggml_op_symbol(enum ggml_op op)
     * }
     */
    public static MethodHandle ggml_op_symbol$handle() {
        return ggml_op_symbol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ggml_op_symbol(enum ggml_op op)
     * }
     */
    public static MemorySegment ggml_op_symbol$address() {
        return ggml_op_symbol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ggml_op_symbol(enum ggml_op op)
     * }
     */
    public static MemorySegment ggml_op_symbol(int op) {
        var mh$ = ggml_op_symbol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_op_symbol", op);
            }
            return (MemorySegment)mh$.invokeExact(op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_unary_op_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_unary_op_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ggml_unary_op_name(enum ggml_unary_op op)
     * }
     */
    public static FunctionDescriptor ggml_unary_op_name$descriptor() {
        return ggml_unary_op_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ggml_unary_op_name(enum ggml_unary_op op)
     * }
     */
    public static MethodHandle ggml_unary_op_name$handle() {
        return ggml_unary_op_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ggml_unary_op_name(enum ggml_unary_op op)
     * }
     */
    public static MemorySegment ggml_unary_op_name$address() {
        return ggml_unary_op_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ggml_unary_op_name(enum ggml_unary_op op)
     * }
     */
    public static MemorySegment ggml_unary_op_name(int op) {
        var mh$ = ggml_unary_op_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_unary_op_name", op);
            }
            return (MemorySegment)mh$.invokeExact(op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_glu_op_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_glu_op_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ggml_glu_op_name(enum ggml_glu_op op)
     * }
     */
    public static FunctionDescriptor ggml_glu_op_name$descriptor() {
        return ggml_glu_op_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ggml_glu_op_name(enum ggml_glu_op op)
     * }
     */
    public static MethodHandle ggml_glu_op_name$handle() {
        return ggml_glu_op_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ggml_glu_op_name(enum ggml_glu_op op)
     * }
     */
    public static MemorySegment ggml_glu_op_name$address() {
        return ggml_glu_op_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ggml_glu_op_name(enum ggml_glu_op op)
     * }
     */
    public static MemorySegment ggml_glu_op_name(int op) {
        var mh$ = ggml_glu_op_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_glu_op_name", op);
            }
            return (MemorySegment)mh$.invokeExact(op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_op_desc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_op_desc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ggml_op_desc(const struct ggml_tensor *t)
     * }
     */
    public static FunctionDescriptor ggml_op_desc$descriptor() {
        return ggml_op_desc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ggml_op_desc(const struct ggml_tensor *t)
     * }
     */
    public static MethodHandle ggml_op_desc$handle() {
        return ggml_op_desc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ggml_op_desc(const struct ggml_tensor *t)
     * }
     */
    public static MemorySegment ggml_op_desc$address() {
        return ggml_op_desc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ggml_op_desc(const struct ggml_tensor *t)
     * }
     */
    public static MemorySegment ggml_op_desc(MemorySegment t) {
        var mh$ = ggml_op_desc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_op_desc", t);
            }
            return (MemorySegment)mh$.invokeExact(t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_element_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_element_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_element_size(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_element_size$descriptor() {
        return ggml_element_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_element_size(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_element_size$handle() {
        return ggml_element_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_element_size(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_element_size$address() {
        return ggml_element_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_element_size(const struct ggml_tensor *tensor)
     * }
     */
    public static long ggml_element_size(MemorySegment tensor) {
        var mh$ = ggml_element_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_element_size", tensor);
            }
            return (long)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_is_quantized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_is_quantized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_is_quantized(enum ggml_type type)
     * }
     */
    public static FunctionDescriptor ggml_is_quantized$descriptor() {
        return ggml_is_quantized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_is_quantized(enum ggml_type type)
     * }
     */
    public static MethodHandle ggml_is_quantized$handle() {
        return ggml_is_quantized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_is_quantized(enum ggml_type type)
     * }
     */
    public static MemorySegment ggml_is_quantized$address() {
        return ggml_is_quantized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_is_quantized(enum ggml_type type)
     * }
     */
    public static boolean ggml_is_quantized(int type) {
        var mh$ = ggml_is_quantized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_is_quantized", type);
            }
            return (boolean)mh$.invokeExact(type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_ftype_to_ggml_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_ftype_to_ggml_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_type ggml_ftype_to_ggml_type(enum ggml_ftype ftype)
     * }
     */
    public static FunctionDescriptor ggml_ftype_to_ggml_type$descriptor() {
        return ggml_ftype_to_ggml_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_type ggml_ftype_to_ggml_type(enum ggml_ftype ftype)
     * }
     */
    public static MethodHandle ggml_ftype_to_ggml_type$handle() {
        return ggml_ftype_to_ggml_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_type ggml_ftype_to_ggml_type(enum ggml_ftype ftype)
     * }
     */
    public static MemorySegment ggml_ftype_to_ggml_type$address() {
        return ggml_ftype_to_ggml_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_type ggml_ftype_to_ggml_type(enum ggml_ftype ftype)
     * }
     */
    public static int ggml_ftype_to_ggml_type(int ftype) {
        var mh$ = ggml_ftype_to_ggml_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_ftype_to_ggml_type", ftype);
            }
            return (int)mh$.invokeExact(ftype);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_is_transposed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_is_transposed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_is_transposed(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_is_transposed$descriptor() {
        return ggml_is_transposed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_is_transposed(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_is_transposed$handle() {
        return ggml_is_transposed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_is_transposed(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_is_transposed$address() {
        return ggml_is_transposed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_is_transposed(const struct ggml_tensor *tensor)
     * }
     */
    public static boolean ggml_is_transposed(MemorySegment tensor) {
        var mh$ = ggml_is_transposed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_is_transposed", tensor);
            }
            return (boolean)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_is_permuted {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_is_permuted");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_is_permuted(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_is_permuted$descriptor() {
        return ggml_is_permuted.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_is_permuted(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_is_permuted$handle() {
        return ggml_is_permuted.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_is_permuted(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_is_permuted$address() {
        return ggml_is_permuted.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_is_permuted(const struct ggml_tensor *tensor)
     * }
     */
    public static boolean ggml_is_permuted(MemorySegment tensor) {
        var mh$ = ggml_is_permuted.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_is_permuted", tensor);
            }
            return (boolean)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_is_empty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_is_empty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_is_empty(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_is_empty$descriptor() {
        return ggml_is_empty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_is_empty(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_is_empty$handle() {
        return ggml_is_empty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_is_empty(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_is_empty$address() {
        return ggml_is_empty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_is_empty(const struct ggml_tensor *tensor)
     * }
     */
    public static boolean ggml_is_empty(MemorySegment tensor) {
        var mh$ = ggml_is_empty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_is_empty", tensor);
            }
            return (boolean)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_is_scalar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_is_scalar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_is_scalar(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_is_scalar$descriptor() {
        return ggml_is_scalar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_is_scalar(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_is_scalar$handle() {
        return ggml_is_scalar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_is_scalar(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_is_scalar$address() {
        return ggml_is_scalar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_is_scalar(const struct ggml_tensor *tensor)
     * }
     */
    public static boolean ggml_is_scalar(MemorySegment tensor) {
        var mh$ = ggml_is_scalar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_is_scalar", tensor);
            }
            return (boolean)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_is_vector {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_is_vector");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_is_vector(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_is_vector$descriptor() {
        return ggml_is_vector.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_is_vector(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_is_vector$handle() {
        return ggml_is_vector.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_is_vector(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_is_vector$address() {
        return ggml_is_vector.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_is_vector(const struct ggml_tensor *tensor)
     * }
     */
    public static boolean ggml_is_vector(MemorySegment tensor) {
        var mh$ = ggml_is_vector.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_is_vector", tensor);
            }
            return (boolean)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_is_matrix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_is_matrix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_is_matrix(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_is_matrix$descriptor() {
        return ggml_is_matrix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_is_matrix(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_is_matrix$handle() {
        return ggml_is_matrix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_is_matrix(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_is_matrix$address() {
        return ggml_is_matrix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_is_matrix(const struct ggml_tensor *tensor)
     * }
     */
    public static boolean ggml_is_matrix(MemorySegment tensor) {
        var mh$ = ggml_is_matrix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_is_matrix", tensor);
            }
            return (boolean)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_is_3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_is_3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_is_3d(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_is_3d$descriptor() {
        return ggml_is_3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_is_3d(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_is_3d$handle() {
        return ggml_is_3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_is_3d(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_is_3d$address() {
        return ggml_is_3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_is_3d(const struct ggml_tensor *tensor)
     * }
     */
    public static boolean ggml_is_3d(MemorySegment tensor) {
        var mh$ = ggml_is_3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_is_3d", tensor);
            }
            return (boolean)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_n_dims {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_n_dims");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_n_dims(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_n_dims$descriptor() {
        return ggml_n_dims.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_n_dims(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_n_dims$handle() {
        return ggml_n_dims.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_n_dims(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_n_dims$address() {
        return ggml_n_dims.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_n_dims(const struct ggml_tensor *tensor)
     * }
     */
    public static int ggml_n_dims(MemorySegment tensor) {
        var mh$ = ggml_n_dims.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_n_dims", tensor);
            }
            return (int)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_is_contiguous {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_is_contiguous");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_is_contiguous$descriptor() {
        return ggml_is_contiguous.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_is_contiguous$handle() {
        return ggml_is_contiguous.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_is_contiguous$address() {
        return ggml_is_contiguous.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous(const struct ggml_tensor *tensor)
     * }
     */
    public static boolean ggml_is_contiguous(MemorySegment tensor) {
        var mh$ = ggml_is_contiguous.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_is_contiguous", tensor);
            }
            return (boolean)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_is_contiguous_0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_is_contiguous_0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous_0(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_is_contiguous_0$descriptor() {
        return ggml_is_contiguous_0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous_0(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_is_contiguous_0$handle() {
        return ggml_is_contiguous_0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous_0(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_is_contiguous_0$address() {
        return ggml_is_contiguous_0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous_0(const struct ggml_tensor *tensor)
     * }
     */
    public static boolean ggml_is_contiguous_0(MemorySegment tensor) {
        var mh$ = ggml_is_contiguous_0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_is_contiguous_0", tensor);
            }
            return (boolean)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_is_contiguous_1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_is_contiguous_1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous_1(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_is_contiguous_1$descriptor() {
        return ggml_is_contiguous_1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous_1(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_is_contiguous_1$handle() {
        return ggml_is_contiguous_1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous_1(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_is_contiguous_1$address() {
        return ggml_is_contiguous_1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous_1(const struct ggml_tensor *tensor)
     * }
     */
    public static boolean ggml_is_contiguous_1(MemorySegment tensor) {
        var mh$ = ggml_is_contiguous_1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_is_contiguous_1", tensor);
            }
            return (boolean)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_is_contiguous_2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_is_contiguous_2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous_2(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_is_contiguous_2$descriptor() {
        return ggml_is_contiguous_2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous_2(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_is_contiguous_2$handle() {
        return ggml_is_contiguous_2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous_2(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_is_contiguous_2$address() {
        return ggml_is_contiguous_2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous_2(const struct ggml_tensor *tensor)
     * }
     */
    public static boolean ggml_is_contiguous_2(MemorySegment tensor) {
        var mh$ = ggml_is_contiguous_2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_is_contiguous_2", tensor);
            }
            return (boolean)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_is_contiguously_allocated {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_is_contiguously_allocated");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguously_allocated(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_is_contiguously_allocated$descriptor() {
        return ggml_is_contiguously_allocated.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguously_allocated(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_is_contiguously_allocated$handle() {
        return ggml_is_contiguously_allocated.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguously_allocated(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_is_contiguously_allocated$address() {
        return ggml_is_contiguously_allocated.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_is_contiguously_allocated(const struct ggml_tensor *tensor)
     * }
     */
    public static boolean ggml_is_contiguously_allocated(MemorySegment tensor) {
        var mh$ = ggml_is_contiguously_allocated.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_is_contiguously_allocated", tensor);
            }
            return (boolean)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_is_contiguous_channels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_is_contiguous_channels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous_channels(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_is_contiguous_channels$descriptor() {
        return ggml_is_contiguous_channels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous_channels(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_is_contiguous_channels$handle() {
        return ggml_is_contiguous_channels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous_channels(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_is_contiguous_channels$address() {
        return ggml_is_contiguous_channels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous_channels(const struct ggml_tensor *tensor)
     * }
     */
    public static boolean ggml_is_contiguous_channels(MemorySegment tensor) {
        var mh$ = ggml_is_contiguous_channels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_is_contiguous_channels", tensor);
            }
            return (boolean)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_is_contiguous_rows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_is_contiguous_rows");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous_rows(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_is_contiguous_rows$descriptor() {
        return ggml_is_contiguous_rows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous_rows(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_is_contiguous_rows$handle() {
        return ggml_is_contiguous_rows.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous_rows(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_is_contiguous_rows$address() {
        return ggml_is_contiguous_rows.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_is_contiguous_rows(const struct ggml_tensor *tensor)
     * }
     */
    public static boolean ggml_is_contiguous_rows(MemorySegment tensor) {
        var mh$ = ggml_is_contiguous_rows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_is_contiguous_rows", tensor);
            }
            return (boolean)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_are_same_shape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_are_same_shape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_are_same_shape(const struct ggml_tensor *t0, const struct ggml_tensor *t1)
     * }
     */
    public static FunctionDescriptor ggml_are_same_shape$descriptor() {
        return ggml_are_same_shape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_are_same_shape(const struct ggml_tensor *t0, const struct ggml_tensor *t1)
     * }
     */
    public static MethodHandle ggml_are_same_shape$handle() {
        return ggml_are_same_shape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_are_same_shape(const struct ggml_tensor *t0, const struct ggml_tensor *t1)
     * }
     */
    public static MemorySegment ggml_are_same_shape$address() {
        return ggml_are_same_shape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_are_same_shape(const struct ggml_tensor *t0, const struct ggml_tensor *t1)
     * }
     */
    public static boolean ggml_are_same_shape(MemorySegment t0, MemorySegment t1) {
        var mh$ = ggml_are_same_shape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_are_same_shape", t0, t1);
            }
            return (boolean)mh$.invokeExact(t0, t1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_are_same_stride {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_are_same_stride");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_are_same_stride(const struct ggml_tensor *t0, const struct ggml_tensor *t1)
     * }
     */
    public static FunctionDescriptor ggml_are_same_stride$descriptor() {
        return ggml_are_same_stride.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_are_same_stride(const struct ggml_tensor *t0, const struct ggml_tensor *t1)
     * }
     */
    public static MethodHandle ggml_are_same_stride$handle() {
        return ggml_are_same_stride.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_are_same_stride(const struct ggml_tensor *t0, const struct ggml_tensor *t1)
     * }
     */
    public static MemorySegment ggml_are_same_stride$address() {
        return ggml_are_same_stride.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_are_same_stride(const struct ggml_tensor *t0, const struct ggml_tensor *t1)
     * }
     */
    public static boolean ggml_are_same_stride(MemorySegment t0, MemorySegment t1) {
        var mh$ = ggml_are_same_stride.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_are_same_stride", t0, t1);
            }
            return (boolean)mh$.invokeExact(t0, t1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_can_repeat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_can_repeat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_can_repeat(const struct ggml_tensor *t0, const struct ggml_tensor *t1)
     * }
     */
    public static FunctionDescriptor ggml_can_repeat$descriptor() {
        return ggml_can_repeat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_can_repeat(const struct ggml_tensor *t0, const struct ggml_tensor *t1)
     * }
     */
    public static MethodHandle ggml_can_repeat$handle() {
        return ggml_can_repeat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_can_repeat(const struct ggml_tensor *t0, const struct ggml_tensor *t1)
     * }
     */
    public static MemorySegment ggml_can_repeat$address() {
        return ggml_can_repeat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_can_repeat(const struct ggml_tensor *t0, const struct ggml_tensor *t1)
     * }
     */
    public static boolean ggml_can_repeat(MemorySegment t0, MemorySegment t1) {
        var mh$ = ggml_can_repeat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_can_repeat", t0, t1);
            }
            return (boolean)mh$.invokeExact(t0, t1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_tensor_overhead {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_tensor_overhead");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_tensor_overhead()
     * }
     */
    public static FunctionDescriptor ggml_tensor_overhead$descriptor() {
        return ggml_tensor_overhead.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_tensor_overhead()
     * }
     */
    public static MethodHandle ggml_tensor_overhead$handle() {
        return ggml_tensor_overhead.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_tensor_overhead()
     * }
     */
    public static MemorySegment ggml_tensor_overhead$address() {
        return ggml_tensor_overhead.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_tensor_overhead()
     * }
     */
    public static long ggml_tensor_overhead() {
        var mh$ = ggml_tensor_overhead.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_tensor_overhead");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_validate_row_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_validate_row_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_validate_row_data(enum ggml_type type, const void *data, size_t nbytes)
     * }
     */
    public static FunctionDescriptor ggml_validate_row_data$descriptor() {
        return ggml_validate_row_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_validate_row_data(enum ggml_type type, const void *data, size_t nbytes)
     * }
     */
    public static MethodHandle ggml_validate_row_data$handle() {
        return ggml_validate_row_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_validate_row_data(enum ggml_type type, const void *data, size_t nbytes)
     * }
     */
    public static MemorySegment ggml_validate_row_data$address() {
        return ggml_validate_row_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_validate_row_data(enum ggml_type type, const void *data, size_t nbytes)
     * }
     */
    public static boolean ggml_validate_row_data(int type, MemorySegment data, long nbytes) {
        var mh$ = ggml_validate_row_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_validate_row_data", type, data, nbytes);
            }
            return (boolean)mh$.invokeExact(type, data, nbytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            ggml_init_params.layout()
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_context *ggml_init(struct ggml_init_params params)
     * }
     */
    public static FunctionDescriptor ggml_init$descriptor() {
        return ggml_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_context *ggml_init(struct ggml_init_params params)
     * }
     */
    public static MethodHandle ggml_init$handle() {
        return ggml_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_context *ggml_init(struct ggml_init_params params)
     * }
     */
    public static MemorySegment ggml_init$address() {
        return ggml_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_context *ggml_init(struct ggml_init_params params)
     * }
     */
    public static MemorySegment ggml_init(MemorySegment params) {
        var mh$ = ggml_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_init", params);
            }
            return (MemorySegment)mh$.invokeExact(params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_reset(struct ggml_context *ctx)
     * }
     */
    public static FunctionDescriptor ggml_reset$descriptor() {
        return ggml_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_reset(struct ggml_context *ctx)
     * }
     */
    public static MethodHandle ggml_reset$handle() {
        return ggml_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_reset(struct ggml_context *ctx)
     * }
     */
    public static MemorySegment ggml_reset$address() {
        return ggml_reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_reset(struct ggml_context *ctx)
     * }
     */
    public static void ggml_reset(MemorySegment ctx) {
        var mh$ = ggml_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_reset", ctx);
            }
            mh$.invokeExact(ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_free(struct ggml_context *ctx)
     * }
     */
    public static FunctionDescriptor ggml_free$descriptor() {
        return ggml_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_free(struct ggml_context *ctx)
     * }
     */
    public static MethodHandle ggml_free$handle() {
        return ggml_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_free(struct ggml_context *ctx)
     * }
     */
    public static MemorySegment ggml_free$address() {
        return ggml_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_free(struct ggml_context *ctx)
     * }
     */
    public static void ggml_free(MemorySegment ctx) {
        var mh$ = ggml_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_free", ctx);
            }
            mh$.invokeExact(ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_used_mem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_used_mem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_used_mem(const struct ggml_context *ctx)
     * }
     */
    public static FunctionDescriptor ggml_used_mem$descriptor() {
        return ggml_used_mem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_used_mem(const struct ggml_context *ctx)
     * }
     */
    public static MethodHandle ggml_used_mem$handle() {
        return ggml_used_mem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_used_mem(const struct ggml_context *ctx)
     * }
     */
    public static MemorySegment ggml_used_mem$address() {
        return ggml_used_mem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_used_mem(const struct ggml_context *ctx)
     * }
     */
    public static long ggml_used_mem(MemorySegment ctx) {
        var mh$ = ggml_used_mem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_used_mem", ctx);
            }
            return (long)mh$.invokeExact(ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_no_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_no_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_get_no_alloc(struct ggml_context *ctx)
     * }
     */
    public static FunctionDescriptor ggml_get_no_alloc$descriptor() {
        return ggml_get_no_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_get_no_alloc(struct ggml_context *ctx)
     * }
     */
    public static MethodHandle ggml_get_no_alloc$handle() {
        return ggml_get_no_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_get_no_alloc(struct ggml_context *ctx)
     * }
     */
    public static MemorySegment ggml_get_no_alloc$address() {
        return ggml_get_no_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_get_no_alloc(struct ggml_context *ctx)
     * }
     */
    public static boolean ggml_get_no_alloc(MemorySegment ctx) {
        var mh$ = ggml_get_no_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_no_alloc", ctx);
            }
            return (boolean)mh$.invokeExact(ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_no_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_BOOL
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set_no_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_set_no_alloc(struct ggml_context *ctx, bool no_alloc)
     * }
     */
    public static FunctionDescriptor ggml_set_no_alloc$descriptor() {
        return ggml_set_no_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_set_no_alloc(struct ggml_context *ctx, bool no_alloc)
     * }
     */
    public static MethodHandle ggml_set_no_alloc$handle() {
        return ggml_set_no_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_set_no_alloc(struct ggml_context *ctx, bool no_alloc)
     * }
     */
    public static MemorySegment ggml_set_no_alloc$address() {
        return ggml_set_no_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_set_no_alloc(struct ggml_context *ctx, bool no_alloc)
     * }
     */
    public static void ggml_set_no_alloc(MemorySegment ctx, boolean no_alloc) {
        var mh$ = ggml_set_no_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_no_alloc", ctx, no_alloc);
            }
            mh$.invokeExact(ctx, no_alloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_mem_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_mem_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *ggml_get_mem_buffer(const struct ggml_context *ctx)
     * }
     */
    public static FunctionDescriptor ggml_get_mem_buffer$descriptor() {
        return ggml_get_mem_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *ggml_get_mem_buffer(const struct ggml_context *ctx)
     * }
     */
    public static MethodHandle ggml_get_mem_buffer$handle() {
        return ggml_get_mem_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *ggml_get_mem_buffer(const struct ggml_context *ctx)
     * }
     */
    public static MemorySegment ggml_get_mem_buffer$address() {
        return ggml_get_mem_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *ggml_get_mem_buffer(const struct ggml_context *ctx)
     * }
     */
    public static MemorySegment ggml_get_mem_buffer(MemorySegment ctx) {
        var mh$ = ggml_get_mem_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_mem_buffer", ctx);
            }
            return (MemorySegment)mh$.invokeExact(ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_mem_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_mem_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_get_mem_size(const struct ggml_context *ctx)
     * }
     */
    public static FunctionDescriptor ggml_get_mem_size$descriptor() {
        return ggml_get_mem_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_get_mem_size(const struct ggml_context *ctx)
     * }
     */
    public static MethodHandle ggml_get_mem_size$handle() {
        return ggml_get_mem_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_get_mem_size(const struct ggml_context *ctx)
     * }
     */
    public static MemorySegment ggml_get_mem_size$address() {
        return ggml_get_mem_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_get_mem_size(const struct ggml_context *ctx)
     * }
     */
    public static long ggml_get_mem_size(MemorySegment ctx) {
        var mh$ = ggml_get_mem_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_mem_size", ctx);
            }
            return (long)mh$.invokeExact(ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_max_tensor_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_max_tensor_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_get_max_tensor_size(const struct ggml_context *ctx)
     * }
     */
    public static FunctionDescriptor ggml_get_max_tensor_size$descriptor() {
        return ggml_get_max_tensor_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_get_max_tensor_size(const struct ggml_context *ctx)
     * }
     */
    public static MethodHandle ggml_get_max_tensor_size$handle() {
        return ggml_get_max_tensor_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_get_max_tensor_size(const struct ggml_context *ctx)
     * }
     */
    public static MemorySegment ggml_get_max_tensor_size$address() {
        return ggml_get_max_tensor_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_get_max_tensor_size(const struct ggml_context *ctx)
     * }
     */
    public static long ggml_get_max_tensor_size(MemorySegment ctx) {
        var mh$ = ggml_get_max_tensor_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_max_tensor_size", ctx);
            }
            return (long)mh$.invokeExact(ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_new_tensor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_new_tensor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_tensor(struct ggml_context *ctx, enum ggml_type type, int n_dims, const int64_t *ne)
     * }
     */
    public static FunctionDescriptor ggml_new_tensor$descriptor() {
        return ggml_new_tensor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_tensor(struct ggml_context *ctx, enum ggml_type type, int n_dims, const int64_t *ne)
     * }
     */
    public static MethodHandle ggml_new_tensor$handle() {
        return ggml_new_tensor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_tensor(struct ggml_context *ctx, enum ggml_type type, int n_dims, const int64_t *ne)
     * }
     */
    public static MemorySegment ggml_new_tensor$address() {
        return ggml_new_tensor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_tensor(struct ggml_context *ctx, enum ggml_type type, int n_dims, const int64_t *ne)
     * }
     */
    public static MemorySegment ggml_new_tensor(MemorySegment ctx, int type, int n_dims, MemorySegment ne) {
        var mh$ = ggml_new_tensor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_new_tensor", ctx, type, n_dims, ne);
            }
            return (MemorySegment)mh$.invokeExact(ctx, type, n_dims, ne);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_new_tensor_1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_new_tensor_1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_tensor_1d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0)
     * }
     */
    public static FunctionDescriptor ggml_new_tensor_1d$descriptor() {
        return ggml_new_tensor_1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_tensor_1d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0)
     * }
     */
    public static MethodHandle ggml_new_tensor_1d$handle() {
        return ggml_new_tensor_1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_tensor_1d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0)
     * }
     */
    public static MemorySegment ggml_new_tensor_1d$address() {
        return ggml_new_tensor_1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_tensor_1d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0)
     * }
     */
    public static MemorySegment ggml_new_tensor_1d(MemorySegment ctx, int type, long ne0) {
        var mh$ = ggml_new_tensor_1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_new_tensor_1d", ctx, type, ne0);
            }
            return (MemorySegment)mh$.invokeExact(ctx, type, ne0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_new_tensor_2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_new_tensor_2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_tensor_2d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0, int64_t ne1)
     * }
     */
    public static FunctionDescriptor ggml_new_tensor_2d$descriptor() {
        return ggml_new_tensor_2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_tensor_2d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0, int64_t ne1)
     * }
     */
    public static MethodHandle ggml_new_tensor_2d$handle() {
        return ggml_new_tensor_2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_tensor_2d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0, int64_t ne1)
     * }
     */
    public static MemorySegment ggml_new_tensor_2d$address() {
        return ggml_new_tensor_2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_tensor_2d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0, int64_t ne1)
     * }
     */
    public static MemorySegment ggml_new_tensor_2d(MemorySegment ctx, int type, long ne0, long ne1) {
        var mh$ = ggml_new_tensor_2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_new_tensor_2d", ctx, type, ne0, ne1);
            }
            return (MemorySegment)mh$.invokeExact(ctx, type, ne0, ne1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_new_tensor_3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_new_tensor_3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_tensor_3d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0, int64_t ne1, int64_t ne2)
     * }
     */
    public static FunctionDescriptor ggml_new_tensor_3d$descriptor() {
        return ggml_new_tensor_3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_tensor_3d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0, int64_t ne1, int64_t ne2)
     * }
     */
    public static MethodHandle ggml_new_tensor_3d$handle() {
        return ggml_new_tensor_3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_tensor_3d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0, int64_t ne1, int64_t ne2)
     * }
     */
    public static MemorySegment ggml_new_tensor_3d$address() {
        return ggml_new_tensor_3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_tensor_3d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0, int64_t ne1, int64_t ne2)
     * }
     */
    public static MemorySegment ggml_new_tensor_3d(MemorySegment ctx, int type, long ne0, long ne1, long ne2) {
        var mh$ = ggml_new_tensor_3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_new_tensor_3d", ctx, type, ne0, ne1, ne2);
            }
            return (MemorySegment)mh$.invokeExact(ctx, type, ne0, ne1, ne2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_new_tensor_4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_new_tensor_4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_tensor_4d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3)
     * }
     */
    public static FunctionDescriptor ggml_new_tensor_4d$descriptor() {
        return ggml_new_tensor_4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_tensor_4d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3)
     * }
     */
    public static MethodHandle ggml_new_tensor_4d$handle() {
        return ggml_new_tensor_4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_tensor_4d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3)
     * }
     */
    public static MemorySegment ggml_new_tensor_4d$address() {
        return ggml_new_tensor_4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_tensor_4d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3)
     * }
     */
    public static MemorySegment ggml_new_tensor_4d(MemorySegment ctx, int type, long ne0, long ne1, long ne2, long ne3) {
        var mh$ = ggml_new_tensor_4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_new_tensor_4d", ctx, type, ne0, ne1, ne2, ne3);
            }
            return (MemorySegment)mh$.invokeExact(ctx, type, ne0, ne1, ne2, ne3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_new_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_new_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *ggml_new_buffer(struct ggml_context *ctx, size_t nbytes)
     * }
     */
    public static FunctionDescriptor ggml_new_buffer$descriptor() {
        return ggml_new_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *ggml_new_buffer(struct ggml_context *ctx, size_t nbytes)
     * }
     */
    public static MethodHandle ggml_new_buffer$handle() {
        return ggml_new_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *ggml_new_buffer(struct ggml_context *ctx, size_t nbytes)
     * }
     */
    public static MemorySegment ggml_new_buffer$address() {
        return ggml_new_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *ggml_new_buffer(struct ggml_context *ctx, size_t nbytes)
     * }
     */
    public static MemorySegment ggml_new_buffer(MemorySegment ctx, long nbytes) {
        var mh$ = ggml_new_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_new_buffer", ctx, nbytes);
            }
            return (MemorySegment)mh$.invokeExact(ctx, nbytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_dup_tensor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_dup_tensor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_dup_tensor(struct ggml_context *ctx, const struct ggml_tensor *src)
     * }
     */
    public static FunctionDescriptor ggml_dup_tensor$descriptor() {
        return ggml_dup_tensor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_dup_tensor(struct ggml_context *ctx, const struct ggml_tensor *src)
     * }
     */
    public static MethodHandle ggml_dup_tensor$handle() {
        return ggml_dup_tensor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_dup_tensor(struct ggml_context *ctx, const struct ggml_tensor *src)
     * }
     */
    public static MemorySegment ggml_dup_tensor$address() {
        return ggml_dup_tensor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_dup_tensor(struct ggml_context *ctx, const struct ggml_tensor *src)
     * }
     */
    public static MemorySegment ggml_dup_tensor(MemorySegment ctx, MemorySegment src) {
        var mh$ = ggml_dup_tensor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_dup_tensor", ctx, src);
            }
            return (MemorySegment)mh$.invokeExact(ctx, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_view_tensor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_view_tensor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_view_tensor(struct ggml_context *ctx, struct ggml_tensor *src)
     * }
     */
    public static FunctionDescriptor ggml_view_tensor$descriptor() {
        return ggml_view_tensor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_view_tensor(struct ggml_context *ctx, struct ggml_tensor *src)
     * }
     */
    public static MethodHandle ggml_view_tensor$handle() {
        return ggml_view_tensor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_view_tensor(struct ggml_context *ctx, struct ggml_tensor *src)
     * }
     */
    public static MemorySegment ggml_view_tensor$address() {
        return ggml_view_tensor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_view_tensor(struct ggml_context *ctx, struct ggml_tensor *src)
     * }
     */
    public static MemorySegment ggml_view_tensor(MemorySegment ctx, MemorySegment src) {
        var mh$ = ggml_view_tensor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_view_tensor", ctx, src);
            }
            return (MemorySegment)mh$.invokeExact(ctx, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_first_tensor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_first_tensor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_first_tensor(const struct ggml_context *ctx)
     * }
     */
    public static FunctionDescriptor ggml_get_first_tensor$descriptor() {
        return ggml_get_first_tensor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_first_tensor(const struct ggml_context *ctx)
     * }
     */
    public static MethodHandle ggml_get_first_tensor$handle() {
        return ggml_get_first_tensor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_first_tensor(const struct ggml_context *ctx)
     * }
     */
    public static MemorySegment ggml_get_first_tensor$address() {
        return ggml_get_first_tensor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_first_tensor(const struct ggml_context *ctx)
     * }
     */
    public static MemorySegment ggml_get_first_tensor(MemorySegment ctx) {
        var mh$ = ggml_get_first_tensor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_first_tensor", ctx);
            }
            return (MemorySegment)mh$.invokeExact(ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_next_tensor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_next_tensor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_next_tensor(const struct ggml_context *ctx, struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_get_next_tensor$descriptor() {
        return ggml_get_next_tensor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_next_tensor(const struct ggml_context *ctx, struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_get_next_tensor$handle() {
        return ggml_get_next_tensor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_next_tensor(const struct ggml_context *ctx, struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_get_next_tensor$address() {
        return ggml_get_next_tensor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_next_tensor(const struct ggml_context *ctx, struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_get_next_tensor(MemorySegment ctx, MemorySegment tensor) {
        var mh$ = ggml_get_next_tensor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_next_tensor", ctx, tensor);
            }
            return (MemorySegment)mh$.invokeExact(ctx, tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_tensor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_tensor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_tensor(struct ggml_context *ctx, const char *name)
     * }
     */
    public static FunctionDescriptor ggml_get_tensor$descriptor() {
        return ggml_get_tensor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_tensor(struct ggml_context *ctx, const char *name)
     * }
     */
    public static MethodHandle ggml_get_tensor$handle() {
        return ggml_get_tensor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_tensor(struct ggml_context *ctx, const char *name)
     * }
     */
    public static MemorySegment ggml_get_tensor$address() {
        return ggml_get_tensor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_tensor(struct ggml_context *ctx, const char *name)
     * }
     */
    public static MemorySegment ggml_get_tensor(MemorySegment ctx, MemorySegment name) {
        var mh$ = ggml_get_tensor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_tensor", ctx, name);
            }
            return (MemorySegment)mh$.invokeExact(ctx, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_unravel_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_unravel_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_unravel_index(const struct ggml_tensor *tensor, int64_t i, int64_t *i0, int64_t *i1, int64_t *i2, int64_t *i3)
     * }
     */
    public static FunctionDescriptor ggml_unravel_index$descriptor() {
        return ggml_unravel_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_unravel_index(const struct ggml_tensor *tensor, int64_t i, int64_t *i0, int64_t *i1, int64_t *i2, int64_t *i3)
     * }
     */
    public static MethodHandle ggml_unravel_index$handle() {
        return ggml_unravel_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_unravel_index(const struct ggml_tensor *tensor, int64_t i, int64_t *i0, int64_t *i1, int64_t *i2, int64_t *i3)
     * }
     */
    public static MemorySegment ggml_unravel_index$address() {
        return ggml_unravel_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_unravel_index(const struct ggml_tensor *tensor, int64_t i, int64_t *i0, int64_t *i1, int64_t *i2, int64_t *i3)
     * }
     */
    public static void ggml_unravel_index(MemorySegment tensor, long i, MemorySegment i0, MemorySegment i1, MemorySegment i2, MemorySegment i3) {
        var mh$ = ggml_unravel_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_unravel_index", tensor, i, i0, i1, i2, i3);
            }
            mh$.invokeExact(tensor, i, i0, i1, i2, i3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_unary_op {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_unary_op");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_unary_op ggml_get_unary_op(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_get_unary_op$descriptor() {
        return ggml_get_unary_op.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_unary_op ggml_get_unary_op(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_get_unary_op$handle() {
        return ggml_get_unary_op.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_unary_op ggml_get_unary_op(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_get_unary_op$address() {
        return ggml_get_unary_op.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_unary_op ggml_get_unary_op(const struct ggml_tensor *tensor)
     * }
     */
    public static int ggml_get_unary_op(MemorySegment tensor) {
        var mh$ = ggml_get_unary_op.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_unary_op", tensor);
            }
            return (int)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_glu_op {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_glu_op");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_glu_op ggml_get_glu_op(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_get_glu_op$descriptor() {
        return ggml_get_glu_op.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_glu_op ggml_get_glu_op(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_get_glu_op$handle() {
        return ggml_get_glu_op.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_glu_op ggml_get_glu_op(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_get_glu_op$address() {
        return ggml_get_glu_op.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_glu_op ggml_get_glu_op(const struct ggml_tensor *tensor)
     * }
     */
    public static int ggml_get_glu_op(MemorySegment tensor) {
        var mh$ = ggml_get_glu_op.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_glu_op", tensor);
            }
            return (int)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *ggml_get_data(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_get_data$descriptor() {
        return ggml_get_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *ggml_get_data(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_get_data$handle() {
        return ggml_get_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *ggml_get_data(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_get_data$address() {
        return ggml_get_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *ggml_get_data(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_get_data(MemorySegment tensor) {
        var mh$ = ggml_get_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_data", tensor);
            }
            return (MemorySegment)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_data_f32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_data_f32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float *ggml_get_data_f32(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_get_data_f32$descriptor() {
        return ggml_get_data_f32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float *ggml_get_data_f32(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_get_data_f32$handle() {
        return ggml_get_data_f32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float *ggml_get_data_f32(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_get_data_f32$address() {
        return ggml_get_data_f32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float *ggml_get_data_f32(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_get_data_f32(MemorySegment tensor) {
        var mh$ = ggml_get_data_f32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_data_f32", tensor);
            }
            return (MemorySegment)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ggml_get_name(const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_get_name$descriptor() {
        return ggml_get_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ggml_get_name(const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_get_name$handle() {
        return ggml_get_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ggml_get_name(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_get_name$address() {
        return ggml_get_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ggml_get_name(const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_get_name(MemorySegment tensor) {
        var mh$ = ggml_get_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_name", tensor);
            }
            return (MemorySegment)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_name(struct ggml_tensor *tensor, const char *name)
     * }
     */
    public static FunctionDescriptor ggml_set_name$descriptor() {
        return ggml_set_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_name(struct ggml_tensor *tensor, const char *name)
     * }
     */
    public static MethodHandle ggml_set_name$handle() {
        return ggml_set_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_name(struct ggml_tensor *tensor, const char *name)
     * }
     */
    public static MemorySegment ggml_set_name$address() {
        return ggml_set_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_name(struct ggml_tensor *tensor, const char *name)
     * }
     */
    public static MemorySegment ggml_set_name(MemorySegment tensor, MemorySegment name) {
        var mh$ = ggml_set_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_name", tensor, name);
            }
            return (MemorySegment)mh$.invokeExact(tensor, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_format_name(struct ggml_tensor *tensor, const char *fmt, ...)
     * }
     */
    public static class ggml_format_name {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                WhisperCpp.C_POINTER,
                WhisperCpp.C_POINTER,
                WhisperCpp.C_POINTER
            );
        private static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_format_name");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private ggml_format_name(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern struct ggml_tensor *ggml_format_name(struct ggml_tensor *tensor, const char *fmt, ...)
         * }
         */
        public static ggml_format_name makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new ggml_format_name(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(MemorySegment tensor, MemorySegment fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("ggml_format_name", tensor, fmt, x2);
                }
                return (MemorySegment) spreader.invokeExact(tensor, fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class ggml_set_input {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set_input");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_set_input(struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_set_input$descriptor() {
        return ggml_set_input.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_set_input(struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_set_input$handle() {
        return ggml_set_input.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_set_input(struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_set_input$address() {
        return ggml_set_input.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_set_input(struct ggml_tensor *tensor)
     * }
     */
    public static void ggml_set_input(MemorySegment tensor) {
        var mh$ = ggml_set_input.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_input", tensor);
            }
            mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_output {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set_output");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_set_output(struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_set_output$descriptor() {
        return ggml_set_output.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_set_output(struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_set_output$handle() {
        return ggml_set_output.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_set_output(struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_set_output$address() {
        return ggml_set_output.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_set_output(struct ggml_tensor *tensor)
     * }
     */
    public static void ggml_set_output(MemorySegment tensor) {
        var mh$ = ggml_set_output.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_output", tensor);
            }
            mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_param {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set_param");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_set_param(struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_set_param$descriptor() {
        return ggml_set_param.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_set_param(struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_set_param$handle() {
        return ggml_set_param.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_set_param(struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_set_param$address() {
        return ggml_set_param.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_set_param(struct ggml_tensor *tensor)
     * }
     */
    public static void ggml_set_param(MemorySegment tensor) {
        var mh$ = ggml_set_param.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_param", tensor);
            }
            mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_loss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set_loss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_set_loss(struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_set_loss$descriptor() {
        return ggml_set_loss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_set_loss(struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_set_loss$handle() {
        return ggml_set_loss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_set_loss(struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_set_loss$address() {
        return ggml_set_loss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_set_loss(struct ggml_tensor *tensor)
     * }
     */
    public static void ggml_set_loss(MemorySegment tensor) {
        var mh$ = ggml_set_loss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_loss", tensor);
            }
            mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_dup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_dup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_dup(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_dup$descriptor() {
        return ggml_dup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_dup(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_dup$handle() {
        return ggml_dup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_dup(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_dup$address() {
        return ggml_dup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_dup(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_dup(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_dup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_dup", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_dup_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_dup_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_dup_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_dup_inplace$descriptor() {
        return ggml_dup_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_dup_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_dup_inplace$handle() {
        return ggml_dup_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_dup_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_dup_inplace$address() {
        return ggml_dup_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_dup_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_dup_inplace(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_dup_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_dup_inplace", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_add$descriptor() {
        return ggml_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_add$handle() {
        return ggml_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_add$address() {
        return ggml_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_add(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_add", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_add_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_add_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_add_inplace$descriptor() {
        return ggml_add_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_add_inplace$handle() {
        return ggml_add_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_add_inplace$address() {
        return ggml_add_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_add_inplace(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_add_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_add_inplace", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_add_cast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_add_cast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_cast(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, enum ggml_type type)
     * }
     */
    public static FunctionDescriptor ggml_add_cast$descriptor() {
        return ggml_add_cast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_cast(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, enum ggml_type type)
     * }
     */
    public static MethodHandle ggml_add_cast$handle() {
        return ggml_add_cast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_cast(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, enum ggml_type type)
     * }
     */
    public static MemorySegment ggml_add_cast$address() {
        return ggml_add_cast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_cast(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, enum ggml_type type)
     * }
     */
    public static MemorySegment ggml_add_cast(MemorySegment ctx, MemorySegment a, MemorySegment b, int type) {
        var mh$ = ggml_add_cast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_add_cast", ctx, a, b, type);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_add_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_add_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_id(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *ids)
     * }
     */
    public static FunctionDescriptor ggml_add_id$descriptor() {
        return ggml_add_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_id(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *ids)
     * }
     */
    public static MethodHandle ggml_add_id$handle() {
        return ggml_add_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_id(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *ids)
     * }
     */
    public static MemorySegment ggml_add_id$address() {
        return ggml_add_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_id(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *ids)
     * }
     */
    public static MemorySegment ggml_add_id(MemorySegment ctx, MemorySegment a, MemorySegment b, MemorySegment ids) {
        var mh$ = ggml_add_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_add_id", ctx, a, b, ids);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, ids);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_add1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_add1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add1(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_add1$descriptor() {
        return ggml_add1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add1(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_add1$handle() {
        return ggml_add1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add1(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_add1$address() {
        return ggml_add1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add1(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_add1(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_add1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_add1", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_add1_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_add1_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add1_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_add1_inplace$descriptor() {
        return ggml_add1_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add1_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_add1_inplace$handle() {
        return ggml_add1_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add1_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_add1_inplace$address() {
        return ggml_add1_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add1_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_add1_inplace(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_add1_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_add1_inplace", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_acc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_acc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_acc(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t nb2, size_t nb3, size_t offset)
     * }
     */
    public static FunctionDescriptor ggml_acc$descriptor() {
        return ggml_acc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_acc(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t nb2, size_t nb3, size_t offset)
     * }
     */
    public static MethodHandle ggml_acc$handle() {
        return ggml_acc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_acc(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t nb2, size_t nb3, size_t offset)
     * }
     */
    public static MemorySegment ggml_acc$address() {
        return ggml_acc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_acc(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t nb2, size_t nb3, size_t offset)
     * }
     */
    public static MemorySegment ggml_acc(MemorySegment ctx, MemorySegment a, MemorySegment b, long nb1, long nb2, long nb3, long offset) {
        var mh$ = ggml_acc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_acc", ctx, a, b, nb1, nb2, nb3, offset);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, nb1, nb2, nb3, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_acc_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_acc_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_acc_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t nb2, size_t nb3, size_t offset)
     * }
     */
    public static FunctionDescriptor ggml_acc_inplace$descriptor() {
        return ggml_acc_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_acc_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t nb2, size_t nb3, size_t offset)
     * }
     */
    public static MethodHandle ggml_acc_inplace$handle() {
        return ggml_acc_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_acc_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t nb2, size_t nb3, size_t offset)
     * }
     */
    public static MemorySegment ggml_acc_inplace$address() {
        return ggml_acc_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_acc_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t nb2, size_t nb3, size_t offset)
     * }
     */
    public static MemorySegment ggml_acc_inplace(MemorySegment ctx, MemorySegment a, MemorySegment b, long nb1, long nb2, long nb3, long offset) {
        var mh$ = ggml_acc_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_acc_inplace", ctx, a, b, nb1, nb2, nb3, offset);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, nb1, nb2, nb3, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_sub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_sub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sub(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_sub$descriptor() {
        return ggml_sub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sub(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_sub$handle() {
        return ggml_sub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sub(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_sub$address() {
        return ggml_sub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sub(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_sub(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_sub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_sub", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_sub_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_sub_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sub_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_sub_inplace$descriptor() {
        return ggml_sub_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sub_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_sub_inplace$handle() {
        return ggml_sub_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sub_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_sub_inplace$address() {
        return ggml_sub_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sub_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_sub_inplace(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_sub_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_sub_inplace", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_mul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_mul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_mul(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_mul$descriptor() {
        return ggml_mul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_mul(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_mul$handle() {
        return ggml_mul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_mul(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_mul$address() {
        return ggml_mul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_mul(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_mul(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_mul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_mul", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_mul_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_mul_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_mul_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_mul_inplace$descriptor() {
        return ggml_mul_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_mul_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_mul_inplace$handle() {
        return ggml_mul_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_mul_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_mul_inplace$address() {
        return ggml_mul_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_mul_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_mul_inplace(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_mul_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_mul_inplace", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_div {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_div");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_div(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_div$descriptor() {
        return ggml_div.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_div(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_div$handle() {
        return ggml_div.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_div(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_div$address() {
        return ggml_div.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_div(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_div(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_div.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_div", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_div_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_div_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_div_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_div_inplace$descriptor() {
        return ggml_div_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_div_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_div_inplace$handle() {
        return ggml_div_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_div_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_div_inplace$address() {
        return ggml_div_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_div_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_div_inplace(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_div_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_div_inplace", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_sqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_sqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sqr(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_sqr$descriptor() {
        return ggml_sqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sqr(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_sqr$handle() {
        return ggml_sqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sqr(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sqr$address() {
        return ggml_sqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sqr(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sqr(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_sqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_sqr", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_sqr_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_sqr_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sqr_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_sqr_inplace$descriptor() {
        return ggml_sqr_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sqr_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_sqr_inplace$handle() {
        return ggml_sqr_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sqr_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sqr_inplace$address() {
        return ggml_sqr_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sqr_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sqr_inplace(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_sqr_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_sqr_inplace", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_sqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_sqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sqrt(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_sqrt$descriptor() {
        return ggml_sqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sqrt(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_sqrt$handle() {
        return ggml_sqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sqrt(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sqrt$address() {
        return ggml_sqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sqrt(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sqrt(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_sqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_sqrt", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_sqrt_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_sqrt_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sqrt_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_sqrt_inplace$descriptor() {
        return ggml_sqrt_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sqrt_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_sqrt_inplace$handle() {
        return ggml_sqrt_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sqrt_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sqrt_inplace$address() {
        return ggml_sqrt_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sqrt_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sqrt_inplace(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_sqrt_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_sqrt_inplace", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_log {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_log");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_log(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_log$descriptor() {
        return ggml_log.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_log(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_log$handle() {
        return ggml_log.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_log(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_log$address() {
        return ggml_log.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_log(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_log(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_log.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_log", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_log_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_log_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_log_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_log_inplace$descriptor() {
        return ggml_log_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_log_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_log_inplace$handle() {
        return ggml_log_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_log_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_log_inplace$address() {
        return ggml_log_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_log_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_log_inplace(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_log_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_log_inplace", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_sin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_sin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sin(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_sin$descriptor() {
        return ggml_sin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sin(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_sin$handle() {
        return ggml_sin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sin(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sin$address() {
        return ggml_sin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sin(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sin(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_sin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_sin", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_sin_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_sin_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sin_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_sin_inplace$descriptor() {
        return ggml_sin_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sin_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_sin_inplace$handle() {
        return ggml_sin_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sin_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sin_inplace$address() {
        return ggml_sin_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sin_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sin_inplace(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_sin_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_sin_inplace", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cos(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_cos$descriptor() {
        return ggml_cos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cos(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_cos$handle() {
        return ggml_cos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cos(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_cos$address() {
        return ggml_cos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cos(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_cos(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_cos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cos", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cos_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cos_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cos_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_cos_inplace$descriptor() {
        return ggml_cos_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cos_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_cos_inplace$handle() {
        return ggml_cos_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cos_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_cos_inplace$address() {
        return ggml_cos_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cos_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_cos_inplace(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_cos_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cos_inplace", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_sum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_sum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sum(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_sum$descriptor() {
        return ggml_sum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sum(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_sum$handle() {
        return ggml_sum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sum(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sum$address() {
        return ggml_sum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sum(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sum(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_sum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_sum", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_sum_rows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_sum_rows");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sum_rows(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_sum_rows$descriptor() {
        return ggml_sum_rows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sum_rows(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_sum_rows$handle() {
        return ggml_sum_rows.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sum_rows(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sum_rows$address() {
        return ggml_sum_rows.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sum_rows(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sum_rows(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_sum_rows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_sum_rows", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_mean {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_mean");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_mean(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_mean$descriptor() {
        return ggml_mean.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_mean(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_mean$handle() {
        return ggml_mean.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_mean(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_mean$address() {
        return ggml_mean.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_mean(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_mean(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_mean.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_mean", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_argmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_argmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_argmax(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_argmax$descriptor() {
        return ggml_argmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_argmax(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_argmax$handle() {
        return ggml_argmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_argmax(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_argmax$address() {
        return ggml_argmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_argmax(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_argmax(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_argmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_argmax", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_count_equal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_count_equal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_count_equal(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_count_equal$descriptor() {
        return ggml_count_equal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_count_equal(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_count_equal$handle() {
        return ggml_count_equal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_count_equal(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_count_equal$address() {
        return ggml_count_equal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_count_equal(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_count_equal(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_count_equal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_count_equal", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_repeat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_repeat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_repeat(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_repeat$descriptor() {
        return ggml_repeat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_repeat(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_repeat$handle() {
        return ggml_repeat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_repeat(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_repeat$address() {
        return ggml_repeat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_repeat(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_repeat(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_repeat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_repeat", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_repeat_4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_repeat_4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_repeat_4d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3)
     * }
     */
    public static FunctionDescriptor ggml_repeat_4d$descriptor() {
        return ggml_repeat_4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_repeat_4d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3)
     * }
     */
    public static MethodHandle ggml_repeat_4d$handle() {
        return ggml_repeat_4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_repeat_4d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3)
     * }
     */
    public static MemorySegment ggml_repeat_4d$address() {
        return ggml_repeat_4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_repeat_4d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3)
     * }
     */
    public static MemorySegment ggml_repeat_4d(MemorySegment ctx, MemorySegment a, long ne0, long ne1, long ne2, long ne3) {
        var mh$ = ggml_repeat_4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_repeat_4d", ctx, a, ne0, ne1, ne2, ne3);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, ne0, ne1, ne2, ne3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_repeat_back {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_repeat_back");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_repeat_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_repeat_back$descriptor() {
        return ggml_repeat_back.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_repeat_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_repeat_back$handle() {
        return ggml_repeat_back.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_repeat_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_repeat_back$address() {
        return ggml_repeat_back.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_repeat_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_repeat_back(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_repeat_back.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_repeat_back", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_concat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_concat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_concat(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int dim)
     * }
     */
    public static FunctionDescriptor ggml_concat$descriptor() {
        return ggml_concat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_concat(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int dim)
     * }
     */
    public static MethodHandle ggml_concat$handle() {
        return ggml_concat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_concat(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int dim)
     * }
     */
    public static MemorySegment ggml_concat$address() {
        return ggml_concat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_concat(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int dim)
     * }
     */
    public static MemorySegment ggml_concat(MemorySegment ctx, MemorySegment a, MemorySegment b, int dim) {
        var mh$ = ggml_concat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_concat", ctx, a, b, dim);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, dim);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_abs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_abs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_abs(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_abs$descriptor() {
        return ggml_abs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_abs(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_abs$handle() {
        return ggml_abs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_abs(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_abs$address() {
        return ggml_abs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_abs(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_abs(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_abs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_abs", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_abs_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_abs_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_abs_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_abs_inplace$descriptor() {
        return ggml_abs_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_abs_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_abs_inplace$handle() {
        return ggml_abs_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_abs_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_abs_inplace$address() {
        return ggml_abs_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_abs_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_abs_inplace(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_abs_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_abs_inplace", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_sgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_sgn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sgn(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_sgn$descriptor() {
        return ggml_sgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sgn(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_sgn$handle() {
        return ggml_sgn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sgn(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sgn$address() {
        return ggml_sgn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sgn(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sgn(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_sgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_sgn", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_sgn_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_sgn_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sgn_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_sgn_inplace$descriptor() {
        return ggml_sgn_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sgn_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_sgn_inplace$handle() {
        return ggml_sgn_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sgn_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sgn_inplace$address() {
        return ggml_sgn_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sgn_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sgn_inplace(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_sgn_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_sgn_inplace", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_neg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_neg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_neg(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_neg$descriptor() {
        return ggml_neg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_neg(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_neg$handle() {
        return ggml_neg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_neg(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_neg$address() {
        return ggml_neg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_neg(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_neg(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_neg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_neg", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_neg_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_neg_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_neg_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_neg_inplace$descriptor() {
        return ggml_neg_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_neg_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_neg_inplace$handle() {
        return ggml_neg_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_neg_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_neg_inplace$address() {
        return ggml_neg_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_neg_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_neg_inplace(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_neg_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_neg_inplace", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_step {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_step");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_step(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_step$descriptor() {
        return ggml_step.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_step(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_step$handle() {
        return ggml_step.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_step(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_step$address() {
        return ggml_step.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_step(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_step(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_step.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_step", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_step_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_step_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_step_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_step_inplace$descriptor() {
        return ggml_step_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_step_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_step_inplace$handle() {
        return ggml_step_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_step_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_step_inplace$address() {
        return ggml_step_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_step_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_step_inplace(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_step_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_step_inplace", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_tanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_tanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_tanh(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_tanh$descriptor() {
        return ggml_tanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_tanh(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_tanh$handle() {
        return ggml_tanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_tanh(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_tanh$address() {
        return ggml_tanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_tanh(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_tanh(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_tanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_tanh", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_tanh_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_tanh_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_tanh_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_tanh_inplace$descriptor() {
        return ggml_tanh_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_tanh_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_tanh_inplace$handle() {
        return ggml_tanh_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_tanh_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_tanh_inplace$address() {
        return ggml_tanh_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_tanh_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_tanh_inplace(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_tanh_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_tanh_inplace", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_elu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_elu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_elu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_elu$descriptor() {
        return ggml_elu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_elu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_elu$handle() {
        return ggml_elu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_elu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_elu$address() {
        return ggml_elu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_elu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_elu(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_elu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_elu", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_elu_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_elu_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_elu_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_elu_inplace$descriptor() {
        return ggml_elu_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_elu_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_elu_inplace$handle() {
        return ggml_elu_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_elu_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_elu_inplace$address() {
        return ggml_elu_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_elu_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_elu_inplace(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_elu_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_elu_inplace", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_relu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_relu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_relu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_relu$descriptor() {
        return ggml_relu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_relu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_relu$handle() {
        return ggml_relu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_relu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_relu$address() {
        return ggml_relu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_relu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_relu(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_relu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_relu", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_leaky_relu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_BOOL
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_leaky_relu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_leaky_relu(struct ggml_context *ctx, struct ggml_tensor *a, float negative_slope, bool inplace)
     * }
     */
    public static FunctionDescriptor ggml_leaky_relu$descriptor() {
        return ggml_leaky_relu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_leaky_relu(struct ggml_context *ctx, struct ggml_tensor *a, float negative_slope, bool inplace)
     * }
     */
    public static MethodHandle ggml_leaky_relu$handle() {
        return ggml_leaky_relu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_leaky_relu(struct ggml_context *ctx, struct ggml_tensor *a, float negative_slope, bool inplace)
     * }
     */
    public static MemorySegment ggml_leaky_relu$address() {
        return ggml_leaky_relu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_leaky_relu(struct ggml_context *ctx, struct ggml_tensor *a, float negative_slope, bool inplace)
     * }
     */
    public static MemorySegment ggml_leaky_relu(MemorySegment ctx, MemorySegment a, float negative_slope, boolean inplace) {
        var mh$ = ggml_leaky_relu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_leaky_relu", ctx, a, negative_slope, inplace);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, negative_slope, inplace);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_relu_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_relu_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_relu_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_relu_inplace$descriptor() {
        return ggml_relu_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_relu_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_relu_inplace$handle() {
        return ggml_relu_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_relu_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_relu_inplace$address() {
        return ggml_relu_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_relu_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_relu_inplace(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_relu_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_relu_inplace", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_sigmoid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_sigmoid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sigmoid(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_sigmoid$descriptor() {
        return ggml_sigmoid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sigmoid(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_sigmoid$handle() {
        return ggml_sigmoid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sigmoid(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sigmoid$address() {
        return ggml_sigmoid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sigmoid(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sigmoid(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_sigmoid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_sigmoid", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_sigmoid_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_sigmoid_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sigmoid_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_sigmoid_inplace$descriptor() {
        return ggml_sigmoid_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sigmoid_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_sigmoid_inplace$handle() {
        return ggml_sigmoid_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sigmoid_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sigmoid_inplace$address() {
        return ggml_sigmoid_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_sigmoid_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_sigmoid_inplace(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_sigmoid_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_sigmoid_inplace", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_gelu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_gelu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_gelu$descriptor() {
        return ggml_gelu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_gelu$handle() {
        return ggml_gelu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_gelu$address() {
        return ggml_gelu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_gelu(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_gelu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_gelu", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_gelu_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_gelu_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_gelu_inplace$descriptor() {
        return ggml_gelu_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_gelu_inplace$handle() {
        return ggml_gelu_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_gelu_inplace$address() {
        return ggml_gelu_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_gelu_inplace(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_gelu_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_gelu_inplace", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_gelu_erf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_gelu_erf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu_erf(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_gelu_erf$descriptor() {
        return ggml_gelu_erf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu_erf(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_gelu_erf$handle() {
        return ggml_gelu_erf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu_erf(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_gelu_erf$address() {
        return ggml_gelu_erf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu_erf(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_gelu_erf(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_gelu_erf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_gelu_erf", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_gelu_erf_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_gelu_erf_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu_erf_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_gelu_erf_inplace$descriptor() {
        return ggml_gelu_erf_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu_erf_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_gelu_erf_inplace$handle() {
        return ggml_gelu_erf_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu_erf_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_gelu_erf_inplace$address() {
        return ggml_gelu_erf_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu_erf_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_gelu_erf_inplace(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_gelu_erf_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_gelu_erf_inplace", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_gelu_quick {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_gelu_quick");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu_quick(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_gelu_quick$descriptor() {
        return ggml_gelu_quick.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu_quick(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_gelu_quick$handle() {
        return ggml_gelu_quick.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu_quick(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_gelu_quick$address() {
        return ggml_gelu_quick.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu_quick(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_gelu_quick(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_gelu_quick.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_gelu_quick", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_gelu_quick_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_gelu_quick_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu_quick_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_gelu_quick_inplace$descriptor() {
        return ggml_gelu_quick_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu_quick_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_gelu_quick_inplace$handle() {
        return ggml_gelu_quick_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu_quick_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_gelu_quick_inplace$address() {
        return ggml_gelu_quick_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gelu_quick_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_gelu_quick_inplace(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_gelu_quick_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_gelu_quick_inplace", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_silu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_silu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_silu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_silu$descriptor() {
        return ggml_silu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_silu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_silu$handle() {
        return ggml_silu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_silu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_silu$address() {
        return ggml_silu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_silu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_silu(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_silu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_silu", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_silu_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_silu_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_silu_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_silu_inplace$descriptor() {
        return ggml_silu_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_silu_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_silu_inplace$handle() {
        return ggml_silu_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_silu_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_silu_inplace$address() {
        return ggml_silu_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_silu_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_silu_inplace(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_silu_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_silu_inplace", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_silu_back {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_silu_back");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_silu_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_silu_back$descriptor() {
        return ggml_silu_back.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_silu_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_silu_back$handle() {
        return ggml_silu_back.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_silu_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_silu_back$address() {
        return ggml_silu_back.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_silu_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_silu_back(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_silu_back.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_silu_back", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_hardswish {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_hardswish");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_hardswish(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_hardswish$descriptor() {
        return ggml_hardswish.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_hardswish(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_hardswish$handle() {
        return ggml_hardswish.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_hardswish(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_hardswish$address() {
        return ggml_hardswish.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_hardswish(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_hardswish(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_hardswish.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_hardswish", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_hardsigmoid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_hardsigmoid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_hardsigmoid(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_hardsigmoid$descriptor() {
        return ggml_hardsigmoid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_hardsigmoid(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_hardsigmoid$handle() {
        return ggml_hardsigmoid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_hardsigmoid(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_hardsigmoid$address() {
        return ggml_hardsigmoid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_hardsigmoid(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_hardsigmoid(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_hardsigmoid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_hardsigmoid", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_exp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_exp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_exp(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_exp$descriptor() {
        return ggml_exp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_exp(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_exp$handle() {
        return ggml_exp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_exp(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_exp$address() {
        return ggml_exp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_exp(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_exp(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_exp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_exp", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_exp_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_exp_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_exp_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_exp_inplace$descriptor() {
        return ggml_exp_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_exp_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_exp_inplace$handle() {
        return ggml_exp_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_exp_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_exp_inplace$address() {
        return ggml_exp_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_exp_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_exp_inplace(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_exp_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_exp_inplace", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_glu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_BOOL
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_glu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_glu(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_glu_op op, bool swapped)
     * }
     */
    public static FunctionDescriptor ggml_glu$descriptor() {
        return ggml_glu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_glu(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_glu_op op, bool swapped)
     * }
     */
    public static MethodHandle ggml_glu$handle() {
        return ggml_glu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_glu(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_glu_op op, bool swapped)
     * }
     */
    public static MemorySegment ggml_glu$address() {
        return ggml_glu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_glu(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_glu_op op, bool swapped)
     * }
     */
    public static MemorySegment ggml_glu(MemorySegment ctx, MemorySegment a, int op, boolean swapped) {
        var mh$ = ggml_glu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_glu", ctx, a, op, swapped);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, op, swapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_reglu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_reglu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reglu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_reglu$descriptor() {
        return ggml_reglu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reglu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_reglu$handle() {
        return ggml_reglu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reglu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_reglu$address() {
        return ggml_reglu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reglu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_reglu(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_reglu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_reglu", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_reglu_swapped {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_reglu_swapped");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reglu_swapped(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_reglu_swapped$descriptor() {
        return ggml_reglu_swapped.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reglu_swapped(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_reglu_swapped$handle() {
        return ggml_reglu_swapped.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reglu_swapped(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_reglu_swapped$address() {
        return ggml_reglu_swapped.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reglu_swapped(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_reglu_swapped(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_reglu_swapped.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_reglu_swapped", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_geglu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_geglu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_geglu$descriptor() {
        return ggml_geglu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_geglu$handle() {
        return ggml_geglu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_geglu$address() {
        return ggml_geglu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_geglu(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_geglu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_geglu", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_geglu_swapped {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_geglu_swapped");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_swapped(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_geglu_swapped$descriptor() {
        return ggml_geglu_swapped.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_swapped(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_geglu_swapped$handle() {
        return ggml_geglu_swapped.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_swapped(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_geglu_swapped$address() {
        return ggml_geglu_swapped.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_swapped(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_geglu_swapped(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_geglu_swapped.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_geglu_swapped", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_swiglu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_swiglu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_swiglu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_swiglu$descriptor() {
        return ggml_swiglu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_swiglu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_swiglu$handle() {
        return ggml_swiglu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_swiglu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_swiglu$address() {
        return ggml_swiglu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_swiglu(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_swiglu(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_swiglu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_swiglu", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_swiglu_swapped {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_swiglu_swapped");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_swiglu_swapped(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_swiglu_swapped$descriptor() {
        return ggml_swiglu_swapped.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_swiglu_swapped(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_swiglu_swapped$handle() {
        return ggml_swiglu_swapped.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_swiglu_swapped(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_swiglu_swapped$address() {
        return ggml_swiglu_swapped.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_swiglu_swapped(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_swiglu_swapped(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_swiglu_swapped.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_swiglu_swapped", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_geglu_erf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_geglu_erf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_erf(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_geglu_erf$descriptor() {
        return ggml_geglu_erf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_erf(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_geglu_erf$handle() {
        return ggml_geglu_erf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_erf(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_geglu_erf$address() {
        return ggml_geglu_erf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_erf(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_geglu_erf(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_geglu_erf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_geglu_erf", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_geglu_erf_swapped {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_geglu_erf_swapped");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_erf_swapped(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_geglu_erf_swapped$descriptor() {
        return ggml_geglu_erf_swapped.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_erf_swapped(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_geglu_erf_swapped$handle() {
        return ggml_geglu_erf_swapped.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_erf_swapped(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_geglu_erf_swapped$address() {
        return ggml_geglu_erf_swapped.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_erf_swapped(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_geglu_erf_swapped(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_geglu_erf_swapped.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_geglu_erf_swapped", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_geglu_quick {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_geglu_quick");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_quick(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_geglu_quick$descriptor() {
        return ggml_geglu_quick.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_quick(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_geglu_quick$handle() {
        return ggml_geglu_quick.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_quick(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_geglu_quick$address() {
        return ggml_geglu_quick.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_quick(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_geglu_quick(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_geglu_quick.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_geglu_quick", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_geglu_quick_swapped {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_geglu_quick_swapped");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_quick_swapped(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_geglu_quick_swapped$descriptor() {
        return ggml_geglu_quick_swapped.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_quick_swapped(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_geglu_quick_swapped$handle() {
        return ggml_geglu_quick_swapped.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_quick_swapped(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_geglu_quick_swapped$address() {
        return ggml_geglu_quick_swapped.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_quick_swapped(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_geglu_quick_swapped(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_geglu_quick_swapped.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_geglu_quick_swapped", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_glu_split {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_glu_split");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_glu_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, enum ggml_glu_op op)
     * }
     */
    public static FunctionDescriptor ggml_glu_split$descriptor() {
        return ggml_glu_split.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_glu_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, enum ggml_glu_op op)
     * }
     */
    public static MethodHandle ggml_glu_split$handle() {
        return ggml_glu_split.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_glu_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, enum ggml_glu_op op)
     * }
     */
    public static MemorySegment ggml_glu_split$address() {
        return ggml_glu_split.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_glu_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, enum ggml_glu_op op)
     * }
     */
    public static MemorySegment ggml_glu_split(MemorySegment ctx, MemorySegment a, MemorySegment b, int op) {
        var mh$ = ggml_glu_split.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_glu_split", ctx, a, b, op);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_reglu_split {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_reglu_split");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reglu_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_reglu_split$descriptor() {
        return ggml_reglu_split.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reglu_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_reglu_split$handle() {
        return ggml_reglu_split.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reglu_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_reglu_split$address() {
        return ggml_reglu_split.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reglu_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_reglu_split(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_reglu_split.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_reglu_split", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_geglu_split {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_geglu_split");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_geglu_split$descriptor() {
        return ggml_geglu_split.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_geglu_split$handle() {
        return ggml_geglu_split.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_geglu_split$address() {
        return ggml_geglu_split.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_geglu_split(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_geglu_split.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_geglu_split", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_swiglu_split {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_swiglu_split");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_swiglu_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_swiglu_split$descriptor() {
        return ggml_swiglu_split.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_swiglu_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_swiglu_split$handle() {
        return ggml_swiglu_split.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_swiglu_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_swiglu_split$address() {
        return ggml_swiglu_split.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_swiglu_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_swiglu_split(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_swiglu_split.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_swiglu_split", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_geglu_erf_split {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_geglu_erf_split");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_erf_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_geglu_erf_split$descriptor() {
        return ggml_geglu_erf_split.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_erf_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_geglu_erf_split$handle() {
        return ggml_geglu_erf_split.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_erf_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_geglu_erf_split$address() {
        return ggml_geglu_erf_split.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_erf_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_geglu_erf_split(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_geglu_erf_split.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_geglu_erf_split", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_geglu_quick_split {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_geglu_quick_split");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_quick_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_geglu_quick_split$descriptor() {
        return ggml_geglu_quick_split.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_quick_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_geglu_quick_split$handle() {
        return ggml_geglu_quick_split.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_quick_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_geglu_quick_split$address() {
        return ggml_geglu_quick_split.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_geglu_quick_split(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_geglu_quick_split(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_geglu_quick_split.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_geglu_quick_split", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_swiglu_oai {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_swiglu_oai");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_swiglu_oai(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, float alpha, float limit)
     * }
     */
    public static FunctionDescriptor ggml_swiglu_oai$descriptor() {
        return ggml_swiglu_oai.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_swiglu_oai(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, float alpha, float limit)
     * }
     */
    public static MethodHandle ggml_swiglu_oai$handle() {
        return ggml_swiglu_oai.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_swiglu_oai(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, float alpha, float limit)
     * }
     */
    public static MemorySegment ggml_swiglu_oai$address() {
        return ggml_swiglu_oai.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_swiglu_oai(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, float alpha, float limit)
     * }
     */
    public static MemorySegment ggml_swiglu_oai(MemorySegment ctx, MemorySegment a, MemorySegment b, float alpha, float limit) {
        var mh$ = ggml_swiglu_oai.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_swiglu_oai", ctx, a, b, alpha, limit);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, alpha, limit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_norm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_norm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_norm(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static FunctionDescriptor ggml_norm$descriptor() {
        return ggml_norm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_norm(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static MethodHandle ggml_norm$handle() {
        return ggml_norm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_norm(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static MemorySegment ggml_norm$address() {
        return ggml_norm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_norm(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static MemorySegment ggml_norm(MemorySegment ctx, MemorySegment a, float eps) {
        var mh$ = ggml_norm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_norm", ctx, a, eps);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, eps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_norm_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_norm_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_norm_inplace(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static FunctionDescriptor ggml_norm_inplace$descriptor() {
        return ggml_norm_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_norm_inplace(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static MethodHandle ggml_norm_inplace$handle() {
        return ggml_norm_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_norm_inplace(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static MemorySegment ggml_norm_inplace$address() {
        return ggml_norm_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_norm_inplace(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static MemorySegment ggml_norm_inplace(MemorySegment ctx, MemorySegment a, float eps) {
        var mh$ = ggml_norm_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_norm_inplace", ctx, a, eps);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, eps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_rms_norm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_rms_norm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rms_norm(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static FunctionDescriptor ggml_rms_norm$descriptor() {
        return ggml_rms_norm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rms_norm(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static MethodHandle ggml_rms_norm$handle() {
        return ggml_rms_norm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rms_norm(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static MemorySegment ggml_rms_norm$address() {
        return ggml_rms_norm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rms_norm(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static MemorySegment ggml_rms_norm(MemorySegment ctx, MemorySegment a, float eps) {
        var mh$ = ggml_rms_norm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_rms_norm", ctx, a, eps);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, eps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_rms_norm_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_rms_norm_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rms_norm_inplace(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static FunctionDescriptor ggml_rms_norm_inplace$descriptor() {
        return ggml_rms_norm_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rms_norm_inplace(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static MethodHandle ggml_rms_norm_inplace$handle() {
        return ggml_rms_norm_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rms_norm_inplace(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static MemorySegment ggml_rms_norm_inplace$address() {
        return ggml_rms_norm_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rms_norm_inplace(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static MemorySegment ggml_rms_norm_inplace(MemorySegment ctx, MemorySegment a, float eps) {
        var mh$ = ggml_rms_norm_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_rms_norm_inplace", ctx, a, eps);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, eps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_group_norm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_group_norm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_group_norm(struct ggml_context *ctx, struct ggml_tensor *a, int n_groups, float eps)
     * }
     */
    public static FunctionDescriptor ggml_group_norm$descriptor() {
        return ggml_group_norm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_group_norm(struct ggml_context *ctx, struct ggml_tensor *a, int n_groups, float eps)
     * }
     */
    public static MethodHandle ggml_group_norm$handle() {
        return ggml_group_norm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_group_norm(struct ggml_context *ctx, struct ggml_tensor *a, int n_groups, float eps)
     * }
     */
    public static MemorySegment ggml_group_norm$address() {
        return ggml_group_norm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_group_norm(struct ggml_context *ctx, struct ggml_tensor *a, int n_groups, float eps)
     * }
     */
    public static MemorySegment ggml_group_norm(MemorySegment ctx, MemorySegment a, int n_groups, float eps) {
        var mh$ = ggml_group_norm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_group_norm", ctx, a, n_groups, eps);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, n_groups, eps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_group_norm_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_group_norm_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_group_norm_inplace(struct ggml_context *ctx, struct ggml_tensor *a, int n_groups, float eps)
     * }
     */
    public static FunctionDescriptor ggml_group_norm_inplace$descriptor() {
        return ggml_group_norm_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_group_norm_inplace(struct ggml_context *ctx, struct ggml_tensor *a, int n_groups, float eps)
     * }
     */
    public static MethodHandle ggml_group_norm_inplace$handle() {
        return ggml_group_norm_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_group_norm_inplace(struct ggml_context *ctx, struct ggml_tensor *a, int n_groups, float eps)
     * }
     */
    public static MemorySegment ggml_group_norm_inplace$address() {
        return ggml_group_norm_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_group_norm_inplace(struct ggml_context *ctx, struct ggml_tensor *a, int n_groups, float eps)
     * }
     */
    public static MemorySegment ggml_group_norm_inplace(MemorySegment ctx, MemorySegment a, int n_groups, float eps) {
        var mh$ = ggml_group_norm_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_group_norm_inplace", ctx, a, n_groups, eps);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, n_groups, eps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_l2_norm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_l2_norm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_l2_norm(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static FunctionDescriptor ggml_l2_norm$descriptor() {
        return ggml_l2_norm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_l2_norm(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static MethodHandle ggml_l2_norm$handle() {
        return ggml_l2_norm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_l2_norm(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static MemorySegment ggml_l2_norm$address() {
        return ggml_l2_norm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_l2_norm(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static MemorySegment ggml_l2_norm(MemorySegment ctx, MemorySegment a, float eps) {
        var mh$ = ggml_l2_norm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_l2_norm", ctx, a, eps);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, eps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_l2_norm_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_l2_norm_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_l2_norm_inplace(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static FunctionDescriptor ggml_l2_norm_inplace$descriptor() {
        return ggml_l2_norm_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_l2_norm_inplace(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static MethodHandle ggml_l2_norm_inplace$handle() {
        return ggml_l2_norm_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_l2_norm_inplace(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static MemorySegment ggml_l2_norm_inplace$address() {
        return ggml_l2_norm_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_l2_norm_inplace(struct ggml_context *ctx, struct ggml_tensor *a, float eps)
     * }
     */
    public static MemorySegment ggml_l2_norm_inplace(MemorySegment ctx, MemorySegment a, float eps) {
        var mh$ = ggml_l2_norm_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_l2_norm_inplace", ctx, a, eps);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, eps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_rms_norm_back {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_rms_norm_back");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rms_norm_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, float eps)
     * }
     */
    public static FunctionDescriptor ggml_rms_norm_back$descriptor() {
        return ggml_rms_norm_back.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rms_norm_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, float eps)
     * }
     */
    public static MethodHandle ggml_rms_norm_back$handle() {
        return ggml_rms_norm_back.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rms_norm_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, float eps)
     * }
     */
    public static MemorySegment ggml_rms_norm_back$address() {
        return ggml_rms_norm_back.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rms_norm_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, float eps)
     * }
     */
    public static MemorySegment ggml_rms_norm_back(MemorySegment ctx, MemorySegment a, MemorySegment b, float eps) {
        var mh$ = ggml_rms_norm_back.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_rms_norm_back", ctx, a, b, eps);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, eps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_mul_mat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_mul_mat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_mul_mat(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_mul_mat$descriptor() {
        return ggml_mul_mat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_mul_mat(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_mul_mat$handle() {
        return ggml_mul_mat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_mul_mat(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_mul_mat$address() {
        return ggml_mul_mat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_mul_mat(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_mul_mat(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_mul_mat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_mul_mat", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_mul_mat_set_prec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_mul_mat_set_prec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_mul_mat_set_prec(struct ggml_tensor *a, enum ggml_prec prec)
     * }
     */
    public static FunctionDescriptor ggml_mul_mat_set_prec$descriptor() {
        return ggml_mul_mat_set_prec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_mul_mat_set_prec(struct ggml_tensor *a, enum ggml_prec prec)
     * }
     */
    public static MethodHandle ggml_mul_mat_set_prec$handle() {
        return ggml_mul_mat_set_prec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_mul_mat_set_prec(struct ggml_tensor *a, enum ggml_prec prec)
     * }
     */
    public static MemorySegment ggml_mul_mat_set_prec$address() {
        return ggml_mul_mat_set_prec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_mul_mat_set_prec(struct ggml_tensor *a, enum ggml_prec prec)
     * }
     */
    public static void ggml_mul_mat_set_prec(MemorySegment a, int prec) {
        var mh$ = ggml_mul_mat_set_prec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_mul_mat_set_prec", a, prec);
            }
            mh$.invokeExact(a, prec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_mul_mat_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_mul_mat_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_mul_mat_id(struct ggml_context *ctx, struct ggml_tensor *as, struct ggml_tensor *b, struct ggml_tensor *ids)
     * }
     */
    public static FunctionDescriptor ggml_mul_mat_id$descriptor() {
        return ggml_mul_mat_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_mul_mat_id(struct ggml_context *ctx, struct ggml_tensor *as, struct ggml_tensor *b, struct ggml_tensor *ids)
     * }
     */
    public static MethodHandle ggml_mul_mat_id$handle() {
        return ggml_mul_mat_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_mul_mat_id(struct ggml_context *ctx, struct ggml_tensor *as, struct ggml_tensor *b, struct ggml_tensor *ids)
     * }
     */
    public static MemorySegment ggml_mul_mat_id$address() {
        return ggml_mul_mat_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_mul_mat_id(struct ggml_context *ctx, struct ggml_tensor *as, struct ggml_tensor *b, struct ggml_tensor *ids)
     * }
     */
    public static MemorySegment ggml_mul_mat_id(MemorySegment ctx, MemorySegment as, MemorySegment b, MemorySegment ids) {
        var mh$ = ggml_mul_mat_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_mul_mat_id", ctx, as, b, ids);
            }
            return (MemorySegment)mh$.invokeExact(ctx, as, b, ids);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_out_prod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_out_prod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_out_prod(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_out_prod$descriptor() {
        return ggml_out_prod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_out_prod(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_out_prod$handle() {
        return ggml_out_prod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_out_prod(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_out_prod$address() {
        return ggml_out_prod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_out_prod(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_out_prod(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_out_prod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_out_prod", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_scale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_scale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_scale(struct ggml_context *ctx, struct ggml_tensor *a, float s)
     * }
     */
    public static FunctionDescriptor ggml_scale$descriptor() {
        return ggml_scale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_scale(struct ggml_context *ctx, struct ggml_tensor *a, float s)
     * }
     */
    public static MethodHandle ggml_scale$handle() {
        return ggml_scale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_scale(struct ggml_context *ctx, struct ggml_tensor *a, float s)
     * }
     */
    public static MemorySegment ggml_scale$address() {
        return ggml_scale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_scale(struct ggml_context *ctx, struct ggml_tensor *a, float s)
     * }
     */
    public static MemorySegment ggml_scale(MemorySegment ctx, MemorySegment a, float s) {
        var mh$ = ggml_scale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_scale", ctx, a, s);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_scale_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_scale_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_scale_inplace(struct ggml_context *ctx, struct ggml_tensor *a, float s)
     * }
     */
    public static FunctionDescriptor ggml_scale_inplace$descriptor() {
        return ggml_scale_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_scale_inplace(struct ggml_context *ctx, struct ggml_tensor *a, float s)
     * }
     */
    public static MethodHandle ggml_scale_inplace$handle() {
        return ggml_scale_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_scale_inplace(struct ggml_context *ctx, struct ggml_tensor *a, float s)
     * }
     */
    public static MemorySegment ggml_scale_inplace$address() {
        return ggml_scale_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_scale_inplace(struct ggml_context *ctx, struct ggml_tensor *a, float s)
     * }
     */
    public static MemorySegment ggml_scale_inplace(MemorySegment ctx, MemorySegment a, float s) {
        var mh$ = ggml_scale_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_scale_inplace", ctx, a, s);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_scale_bias {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_scale_bias");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_scale_bias(struct ggml_context *ctx, struct ggml_tensor *a, float s, float b)
     * }
     */
    public static FunctionDescriptor ggml_scale_bias$descriptor() {
        return ggml_scale_bias.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_scale_bias(struct ggml_context *ctx, struct ggml_tensor *a, float s, float b)
     * }
     */
    public static MethodHandle ggml_scale_bias$handle() {
        return ggml_scale_bias.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_scale_bias(struct ggml_context *ctx, struct ggml_tensor *a, float s, float b)
     * }
     */
    public static MemorySegment ggml_scale_bias$address() {
        return ggml_scale_bias.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_scale_bias(struct ggml_context *ctx, struct ggml_tensor *a, float s, float b)
     * }
     */
    public static MemorySegment ggml_scale_bias(MemorySegment ctx, MemorySegment a, float s, float b) {
        var mh$ = ggml_scale_bias.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_scale_bias", ctx, a, s, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, s, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_scale_bias_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_scale_bias_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_scale_bias_inplace(struct ggml_context *ctx, struct ggml_tensor *a, float s, float b)
     * }
     */
    public static FunctionDescriptor ggml_scale_bias_inplace$descriptor() {
        return ggml_scale_bias_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_scale_bias_inplace(struct ggml_context *ctx, struct ggml_tensor *a, float s, float b)
     * }
     */
    public static MethodHandle ggml_scale_bias_inplace$handle() {
        return ggml_scale_bias_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_scale_bias_inplace(struct ggml_context *ctx, struct ggml_tensor *a, float s, float b)
     * }
     */
    public static MemorySegment ggml_scale_bias_inplace$address() {
        return ggml_scale_bias_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_scale_bias_inplace(struct ggml_context *ctx, struct ggml_tensor *a, float s, float b)
     * }
     */
    public static MemorySegment ggml_scale_bias_inplace(MemorySegment ctx, MemorySegment a, float s, float b) {
        var mh$ = ggml_scale_bias_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_scale_bias_inplace", ctx, a, s, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, s, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t nb2, size_t nb3, size_t offset)
     * }
     */
    public static FunctionDescriptor ggml_set$descriptor() {
        return ggml_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t nb2, size_t nb3, size_t offset)
     * }
     */
    public static MethodHandle ggml_set$handle() {
        return ggml_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t nb2, size_t nb3, size_t offset)
     * }
     */
    public static MemorySegment ggml_set$address() {
        return ggml_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t nb2, size_t nb3, size_t offset)
     * }
     */
    public static MemorySegment ggml_set(MemorySegment ctx, MemorySegment a, MemorySegment b, long nb1, long nb2, long nb3, long offset) {
        var mh$ = ggml_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set", ctx, a, b, nb1, nb2, nb3, offset);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, nb1, nb2, nb3, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t nb2, size_t nb3, size_t offset)
     * }
     */
    public static FunctionDescriptor ggml_set_inplace$descriptor() {
        return ggml_set_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t nb2, size_t nb3, size_t offset)
     * }
     */
    public static MethodHandle ggml_set_inplace$handle() {
        return ggml_set_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t nb2, size_t nb3, size_t offset)
     * }
     */
    public static MemorySegment ggml_set_inplace$address() {
        return ggml_set_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t nb2, size_t nb3, size_t offset)
     * }
     */
    public static MemorySegment ggml_set_inplace(MemorySegment ctx, MemorySegment a, MemorySegment b, long nb1, long nb2, long nb3, long offset) {
        var mh$ = ggml_set_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_inplace", ctx, a, b, nb1, nb2, nb3, offset);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, nb1, nb2, nb3, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set_1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_1d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t offset)
     * }
     */
    public static FunctionDescriptor ggml_set_1d$descriptor() {
        return ggml_set_1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_1d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t offset)
     * }
     */
    public static MethodHandle ggml_set_1d$handle() {
        return ggml_set_1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_1d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t offset)
     * }
     */
    public static MemorySegment ggml_set_1d$address() {
        return ggml_set_1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_1d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t offset)
     * }
     */
    public static MemorySegment ggml_set_1d(MemorySegment ctx, MemorySegment a, MemorySegment b, long offset) {
        var mh$ = ggml_set_1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_1d", ctx, a, b, offset);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_1d_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set_1d_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_1d_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t offset)
     * }
     */
    public static FunctionDescriptor ggml_set_1d_inplace$descriptor() {
        return ggml_set_1d_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_1d_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t offset)
     * }
     */
    public static MethodHandle ggml_set_1d_inplace$handle() {
        return ggml_set_1d_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_1d_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t offset)
     * }
     */
    public static MemorySegment ggml_set_1d_inplace$address() {
        return ggml_set_1d_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_1d_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t offset)
     * }
     */
    public static MemorySegment ggml_set_1d_inplace(MemorySegment ctx, MemorySegment a, MemorySegment b, long offset) {
        var mh$ = ggml_set_1d_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_1d_inplace", ctx, a, b, offset);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set_2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_2d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t offset)
     * }
     */
    public static FunctionDescriptor ggml_set_2d$descriptor() {
        return ggml_set_2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_2d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t offset)
     * }
     */
    public static MethodHandle ggml_set_2d$handle() {
        return ggml_set_2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_2d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t offset)
     * }
     */
    public static MemorySegment ggml_set_2d$address() {
        return ggml_set_2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_2d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t offset)
     * }
     */
    public static MemorySegment ggml_set_2d(MemorySegment ctx, MemorySegment a, MemorySegment b, long nb1, long offset) {
        var mh$ = ggml_set_2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_2d", ctx, a, b, nb1, offset);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, nb1, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_2d_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set_2d_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_2d_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t offset)
     * }
     */
    public static FunctionDescriptor ggml_set_2d_inplace$descriptor() {
        return ggml_set_2d_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_2d_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t offset)
     * }
     */
    public static MethodHandle ggml_set_2d_inplace$handle() {
        return ggml_set_2d_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_2d_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t offset)
     * }
     */
    public static MemorySegment ggml_set_2d_inplace$address() {
        return ggml_set_2d_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_2d_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, size_t nb1, size_t offset)
     * }
     */
    public static MemorySegment ggml_set_2d_inplace(MemorySegment ctx, MemorySegment a, MemorySegment b, long nb1, long offset) {
        var mh$ = ggml_set_2d_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_2d_inplace", ctx, a, b, nb1, offset);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, nb1, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cpy(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_cpy$descriptor() {
        return ggml_cpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cpy(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_cpy$handle() {
        return ggml_cpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cpy(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_cpy$address() {
        return ggml_cpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cpy(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_cpy(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_cpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpy", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cast(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_type type)
     * }
     */
    public static FunctionDescriptor ggml_cast$descriptor() {
        return ggml_cast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cast(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_type type)
     * }
     */
    public static MethodHandle ggml_cast$handle() {
        return ggml_cast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cast(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_type type)
     * }
     */
    public static MemorySegment ggml_cast$address() {
        return ggml_cast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cast(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_type type)
     * }
     */
    public static MemorySegment ggml_cast(MemorySegment ctx, MemorySegment a, int type) {
        var mh$ = ggml_cast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cast", ctx, a, type);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cont {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cont");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cont(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_cont$descriptor() {
        return ggml_cont.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cont(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_cont$handle() {
        return ggml_cont.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cont(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_cont$address() {
        return ggml_cont.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cont(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_cont(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_cont.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cont", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cont_1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cont_1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cont_1d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0)
     * }
     */
    public static FunctionDescriptor ggml_cont_1d$descriptor() {
        return ggml_cont_1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cont_1d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0)
     * }
     */
    public static MethodHandle ggml_cont_1d$handle() {
        return ggml_cont_1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cont_1d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0)
     * }
     */
    public static MemorySegment ggml_cont_1d$address() {
        return ggml_cont_1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cont_1d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0)
     * }
     */
    public static MemorySegment ggml_cont_1d(MemorySegment ctx, MemorySegment a, long ne0) {
        var mh$ = ggml_cont_1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cont_1d", ctx, a, ne0);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, ne0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cont_2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cont_2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cont_2d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1)
     * }
     */
    public static FunctionDescriptor ggml_cont_2d$descriptor() {
        return ggml_cont_2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cont_2d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1)
     * }
     */
    public static MethodHandle ggml_cont_2d$handle() {
        return ggml_cont_2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cont_2d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1)
     * }
     */
    public static MemorySegment ggml_cont_2d$address() {
        return ggml_cont_2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cont_2d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1)
     * }
     */
    public static MemorySegment ggml_cont_2d(MemorySegment ctx, MemorySegment a, long ne0, long ne1) {
        var mh$ = ggml_cont_2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cont_2d", ctx, a, ne0, ne1);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, ne0, ne1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cont_3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cont_3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cont_3d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2)
     * }
     */
    public static FunctionDescriptor ggml_cont_3d$descriptor() {
        return ggml_cont_3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cont_3d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2)
     * }
     */
    public static MethodHandle ggml_cont_3d$handle() {
        return ggml_cont_3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cont_3d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2)
     * }
     */
    public static MemorySegment ggml_cont_3d$address() {
        return ggml_cont_3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cont_3d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2)
     * }
     */
    public static MemorySegment ggml_cont_3d(MemorySegment ctx, MemorySegment a, long ne0, long ne1, long ne2) {
        var mh$ = ggml_cont_3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cont_3d", ctx, a, ne0, ne1, ne2);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, ne0, ne1, ne2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cont_4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cont_4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cont_4d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3)
     * }
     */
    public static FunctionDescriptor ggml_cont_4d$descriptor() {
        return ggml_cont_4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cont_4d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3)
     * }
     */
    public static MethodHandle ggml_cont_4d$handle() {
        return ggml_cont_4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cont_4d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3)
     * }
     */
    public static MemorySegment ggml_cont_4d$address() {
        return ggml_cont_4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cont_4d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3)
     * }
     */
    public static MemorySegment ggml_cont_4d(MemorySegment ctx, MemorySegment a, long ne0, long ne1, long ne2, long ne3) {
        var mh$ = ggml_cont_4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cont_4d", ctx, a, ne0, ne1, ne2, ne3);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, ne0, ne1, ne2, ne3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_reshape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_reshape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reshape(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_reshape$descriptor() {
        return ggml_reshape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reshape(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_reshape$handle() {
        return ggml_reshape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reshape(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_reshape$address() {
        return ggml_reshape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reshape(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_reshape(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_reshape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_reshape", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_reshape_1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_reshape_1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reshape_1d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0)
     * }
     */
    public static FunctionDescriptor ggml_reshape_1d$descriptor() {
        return ggml_reshape_1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reshape_1d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0)
     * }
     */
    public static MethodHandle ggml_reshape_1d$handle() {
        return ggml_reshape_1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reshape_1d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0)
     * }
     */
    public static MemorySegment ggml_reshape_1d$address() {
        return ggml_reshape_1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reshape_1d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0)
     * }
     */
    public static MemorySegment ggml_reshape_1d(MemorySegment ctx, MemorySegment a, long ne0) {
        var mh$ = ggml_reshape_1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_reshape_1d", ctx, a, ne0);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, ne0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_reshape_2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_reshape_2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reshape_2d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1)
     * }
     */
    public static FunctionDescriptor ggml_reshape_2d$descriptor() {
        return ggml_reshape_2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reshape_2d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1)
     * }
     */
    public static MethodHandle ggml_reshape_2d$handle() {
        return ggml_reshape_2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reshape_2d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1)
     * }
     */
    public static MemorySegment ggml_reshape_2d$address() {
        return ggml_reshape_2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reshape_2d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1)
     * }
     */
    public static MemorySegment ggml_reshape_2d(MemorySegment ctx, MemorySegment a, long ne0, long ne1) {
        var mh$ = ggml_reshape_2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_reshape_2d", ctx, a, ne0, ne1);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, ne0, ne1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_reshape_3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_reshape_3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reshape_3d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2)
     * }
     */
    public static FunctionDescriptor ggml_reshape_3d$descriptor() {
        return ggml_reshape_3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reshape_3d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2)
     * }
     */
    public static MethodHandle ggml_reshape_3d$handle() {
        return ggml_reshape_3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reshape_3d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2)
     * }
     */
    public static MemorySegment ggml_reshape_3d$address() {
        return ggml_reshape_3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reshape_3d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2)
     * }
     */
    public static MemorySegment ggml_reshape_3d(MemorySegment ctx, MemorySegment a, long ne0, long ne1, long ne2) {
        var mh$ = ggml_reshape_3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_reshape_3d", ctx, a, ne0, ne1, ne2);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, ne0, ne1, ne2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_reshape_4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_reshape_4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reshape_4d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3)
     * }
     */
    public static FunctionDescriptor ggml_reshape_4d$descriptor() {
        return ggml_reshape_4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reshape_4d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3)
     * }
     */
    public static MethodHandle ggml_reshape_4d$handle() {
        return ggml_reshape_4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reshape_4d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3)
     * }
     */
    public static MemorySegment ggml_reshape_4d$address() {
        return ggml_reshape_4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_reshape_4d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3)
     * }
     */
    public static MemorySegment ggml_reshape_4d(MemorySegment ctx, MemorySegment a, long ne0, long ne1, long ne2, long ne3) {
        var mh$ = ggml_reshape_4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_reshape_4d", ctx, a, ne0, ne1, ne2, ne3);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, ne0, ne1, ne2, ne3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_view_1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_view_1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_view_1d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, size_t offset)
     * }
     */
    public static FunctionDescriptor ggml_view_1d$descriptor() {
        return ggml_view_1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_view_1d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, size_t offset)
     * }
     */
    public static MethodHandle ggml_view_1d$handle() {
        return ggml_view_1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_view_1d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, size_t offset)
     * }
     */
    public static MemorySegment ggml_view_1d$address() {
        return ggml_view_1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_view_1d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, size_t offset)
     * }
     */
    public static MemorySegment ggml_view_1d(MemorySegment ctx, MemorySegment a, long ne0, long offset) {
        var mh$ = ggml_view_1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_view_1d", ctx, a, ne0, offset);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, ne0, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_view_2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_view_2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_view_2d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, size_t nb1, size_t offset)
     * }
     */
    public static FunctionDescriptor ggml_view_2d$descriptor() {
        return ggml_view_2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_view_2d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, size_t nb1, size_t offset)
     * }
     */
    public static MethodHandle ggml_view_2d$handle() {
        return ggml_view_2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_view_2d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, size_t nb1, size_t offset)
     * }
     */
    public static MemorySegment ggml_view_2d$address() {
        return ggml_view_2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_view_2d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, size_t nb1, size_t offset)
     * }
     */
    public static MemorySegment ggml_view_2d(MemorySegment ctx, MemorySegment a, long ne0, long ne1, long nb1, long offset) {
        var mh$ = ggml_view_2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_view_2d", ctx, a, ne0, ne1, nb1, offset);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, ne0, ne1, nb1, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_view_3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_view_3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_view_3d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, size_t nb1, size_t nb2, size_t offset)
     * }
     */
    public static FunctionDescriptor ggml_view_3d$descriptor() {
        return ggml_view_3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_view_3d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, size_t nb1, size_t nb2, size_t offset)
     * }
     */
    public static MethodHandle ggml_view_3d$handle() {
        return ggml_view_3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_view_3d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, size_t nb1, size_t nb2, size_t offset)
     * }
     */
    public static MemorySegment ggml_view_3d$address() {
        return ggml_view_3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_view_3d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, size_t nb1, size_t nb2, size_t offset)
     * }
     */
    public static MemorySegment ggml_view_3d(MemorySegment ctx, MemorySegment a, long ne0, long ne1, long ne2, long nb1, long nb2, long offset) {
        var mh$ = ggml_view_3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_view_3d", ctx, a, ne0, ne1, ne2, nb1, nb2, offset);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, ne0, ne1, ne2, nb1, nb2, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_view_4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_view_4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_view_4d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3, size_t nb1, size_t nb2, size_t nb3, size_t offset)
     * }
     */
    public static FunctionDescriptor ggml_view_4d$descriptor() {
        return ggml_view_4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_view_4d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3, size_t nb1, size_t nb2, size_t nb3, size_t offset)
     * }
     */
    public static MethodHandle ggml_view_4d$handle() {
        return ggml_view_4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_view_4d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3, size_t nb1, size_t nb2, size_t nb3, size_t offset)
     * }
     */
    public static MemorySegment ggml_view_4d$address() {
        return ggml_view_4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_view_4d(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3, size_t nb1, size_t nb2, size_t nb3, size_t offset)
     * }
     */
    public static MemorySegment ggml_view_4d(MemorySegment ctx, MemorySegment a, long ne0, long ne1, long ne2, long ne3, long nb1, long nb2, long nb3, long offset) {
        var mh$ = ggml_view_4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_view_4d", ctx, a, ne0, ne1, ne2, ne3, nb1, nb2, nb3, offset);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, ne0, ne1, ne2, ne3, nb1, nb2, nb3, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_permute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_permute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_permute(struct ggml_context *ctx, struct ggml_tensor *a, int axis0, int axis1, int axis2, int axis3)
     * }
     */
    public static FunctionDescriptor ggml_permute$descriptor() {
        return ggml_permute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_permute(struct ggml_context *ctx, struct ggml_tensor *a, int axis0, int axis1, int axis2, int axis3)
     * }
     */
    public static MethodHandle ggml_permute$handle() {
        return ggml_permute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_permute(struct ggml_context *ctx, struct ggml_tensor *a, int axis0, int axis1, int axis2, int axis3)
     * }
     */
    public static MemorySegment ggml_permute$address() {
        return ggml_permute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_permute(struct ggml_context *ctx, struct ggml_tensor *a, int axis0, int axis1, int axis2, int axis3)
     * }
     */
    public static MemorySegment ggml_permute(MemorySegment ctx, MemorySegment a, int axis0, int axis1, int axis2, int axis3) {
        var mh$ = ggml_permute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_permute", ctx, a, axis0, axis1, axis2, axis3);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, axis0, axis1, axis2, axis3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_transpose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_transpose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_transpose(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_transpose$descriptor() {
        return ggml_transpose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_transpose(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_transpose$handle() {
        return ggml_transpose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_transpose(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_transpose$address() {
        return ggml_transpose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_transpose(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_transpose(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_transpose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_transpose", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_rows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_rows");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_rows(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_get_rows$descriptor() {
        return ggml_get_rows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_rows(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_get_rows$handle() {
        return ggml_get_rows.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_rows(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_get_rows$address() {
        return ggml_get_rows.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_rows(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_get_rows(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_get_rows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_rows", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_rows_back {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_rows_back");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_rows_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c)
     * }
     */
    public static FunctionDescriptor ggml_get_rows_back$descriptor() {
        return ggml_get_rows_back.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_rows_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c)
     * }
     */
    public static MethodHandle ggml_get_rows_back$handle() {
        return ggml_get_rows_back.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_rows_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c)
     * }
     */
    public static MemorySegment ggml_get_rows_back$address() {
        return ggml_get_rows_back.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_rows_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c)
     * }
     */
    public static MemorySegment ggml_get_rows_back(MemorySegment ctx, MemorySegment a, MemorySegment b, MemorySegment c) {
        var mh$ = ggml_get_rows_back.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_rows_back", ctx, a, b, c);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_rows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set_rows");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_rows(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c)
     * }
     */
    public static FunctionDescriptor ggml_set_rows$descriptor() {
        return ggml_set_rows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_rows(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c)
     * }
     */
    public static MethodHandle ggml_set_rows$handle() {
        return ggml_set_rows.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_rows(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c)
     * }
     */
    public static MemorySegment ggml_set_rows$address() {
        return ggml_set_rows.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_rows(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c)
     * }
     */
    public static MemorySegment ggml_set_rows(MemorySegment ctx, MemorySegment a, MemorySegment b, MemorySegment c) {
        var mh$ = ggml_set_rows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_rows", ctx, a, b, c);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_diag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_diag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_diag(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_diag$descriptor() {
        return ggml_diag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_diag(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_diag$handle() {
        return ggml_diag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_diag(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_diag$address() {
        return ggml_diag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_diag(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_diag(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_diag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_diag", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_diag_mask_inf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_diag_mask_inf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_diag_mask_inf(struct ggml_context *ctx, struct ggml_tensor *a, int n_past)
     * }
     */
    public static FunctionDescriptor ggml_diag_mask_inf$descriptor() {
        return ggml_diag_mask_inf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_diag_mask_inf(struct ggml_context *ctx, struct ggml_tensor *a, int n_past)
     * }
     */
    public static MethodHandle ggml_diag_mask_inf$handle() {
        return ggml_diag_mask_inf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_diag_mask_inf(struct ggml_context *ctx, struct ggml_tensor *a, int n_past)
     * }
     */
    public static MemorySegment ggml_diag_mask_inf$address() {
        return ggml_diag_mask_inf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_diag_mask_inf(struct ggml_context *ctx, struct ggml_tensor *a, int n_past)
     * }
     */
    public static MemorySegment ggml_diag_mask_inf(MemorySegment ctx, MemorySegment a, int n_past) {
        var mh$ = ggml_diag_mask_inf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_diag_mask_inf", ctx, a, n_past);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, n_past);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_diag_mask_inf_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_diag_mask_inf_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_diag_mask_inf_inplace(struct ggml_context *ctx, struct ggml_tensor *a, int n_past)
     * }
     */
    public static FunctionDescriptor ggml_diag_mask_inf_inplace$descriptor() {
        return ggml_diag_mask_inf_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_diag_mask_inf_inplace(struct ggml_context *ctx, struct ggml_tensor *a, int n_past)
     * }
     */
    public static MethodHandle ggml_diag_mask_inf_inplace$handle() {
        return ggml_diag_mask_inf_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_diag_mask_inf_inplace(struct ggml_context *ctx, struct ggml_tensor *a, int n_past)
     * }
     */
    public static MemorySegment ggml_diag_mask_inf_inplace$address() {
        return ggml_diag_mask_inf_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_diag_mask_inf_inplace(struct ggml_context *ctx, struct ggml_tensor *a, int n_past)
     * }
     */
    public static MemorySegment ggml_diag_mask_inf_inplace(MemorySegment ctx, MemorySegment a, int n_past) {
        var mh$ = ggml_diag_mask_inf_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_diag_mask_inf_inplace", ctx, a, n_past);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, n_past);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_diag_mask_zero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_diag_mask_zero");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_diag_mask_zero(struct ggml_context *ctx, struct ggml_tensor *a, int n_past)
     * }
     */
    public static FunctionDescriptor ggml_diag_mask_zero$descriptor() {
        return ggml_diag_mask_zero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_diag_mask_zero(struct ggml_context *ctx, struct ggml_tensor *a, int n_past)
     * }
     */
    public static MethodHandle ggml_diag_mask_zero$handle() {
        return ggml_diag_mask_zero.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_diag_mask_zero(struct ggml_context *ctx, struct ggml_tensor *a, int n_past)
     * }
     */
    public static MemorySegment ggml_diag_mask_zero$address() {
        return ggml_diag_mask_zero.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_diag_mask_zero(struct ggml_context *ctx, struct ggml_tensor *a, int n_past)
     * }
     */
    public static MemorySegment ggml_diag_mask_zero(MemorySegment ctx, MemorySegment a, int n_past) {
        var mh$ = ggml_diag_mask_zero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_diag_mask_zero", ctx, a, n_past);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, n_past);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_diag_mask_zero_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_diag_mask_zero_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_diag_mask_zero_inplace(struct ggml_context *ctx, struct ggml_tensor *a, int n_past)
     * }
     */
    public static FunctionDescriptor ggml_diag_mask_zero_inplace$descriptor() {
        return ggml_diag_mask_zero_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_diag_mask_zero_inplace(struct ggml_context *ctx, struct ggml_tensor *a, int n_past)
     * }
     */
    public static MethodHandle ggml_diag_mask_zero_inplace$handle() {
        return ggml_diag_mask_zero_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_diag_mask_zero_inplace(struct ggml_context *ctx, struct ggml_tensor *a, int n_past)
     * }
     */
    public static MemorySegment ggml_diag_mask_zero_inplace$address() {
        return ggml_diag_mask_zero_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_diag_mask_zero_inplace(struct ggml_context *ctx, struct ggml_tensor *a, int n_past)
     * }
     */
    public static MemorySegment ggml_diag_mask_zero_inplace(MemorySegment ctx, MemorySegment a, int n_past) {
        var mh$ = ggml_diag_mask_zero_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_diag_mask_zero_inplace", ctx, a, n_past);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, n_past);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_soft_max {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_soft_max");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_soft_max(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_soft_max$descriptor() {
        return ggml_soft_max.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_soft_max(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_soft_max$handle() {
        return ggml_soft_max.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_soft_max(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_soft_max$address() {
        return ggml_soft_max.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_soft_max(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_soft_max(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_soft_max.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_soft_max", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_soft_max_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_soft_max_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_soft_max_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_soft_max_inplace$descriptor() {
        return ggml_soft_max_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_soft_max_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_soft_max_inplace$handle() {
        return ggml_soft_max_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_soft_max_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_soft_max_inplace$address() {
        return ggml_soft_max_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_soft_max_inplace(struct ggml_context *ctx, struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_soft_max_inplace(MemorySegment ctx, MemorySegment a) {
        var mh$ = ggml_soft_max_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_soft_max_inplace", ctx, a);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_soft_max_ext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_soft_max_ext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_soft_max_ext(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *mask, float scale, float max_bias)
     * }
     */
    public static FunctionDescriptor ggml_soft_max_ext$descriptor() {
        return ggml_soft_max_ext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_soft_max_ext(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *mask, float scale, float max_bias)
     * }
     */
    public static MethodHandle ggml_soft_max_ext$handle() {
        return ggml_soft_max_ext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_soft_max_ext(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *mask, float scale, float max_bias)
     * }
     */
    public static MemorySegment ggml_soft_max_ext$address() {
        return ggml_soft_max_ext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_soft_max_ext(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *mask, float scale, float max_bias)
     * }
     */
    public static MemorySegment ggml_soft_max_ext(MemorySegment ctx, MemorySegment a, MemorySegment mask, float scale, float max_bias) {
        var mh$ = ggml_soft_max_ext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_soft_max_ext", ctx, a, mask, scale, max_bias);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, mask, scale, max_bias);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_soft_max_add_sinks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_soft_max_add_sinks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_soft_max_add_sinks(struct ggml_tensor *a, struct ggml_tensor *sinks)
     * }
     */
    public static FunctionDescriptor ggml_soft_max_add_sinks$descriptor() {
        return ggml_soft_max_add_sinks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_soft_max_add_sinks(struct ggml_tensor *a, struct ggml_tensor *sinks)
     * }
     */
    public static MethodHandle ggml_soft_max_add_sinks$handle() {
        return ggml_soft_max_add_sinks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_soft_max_add_sinks(struct ggml_tensor *a, struct ggml_tensor *sinks)
     * }
     */
    public static MemorySegment ggml_soft_max_add_sinks$address() {
        return ggml_soft_max_add_sinks.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_soft_max_add_sinks(struct ggml_tensor *a, struct ggml_tensor *sinks)
     * }
     */
    public static void ggml_soft_max_add_sinks(MemorySegment a, MemorySegment sinks) {
        var mh$ = ggml_soft_max_add_sinks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_soft_max_add_sinks", a, sinks);
            }
            mh$.invokeExact(a, sinks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_soft_max_ext_back {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_soft_max_ext_back");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_soft_max_ext_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, float scale, float max_bias)
     * }
     */
    public static FunctionDescriptor ggml_soft_max_ext_back$descriptor() {
        return ggml_soft_max_ext_back.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_soft_max_ext_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, float scale, float max_bias)
     * }
     */
    public static MethodHandle ggml_soft_max_ext_back$handle() {
        return ggml_soft_max_ext_back.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_soft_max_ext_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, float scale, float max_bias)
     * }
     */
    public static MemorySegment ggml_soft_max_ext_back$address() {
        return ggml_soft_max_ext_back.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_soft_max_ext_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, float scale, float max_bias)
     * }
     */
    public static MemorySegment ggml_soft_max_ext_back(MemorySegment ctx, MemorySegment a, MemorySegment b, float scale, float max_bias) {
        var mh$ = ggml_soft_max_ext_back.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_soft_max_ext_back", ctx, a, b, scale, max_bias);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, scale, max_bias);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_soft_max_ext_back_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_soft_max_ext_back_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_soft_max_ext_back_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, float scale, float max_bias)
     * }
     */
    public static FunctionDescriptor ggml_soft_max_ext_back_inplace$descriptor() {
        return ggml_soft_max_ext_back_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_soft_max_ext_back_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, float scale, float max_bias)
     * }
     */
    public static MethodHandle ggml_soft_max_ext_back_inplace$handle() {
        return ggml_soft_max_ext_back_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_soft_max_ext_back_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, float scale, float max_bias)
     * }
     */
    public static MemorySegment ggml_soft_max_ext_back_inplace$address() {
        return ggml_soft_max_ext_back_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_soft_max_ext_back_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, float scale, float max_bias)
     * }
     */
    public static MemorySegment ggml_soft_max_ext_back_inplace(MemorySegment ctx, MemorySegment a, MemorySegment b, float scale, float max_bias) {
        var mh$ = ggml_soft_max_ext_back_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_soft_max_ext_back_inplace", ctx, a, b, scale, max_bias);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, scale, max_bias);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_rope {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_rope");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int n_dims, int mode)
     * }
     */
    public static FunctionDescriptor ggml_rope$descriptor() {
        return ggml_rope.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int n_dims, int mode)
     * }
     */
    public static MethodHandle ggml_rope$handle() {
        return ggml_rope.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int n_dims, int mode)
     * }
     */
    public static MemorySegment ggml_rope$address() {
        return ggml_rope.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int n_dims, int mode)
     * }
     */
    public static MemorySegment ggml_rope(MemorySegment ctx, MemorySegment a, MemorySegment b, int n_dims, int mode) {
        var mh$ = ggml_rope.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_rope", ctx, a, b, n_dims, mode);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, n_dims, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_rope_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_rope_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int n_dims, int mode)
     * }
     */
    public static FunctionDescriptor ggml_rope_inplace$descriptor() {
        return ggml_rope_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int n_dims, int mode)
     * }
     */
    public static MethodHandle ggml_rope_inplace$handle() {
        return ggml_rope_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int n_dims, int mode)
     * }
     */
    public static MemorySegment ggml_rope_inplace$address() {
        return ggml_rope_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int n_dims, int mode)
     * }
     */
    public static MemorySegment ggml_rope_inplace(MemorySegment ctx, MemorySegment a, MemorySegment b, int n_dims, int mode) {
        var mh$ = ggml_rope_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_rope_inplace", ctx, a, b, n_dims, mode);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, n_dims, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_rope_ext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_rope_ext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_ext(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static FunctionDescriptor ggml_rope_ext$descriptor() {
        return ggml_rope_ext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_ext(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MethodHandle ggml_rope_ext$handle() {
        return ggml_rope_ext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_ext(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MemorySegment ggml_rope_ext$address() {
        return ggml_rope_ext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_ext(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MemorySegment ggml_rope_ext(MemorySegment ctx, MemorySegment a, MemorySegment b, MemorySegment c, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow) {
        var mh$ = ggml_rope_ext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_rope_ext", ctx, a, b, c, n_dims, mode, n_ctx_orig, freq_base, freq_scale, ext_factor, attn_factor, beta_fast, beta_slow);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, c, n_dims, mode, n_ctx_orig, freq_base, freq_scale, ext_factor, attn_factor, beta_fast, beta_slow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_rope_multi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_rope_multi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_multi(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int sections[4], int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static FunctionDescriptor ggml_rope_multi$descriptor() {
        return ggml_rope_multi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_multi(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int sections[4], int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MethodHandle ggml_rope_multi$handle() {
        return ggml_rope_multi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_multi(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int sections[4], int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MemorySegment ggml_rope_multi$address() {
        return ggml_rope_multi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_multi(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int sections[4], int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MemorySegment ggml_rope_multi(MemorySegment ctx, MemorySegment a, MemorySegment b, MemorySegment c, int n_dims, MemorySegment sections, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow) {
        var mh$ = ggml_rope_multi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_rope_multi", ctx, a, b, c, n_dims, sections, mode, n_ctx_orig, freq_base, freq_scale, ext_factor, attn_factor, beta_fast, beta_slow);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, c, n_dims, sections, mode, n_ctx_orig, freq_base, freq_scale, ext_factor, attn_factor, beta_fast, beta_slow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_rope_ext_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_rope_ext_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_ext_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static FunctionDescriptor ggml_rope_ext_inplace$descriptor() {
        return ggml_rope_ext_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_ext_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MethodHandle ggml_rope_ext_inplace$handle() {
        return ggml_rope_ext_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_ext_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MemorySegment ggml_rope_ext_inplace$address() {
        return ggml_rope_ext_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_ext_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MemorySegment ggml_rope_ext_inplace(MemorySegment ctx, MemorySegment a, MemorySegment b, MemorySegment c, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow) {
        var mh$ = ggml_rope_ext_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_rope_ext_inplace", ctx, a, b, c, n_dims, mode, n_ctx_orig, freq_base, freq_scale, ext_factor, attn_factor, beta_fast, beta_slow);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, c, n_dims, mode, n_ctx_orig, freq_base, freq_scale, ext_factor, attn_factor, beta_fast, beta_slow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_rope_multi_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_rope_multi_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_multi_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int sections[4], int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static FunctionDescriptor ggml_rope_multi_inplace$descriptor() {
        return ggml_rope_multi_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_multi_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int sections[4], int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MethodHandle ggml_rope_multi_inplace$handle() {
        return ggml_rope_multi_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_multi_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int sections[4], int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MemorySegment ggml_rope_multi_inplace$address() {
        return ggml_rope_multi_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_multi_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int sections[4], int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MemorySegment ggml_rope_multi_inplace(MemorySegment ctx, MemorySegment a, MemorySegment b, MemorySegment c, int n_dims, MemorySegment sections, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow) {
        var mh$ = ggml_rope_multi_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_rope_multi_inplace", ctx, a, b, c, n_dims, sections, mode, n_ctx_orig, freq_base, freq_scale, ext_factor, attn_factor, beta_fast, beta_slow);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, c, n_dims, sections, mode, n_ctx_orig, freq_base, freq_scale, ext_factor, attn_factor, beta_fast, beta_slow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_rope_custom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_rope_custom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_custom(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static FunctionDescriptor ggml_rope_custom$descriptor() {
        return ggml_rope_custom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_custom(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MethodHandle ggml_rope_custom$handle() {
        return ggml_rope_custom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_custom(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MemorySegment ggml_rope_custom$address() {
        return ggml_rope_custom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_custom(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MemorySegment ggml_rope_custom(MemorySegment ctx, MemorySegment a, MemorySegment b, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow) {
        var mh$ = ggml_rope_custom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_rope_custom", ctx, a, b, n_dims, mode, n_ctx_orig, freq_base, freq_scale, ext_factor, attn_factor, beta_fast, beta_slow);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, n_dims, mode, n_ctx_orig, freq_base, freq_scale, ext_factor, attn_factor, beta_fast, beta_slow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_rope_custom_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_rope_custom_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_custom_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static FunctionDescriptor ggml_rope_custom_inplace$descriptor() {
        return ggml_rope_custom_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_custom_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MethodHandle ggml_rope_custom_inplace$handle() {
        return ggml_rope_custom_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_custom_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MemorySegment ggml_rope_custom_inplace$address() {
        return ggml_rope_custom_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_custom_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MemorySegment ggml_rope_custom_inplace(MemorySegment ctx, MemorySegment a, MemorySegment b, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow) {
        var mh$ = ggml_rope_custom_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_rope_custom_inplace", ctx, a, b, n_dims, mode, n_ctx_orig, freq_base, freq_scale, ext_factor, attn_factor, beta_fast, beta_slow);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, n_dims, mode, n_ctx_orig, freq_base, freq_scale, ext_factor, attn_factor, beta_fast, beta_slow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_rope_yarn_corr_dims {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_rope_yarn_corr_dims");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_rope_yarn_corr_dims(int n_dims, int n_ctx_orig, float freq_base, float beta_fast, float beta_slow, float dims[2])
     * }
     */
    public static FunctionDescriptor ggml_rope_yarn_corr_dims$descriptor() {
        return ggml_rope_yarn_corr_dims.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_rope_yarn_corr_dims(int n_dims, int n_ctx_orig, float freq_base, float beta_fast, float beta_slow, float dims[2])
     * }
     */
    public static MethodHandle ggml_rope_yarn_corr_dims$handle() {
        return ggml_rope_yarn_corr_dims.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_rope_yarn_corr_dims(int n_dims, int n_ctx_orig, float freq_base, float beta_fast, float beta_slow, float dims[2])
     * }
     */
    public static MemorySegment ggml_rope_yarn_corr_dims$address() {
        return ggml_rope_yarn_corr_dims.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_rope_yarn_corr_dims(int n_dims, int n_ctx_orig, float freq_base, float beta_fast, float beta_slow, float dims[2])
     * }
     */
    public static void ggml_rope_yarn_corr_dims(int n_dims, int n_ctx_orig, float freq_base, float beta_fast, float beta_slow, MemorySegment dims) {
        var mh$ = ggml_rope_yarn_corr_dims.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_rope_yarn_corr_dims", n_dims, n_ctx_orig, freq_base, beta_fast, beta_slow, dims);
            }
            mh$.invokeExact(n_dims, n_ctx_orig, freq_base, beta_fast, beta_slow, dims);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_rope_ext_back {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_rope_ext_back");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_ext_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static FunctionDescriptor ggml_rope_ext_back$descriptor() {
        return ggml_rope_ext_back.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_ext_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MethodHandle ggml_rope_ext_back$handle() {
        return ggml_rope_ext_back.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_ext_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MemorySegment ggml_rope_ext_back$address() {
        return ggml_rope_ext_back.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_ext_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MemorySegment ggml_rope_ext_back(MemorySegment ctx, MemorySegment a, MemorySegment b, MemorySegment c, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow) {
        var mh$ = ggml_rope_ext_back.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_rope_ext_back", ctx, a, b, c, n_dims, mode, n_ctx_orig, freq_base, freq_scale, ext_factor, attn_factor, beta_fast, beta_slow);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, c, n_dims, mode, n_ctx_orig, freq_base, freq_scale, ext_factor, attn_factor, beta_fast, beta_slow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_rope_multi_back {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_rope_multi_back");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_multi_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int sections[4], int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static FunctionDescriptor ggml_rope_multi_back$descriptor() {
        return ggml_rope_multi_back.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_multi_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int sections[4], int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MethodHandle ggml_rope_multi_back$handle() {
        return ggml_rope_multi_back.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_multi_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int sections[4], int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MemorySegment ggml_rope_multi_back$address() {
        return ggml_rope_multi_back.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_multi_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int sections[4], int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MemorySegment ggml_rope_multi_back(MemorySegment ctx, MemorySegment a, MemorySegment b, MemorySegment c, int n_dims, MemorySegment sections, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow) {
        var mh$ = ggml_rope_multi_back.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_rope_multi_back", ctx, a, b, c, n_dims, sections, mode, n_ctx_orig, freq_base, freq_scale, ext_factor, attn_factor, beta_fast, beta_slow);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, c, n_dims, sections, mode, n_ctx_orig, freq_base, freq_scale, ext_factor, attn_factor, beta_fast, beta_slow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_clamp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_clamp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_clamp(struct ggml_context *ctx, struct ggml_tensor *a, float min, float max)
     * }
     */
    public static FunctionDescriptor ggml_clamp$descriptor() {
        return ggml_clamp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_clamp(struct ggml_context *ctx, struct ggml_tensor *a, float min, float max)
     * }
     */
    public static MethodHandle ggml_clamp$handle() {
        return ggml_clamp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_clamp(struct ggml_context *ctx, struct ggml_tensor *a, float min, float max)
     * }
     */
    public static MemorySegment ggml_clamp$address() {
        return ggml_clamp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_clamp(struct ggml_context *ctx, struct ggml_tensor *a, float min, float max)
     * }
     */
    public static MemorySegment ggml_clamp(MemorySegment ctx, MemorySegment a, float min, float max) {
        var mh$ = ggml_clamp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_clamp", ctx, a, min, max);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, min, max);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_im2col {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_BOOL,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_im2col");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_im2col(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1, bool is_2D, enum ggml_type dst_type)
     * }
     */
    public static FunctionDescriptor ggml_im2col$descriptor() {
        return ggml_im2col.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_im2col(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1, bool is_2D, enum ggml_type dst_type)
     * }
     */
    public static MethodHandle ggml_im2col$handle() {
        return ggml_im2col.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_im2col(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1, bool is_2D, enum ggml_type dst_type)
     * }
     */
    public static MemorySegment ggml_im2col$address() {
        return ggml_im2col.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_im2col(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1, bool is_2D, enum ggml_type dst_type)
     * }
     */
    public static MemorySegment ggml_im2col(MemorySegment ctx, MemorySegment a, MemorySegment b, int s0, int s1, int p0, int p1, int d0, int d1, boolean is_2D, int dst_type) {
        var mh$ = ggml_im2col.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_im2col", ctx, a, b, s0, s1, p0, p1, d0, d1, is_2D, dst_type);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, s0, s1, p0, p1, d0, d1, is_2D, dst_type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_im2col_back {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_BOOL
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_im2col_back");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_im2col_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int64_t *ne, int s0, int s1, int p0, int p1, int d0, int d1, bool is_2D)
     * }
     */
    public static FunctionDescriptor ggml_im2col_back$descriptor() {
        return ggml_im2col_back.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_im2col_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int64_t *ne, int s0, int s1, int p0, int p1, int d0, int d1, bool is_2D)
     * }
     */
    public static MethodHandle ggml_im2col_back$handle() {
        return ggml_im2col_back.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_im2col_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int64_t *ne, int s0, int s1, int p0, int p1, int d0, int d1, bool is_2D)
     * }
     */
    public static MemorySegment ggml_im2col_back$address() {
        return ggml_im2col_back.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_im2col_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int64_t *ne, int s0, int s1, int p0, int p1, int d0, int d1, bool is_2D)
     * }
     */
    public static MemorySegment ggml_im2col_back(MemorySegment ctx, MemorySegment a, MemorySegment b, MemorySegment ne, int s0, int s1, int p0, int p1, int d0, int d1, boolean is_2D) {
        var mh$ = ggml_im2col_back.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_im2col_back", ctx, a, b, ne, s0, s1, p0, p1, d0, d1, is_2D);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, ne, s0, s1, p0, p1, d0, d1, is_2D);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_conv_1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_conv_1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int p0, int d0)
     * }
     */
    public static FunctionDescriptor ggml_conv_1d$descriptor() {
        return ggml_conv_1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int p0, int d0)
     * }
     */
    public static MethodHandle ggml_conv_1d$handle() {
        return ggml_conv_1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int p0, int d0)
     * }
     */
    public static MemorySegment ggml_conv_1d$address() {
        return ggml_conv_1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int p0, int d0)
     * }
     */
    public static MemorySegment ggml_conv_1d(MemorySegment ctx, MemorySegment a, MemorySegment b, int s0, int p0, int d0) {
        var mh$ = ggml_conv_1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_conv_1d", ctx, a, b, s0, p0, d0);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, s0, p0, d0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_conv_1d_ph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_conv_1d_ph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d_ph(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s, int d)
     * }
     */
    public static FunctionDescriptor ggml_conv_1d_ph$descriptor() {
        return ggml_conv_1d_ph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d_ph(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s, int d)
     * }
     */
    public static MethodHandle ggml_conv_1d_ph$handle() {
        return ggml_conv_1d_ph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d_ph(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s, int d)
     * }
     */
    public static MemorySegment ggml_conv_1d_ph$address() {
        return ggml_conv_1d_ph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d_ph(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s, int d)
     * }
     */
    public static MemorySegment ggml_conv_1d_ph(MemorySegment ctx, MemorySegment a, MemorySegment b, int s, int d) {
        var mh$ = ggml_conv_1d_ph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_conv_1d_ph", ctx, a, b, s, d);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, s, d);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_conv_1d_dw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_conv_1d_dw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d_dw(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int p0, int d0)
     * }
     */
    public static FunctionDescriptor ggml_conv_1d_dw$descriptor() {
        return ggml_conv_1d_dw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d_dw(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int p0, int d0)
     * }
     */
    public static MethodHandle ggml_conv_1d_dw$handle() {
        return ggml_conv_1d_dw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d_dw(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int p0, int d0)
     * }
     */
    public static MemorySegment ggml_conv_1d_dw$address() {
        return ggml_conv_1d_dw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d_dw(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int p0, int d0)
     * }
     */
    public static MemorySegment ggml_conv_1d_dw(MemorySegment ctx, MemorySegment a, MemorySegment b, int s0, int p0, int d0) {
        var mh$ = ggml_conv_1d_dw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_conv_1d_dw", ctx, a, b, s0, p0, d0);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, s0, p0, d0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_conv_1d_dw_ph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_conv_1d_dw_ph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d_dw_ph(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int d0)
     * }
     */
    public static FunctionDescriptor ggml_conv_1d_dw_ph$descriptor() {
        return ggml_conv_1d_dw_ph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d_dw_ph(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int d0)
     * }
     */
    public static MethodHandle ggml_conv_1d_dw_ph$handle() {
        return ggml_conv_1d_dw_ph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d_dw_ph(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int d0)
     * }
     */
    public static MemorySegment ggml_conv_1d_dw_ph$address() {
        return ggml_conv_1d_dw_ph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d_dw_ph(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int d0)
     * }
     */
    public static MemorySegment ggml_conv_1d_dw_ph(MemorySegment ctx, MemorySegment a, MemorySegment b, int s0, int d0) {
        var mh$ = ggml_conv_1d_dw_ph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_conv_1d_dw_ph", ctx, a, b, s0, d0);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, s0, d0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_conv_transpose_1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_conv_transpose_1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_transpose_1d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int p0, int d0)
     * }
     */
    public static FunctionDescriptor ggml_conv_transpose_1d$descriptor() {
        return ggml_conv_transpose_1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_transpose_1d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int p0, int d0)
     * }
     */
    public static MethodHandle ggml_conv_transpose_1d$handle() {
        return ggml_conv_transpose_1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_transpose_1d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int p0, int d0)
     * }
     */
    public static MemorySegment ggml_conv_transpose_1d$address() {
        return ggml_conv_transpose_1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_transpose_1d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int p0, int d0)
     * }
     */
    public static MemorySegment ggml_conv_transpose_1d(MemorySegment ctx, MemorySegment a, MemorySegment b, int s0, int p0, int d0) {
        var mh$ = ggml_conv_transpose_1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_conv_transpose_1d", ctx, a, b, s0, p0, d0);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, s0, p0, d0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_conv_2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_conv_2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1)
     * }
     */
    public static FunctionDescriptor ggml_conv_2d$descriptor() {
        return ggml_conv_2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1)
     * }
     */
    public static MethodHandle ggml_conv_2d$handle() {
        return ggml_conv_2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1)
     * }
     */
    public static MemorySegment ggml_conv_2d$address() {
        return ggml_conv_2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1)
     * }
     */
    public static MemorySegment ggml_conv_2d(MemorySegment ctx, MemorySegment a, MemorySegment b, int s0, int s1, int p0, int p1, int d0, int d1) {
        var mh$ = ggml_conv_2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_conv_2d", ctx, a, b, s0, s1, p0, p1, d0, d1);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, s0, s1, p0, p1, d0, d1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_conv_2d_sk_p0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_conv_2d_sk_p0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_sk_p0(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_conv_2d_sk_p0$descriptor() {
        return ggml_conv_2d_sk_p0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_sk_p0(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_conv_2d_sk_p0$handle() {
        return ggml_conv_2d_sk_p0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_sk_p0(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_conv_2d_sk_p0$address() {
        return ggml_conv_2d_sk_p0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_sk_p0(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_conv_2d_sk_p0(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_conv_2d_sk_p0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_conv_2d_sk_p0", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_conv_2d_s1_ph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_conv_2d_s1_ph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_s1_ph(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_conv_2d_s1_ph$descriptor() {
        return ggml_conv_2d_s1_ph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_s1_ph(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_conv_2d_s1_ph$handle() {
        return ggml_conv_2d_s1_ph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_s1_ph(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_conv_2d_s1_ph$address() {
        return ggml_conv_2d_s1_ph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_s1_ph(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_conv_2d_s1_ph(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_conv_2d_s1_ph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_conv_2d_s1_ph", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_conv_2d_dw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_conv_2d_dw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_dw(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1)
     * }
     */
    public static FunctionDescriptor ggml_conv_2d_dw$descriptor() {
        return ggml_conv_2d_dw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_dw(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1)
     * }
     */
    public static MethodHandle ggml_conv_2d_dw$handle() {
        return ggml_conv_2d_dw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_dw(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1)
     * }
     */
    public static MemorySegment ggml_conv_2d_dw$address() {
        return ggml_conv_2d_dw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_dw(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1)
     * }
     */
    public static MemorySegment ggml_conv_2d_dw(MemorySegment ctx, MemorySegment a, MemorySegment b, int s0, int s1, int p0, int p1, int d0, int d1) {
        var mh$ = ggml_conv_2d_dw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_conv_2d_dw", ctx, a, b, s0, s1, p0, p1, d0, d1);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, s0, s1, p0, p1, d0, d1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_conv_2d_dw_direct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_conv_2d_dw_direct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_dw_direct(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int stride0, int stride1, int pad0, int pad1, int dilation0, int dilation1)
     * }
     */
    public static FunctionDescriptor ggml_conv_2d_dw_direct$descriptor() {
        return ggml_conv_2d_dw_direct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_dw_direct(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int stride0, int stride1, int pad0, int pad1, int dilation0, int dilation1)
     * }
     */
    public static MethodHandle ggml_conv_2d_dw_direct$handle() {
        return ggml_conv_2d_dw_direct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_dw_direct(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int stride0, int stride1, int pad0, int pad1, int dilation0, int dilation1)
     * }
     */
    public static MemorySegment ggml_conv_2d_dw_direct$address() {
        return ggml_conv_2d_dw_direct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_dw_direct(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int stride0, int stride1, int pad0, int pad1, int dilation0, int dilation1)
     * }
     */
    public static MemorySegment ggml_conv_2d_dw_direct(MemorySegment ctx, MemorySegment a, MemorySegment b, int stride0, int stride1, int pad0, int pad1, int dilation0, int dilation1) {
        var mh$ = ggml_conv_2d_dw_direct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_conv_2d_dw_direct", ctx, a, b, stride0, stride1, pad0, pad1, dilation0, dilation1);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, stride0, stride1, pad0, pad1, dilation0, dilation1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_conv_transpose_2d_p0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_conv_transpose_2d_p0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_transpose_2d_p0(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int stride)
     * }
     */
    public static FunctionDescriptor ggml_conv_transpose_2d_p0$descriptor() {
        return ggml_conv_transpose_2d_p0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_transpose_2d_p0(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int stride)
     * }
     */
    public static MethodHandle ggml_conv_transpose_2d_p0$handle() {
        return ggml_conv_transpose_2d_p0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_transpose_2d_p0(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int stride)
     * }
     */
    public static MemorySegment ggml_conv_transpose_2d_p0$address() {
        return ggml_conv_transpose_2d_p0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_transpose_2d_p0(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int stride)
     * }
     */
    public static MemorySegment ggml_conv_transpose_2d_p0(MemorySegment ctx, MemorySegment a, MemorySegment b, int stride) {
        var mh$ = ggml_conv_transpose_2d_p0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_conv_transpose_2d_p0", ctx, a, b, stride);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, stride);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_conv_2d_direct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_conv_2d_direct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_direct(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1)
     * }
     */
    public static FunctionDescriptor ggml_conv_2d_direct$descriptor() {
        return ggml_conv_2d_direct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_direct(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1)
     * }
     */
    public static MethodHandle ggml_conv_2d_direct$handle() {
        return ggml_conv_2d_direct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_direct(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1)
     * }
     */
    public static MemorySegment ggml_conv_2d_direct$address() {
        return ggml_conv_2d_direct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_direct(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1)
     * }
     */
    public static MemorySegment ggml_conv_2d_direct(MemorySegment ctx, MemorySegment a, MemorySegment b, int s0, int s1, int p0, int p1, int d0, int d1) {
        var mh$ = ggml_conv_2d_direct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_conv_2d_direct", ctx, a, b, s0, s1, p0, p1, d0, d1);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, s0, s1, p0, p1, d0, d1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GGML_OP_POOL_MAX = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ggml_op_pool.GGML_OP_POOL_MAX = 0
     * }
     */
    public static int GGML_OP_POOL_MAX() {
        return GGML_OP_POOL_MAX;
    }
    private static final int GGML_OP_POOL_AVG = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ggml_op_pool.GGML_OP_POOL_AVG = 1
     * }
     */
    public static int GGML_OP_POOL_AVG() {
        return GGML_OP_POOL_AVG;
    }
    private static final int GGML_OP_POOL_COUNT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ggml_op_pool.GGML_OP_POOL_COUNT = 2
     * }
     */
    public static int GGML_OP_POOL_COUNT() {
        return GGML_OP_POOL_COUNT;
    }

    private static class ggml_pool_1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_pool_1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pool_1d(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_op_pool op, int k0, int s0, int p0)
     * }
     */
    public static FunctionDescriptor ggml_pool_1d$descriptor() {
        return ggml_pool_1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pool_1d(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_op_pool op, int k0, int s0, int p0)
     * }
     */
    public static MethodHandle ggml_pool_1d$handle() {
        return ggml_pool_1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pool_1d(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_op_pool op, int k0, int s0, int p0)
     * }
     */
    public static MemorySegment ggml_pool_1d$address() {
        return ggml_pool_1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pool_1d(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_op_pool op, int k0, int s0, int p0)
     * }
     */
    public static MemorySegment ggml_pool_1d(MemorySegment ctx, MemorySegment a, int op, int k0, int s0, int p0) {
        var mh$ = ggml_pool_1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_pool_1d", ctx, a, op, k0, s0, p0);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, op, k0, s0, p0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_pool_2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_pool_2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pool_2d(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_op_pool op, int k0, int k1, int s0, int s1, float p0, float p1)
     * }
     */
    public static FunctionDescriptor ggml_pool_2d$descriptor() {
        return ggml_pool_2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pool_2d(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_op_pool op, int k0, int k1, int s0, int s1, float p0, float p1)
     * }
     */
    public static MethodHandle ggml_pool_2d$handle() {
        return ggml_pool_2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pool_2d(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_op_pool op, int k0, int k1, int s0, int s1, float p0, float p1)
     * }
     */
    public static MemorySegment ggml_pool_2d$address() {
        return ggml_pool_2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pool_2d(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_op_pool op, int k0, int k1, int s0, int s1, float p0, float p1)
     * }
     */
    public static MemorySegment ggml_pool_2d(MemorySegment ctx, MemorySegment a, int op, int k0, int k1, int s0, int s1, float p0, float p1) {
        var mh$ = ggml_pool_2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_pool_2d", ctx, a, op, k0, k1, s0, s1, p0, p1);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, op, k0, k1, s0, s1, p0, p1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_pool_2d_back {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_pool_2d_back");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pool_2d_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *af, enum ggml_op_pool op, int k0, int k1, int s0, int s1, float p0, float p1)
     * }
     */
    public static FunctionDescriptor ggml_pool_2d_back$descriptor() {
        return ggml_pool_2d_back.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pool_2d_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *af, enum ggml_op_pool op, int k0, int k1, int s0, int s1, float p0, float p1)
     * }
     */
    public static MethodHandle ggml_pool_2d_back$handle() {
        return ggml_pool_2d_back.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pool_2d_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *af, enum ggml_op_pool op, int k0, int k1, int s0, int s1, float p0, float p1)
     * }
     */
    public static MemorySegment ggml_pool_2d_back$address() {
        return ggml_pool_2d_back.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pool_2d_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *af, enum ggml_op_pool op, int k0, int k1, int s0, int s1, float p0, float p1)
     * }
     */
    public static MemorySegment ggml_pool_2d_back(MemorySegment ctx, MemorySegment a, MemorySegment af, int op, int k0, int k1, int s0, int s1, float p0, float p1) {
        var mh$ = ggml_pool_2d_back.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_pool_2d_back", ctx, a, af, op, k0, k1, s0, s1, p0, p1);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, af, op, k0, k1, s0, s1, p0, p1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GGML_SCALE_MODE_NEAREST = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ggml_scale_mode.GGML_SCALE_MODE_NEAREST = 0
     * }
     */
    public static int GGML_SCALE_MODE_NEAREST() {
        return GGML_SCALE_MODE_NEAREST;
    }
    private static final int GGML_SCALE_MODE_BILINEAR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ggml_scale_mode.GGML_SCALE_MODE_BILINEAR = 1
     * }
     */
    public static int GGML_SCALE_MODE_BILINEAR() {
        return GGML_SCALE_MODE_BILINEAR;
    }
    private static final int GGML_SCALE_MODE_COUNT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ggml_scale_mode.GGML_SCALE_MODE_COUNT = 2
     * }
     */
    public static int GGML_SCALE_MODE_COUNT() {
        return GGML_SCALE_MODE_COUNT;
    }
    private static final int GGML_SCALE_FLAG_ALIGN_CORNERS = (int)256L;
    /**
     * {@snippet lang=c :
     * enum ggml_scale_flag.GGML_SCALE_FLAG_ALIGN_CORNERS = 256
     * }
     */
    public static int GGML_SCALE_FLAG_ALIGN_CORNERS() {
        return GGML_SCALE_FLAG_ALIGN_CORNERS;
    }

    private static class ggml_upscale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_upscale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_upscale(struct ggml_context *ctx, struct ggml_tensor *a, int scale_factor, enum ggml_scale_mode mode)
     * }
     */
    public static FunctionDescriptor ggml_upscale$descriptor() {
        return ggml_upscale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_upscale(struct ggml_context *ctx, struct ggml_tensor *a, int scale_factor, enum ggml_scale_mode mode)
     * }
     */
    public static MethodHandle ggml_upscale$handle() {
        return ggml_upscale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_upscale(struct ggml_context *ctx, struct ggml_tensor *a, int scale_factor, enum ggml_scale_mode mode)
     * }
     */
    public static MemorySegment ggml_upscale$address() {
        return ggml_upscale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_upscale(struct ggml_context *ctx, struct ggml_tensor *a, int scale_factor, enum ggml_scale_mode mode)
     * }
     */
    public static MemorySegment ggml_upscale(MemorySegment ctx, MemorySegment a, int scale_factor, int mode) {
        var mh$ = ggml_upscale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_upscale", ctx, a, scale_factor, mode);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, scale_factor, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_upscale_ext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_upscale_ext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_upscale_ext(struct ggml_context *ctx, struct ggml_tensor *a, int ne0, int ne1, int ne2, int ne3, enum ggml_scale_mode mode)
     * }
     */
    public static FunctionDescriptor ggml_upscale_ext$descriptor() {
        return ggml_upscale_ext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_upscale_ext(struct ggml_context *ctx, struct ggml_tensor *a, int ne0, int ne1, int ne2, int ne3, enum ggml_scale_mode mode)
     * }
     */
    public static MethodHandle ggml_upscale_ext$handle() {
        return ggml_upscale_ext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_upscale_ext(struct ggml_context *ctx, struct ggml_tensor *a, int ne0, int ne1, int ne2, int ne3, enum ggml_scale_mode mode)
     * }
     */
    public static MemorySegment ggml_upscale_ext$address() {
        return ggml_upscale_ext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_upscale_ext(struct ggml_context *ctx, struct ggml_tensor *a, int ne0, int ne1, int ne2, int ne3, enum ggml_scale_mode mode)
     * }
     */
    public static MemorySegment ggml_upscale_ext(MemorySegment ctx, MemorySegment a, int ne0, int ne1, int ne2, int ne3, int mode) {
        var mh$ = ggml_upscale_ext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_upscale_ext", ctx, a, ne0, ne1, ne2, ne3, mode);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, ne0, ne1, ne2, ne3, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_interpolate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_interpolate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_interpolate(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3, uint32_t mode)
     * }
     */
    public static FunctionDescriptor ggml_interpolate$descriptor() {
        return ggml_interpolate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_interpolate(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3, uint32_t mode)
     * }
     */
    public static MethodHandle ggml_interpolate$handle() {
        return ggml_interpolate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_interpolate(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3, uint32_t mode)
     * }
     */
    public static MemorySegment ggml_interpolate$address() {
        return ggml_interpolate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_interpolate(struct ggml_context *ctx, struct ggml_tensor *a, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3, uint32_t mode)
     * }
     */
    public static MemorySegment ggml_interpolate(MemorySegment ctx, MemorySegment a, long ne0, long ne1, long ne2, long ne3, int mode) {
        var mh$ = ggml_interpolate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_interpolate", ctx, a, ne0, ne1, ne2, ne3, mode);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, ne0, ne1, ne2, ne3, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_pad {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_pad");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pad(struct ggml_context *ctx, struct ggml_tensor *a, int p0, int p1, int p2, int p3)
     * }
     */
    public static FunctionDescriptor ggml_pad$descriptor() {
        return ggml_pad.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pad(struct ggml_context *ctx, struct ggml_tensor *a, int p0, int p1, int p2, int p3)
     * }
     */
    public static MethodHandle ggml_pad$handle() {
        return ggml_pad.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pad(struct ggml_context *ctx, struct ggml_tensor *a, int p0, int p1, int p2, int p3)
     * }
     */
    public static MemorySegment ggml_pad$address() {
        return ggml_pad.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pad(struct ggml_context *ctx, struct ggml_tensor *a, int p0, int p1, int p2, int p3)
     * }
     */
    public static MemorySegment ggml_pad(MemorySegment ctx, MemorySegment a, int p0, int p1, int p2, int p3) {
        var mh$ = ggml_pad.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_pad", ctx, a, p0, p1, p2, p3);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, p0, p1, p2, p3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_pad_reflect_1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_pad_reflect_1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pad_reflect_1d(struct ggml_context *ctx, struct ggml_tensor *a, int p0, int p1)
     * }
     */
    public static FunctionDescriptor ggml_pad_reflect_1d$descriptor() {
        return ggml_pad_reflect_1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pad_reflect_1d(struct ggml_context *ctx, struct ggml_tensor *a, int p0, int p1)
     * }
     */
    public static MethodHandle ggml_pad_reflect_1d$handle() {
        return ggml_pad_reflect_1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pad_reflect_1d(struct ggml_context *ctx, struct ggml_tensor *a, int p0, int p1)
     * }
     */
    public static MemorySegment ggml_pad_reflect_1d$address() {
        return ggml_pad_reflect_1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pad_reflect_1d(struct ggml_context *ctx, struct ggml_tensor *a, int p0, int p1)
     * }
     */
    public static MemorySegment ggml_pad_reflect_1d(MemorySegment ctx, MemorySegment a, int p0, int p1) {
        var mh$ = ggml_pad_reflect_1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_pad_reflect_1d", ctx, a, p0, p1);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, p0, p1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_roll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_roll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_roll(struct ggml_context *ctx, struct ggml_tensor *a, int shift0, int shift1, int shift2, int shift3)
     * }
     */
    public static FunctionDescriptor ggml_roll$descriptor() {
        return ggml_roll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_roll(struct ggml_context *ctx, struct ggml_tensor *a, int shift0, int shift1, int shift2, int shift3)
     * }
     */
    public static MethodHandle ggml_roll$handle() {
        return ggml_roll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_roll(struct ggml_context *ctx, struct ggml_tensor *a, int shift0, int shift1, int shift2, int shift3)
     * }
     */
    public static MemorySegment ggml_roll$address() {
        return ggml_roll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_roll(struct ggml_context *ctx, struct ggml_tensor *a, int shift0, int shift1, int shift2, int shift3)
     * }
     */
    public static MemorySegment ggml_roll(MemorySegment ctx, MemorySegment a, int shift0, int shift1, int shift2, int shift3) {
        var mh$ = ggml_roll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_roll", ctx, a, shift0, shift1, shift2, shift3);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, shift0, shift1, shift2, shift3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_timestep_embedding {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_timestep_embedding");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_timestep_embedding(struct ggml_context *ctx, struct ggml_tensor *timesteps, int dim, int max_period)
     * }
     */
    public static FunctionDescriptor ggml_timestep_embedding$descriptor() {
        return ggml_timestep_embedding.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_timestep_embedding(struct ggml_context *ctx, struct ggml_tensor *timesteps, int dim, int max_period)
     * }
     */
    public static MethodHandle ggml_timestep_embedding$handle() {
        return ggml_timestep_embedding.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_timestep_embedding(struct ggml_context *ctx, struct ggml_tensor *timesteps, int dim, int max_period)
     * }
     */
    public static MemorySegment ggml_timestep_embedding$address() {
        return ggml_timestep_embedding.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_timestep_embedding(struct ggml_context *ctx, struct ggml_tensor *timesteps, int dim, int max_period)
     * }
     */
    public static MemorySegment ggml_timestep_embedding(MemorySegment ctx, MemorySegment timesteps, int dim, int max_period) {
        var mh$ = ggml_timestep_embedding.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_timestep_embedding", ctx, timesteps, dim, max_period);
            }
            return (MemorySegment)mh$.invokeExact(ctx, timesteps, dim, max_period);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GGML_SORT_ORDER_ASC = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ggml_sort_order.GGML_SORT_ORDER_ASC = 0
     * }
     */
    public static int GGML_SORT_ORDER_ASC() {
        return GGML_SORT_ORDER_ASC;
    }
    private static final int GGML_SORT_ORDER_DESC = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ggml_sort_order.GGML_SORT_ORDER_DESC = 1
     * }
     */
    public static int GGML_SORT_ORDER_DESC() {
        return GGML_SORT_ORDER_DESC;
    }

    private static class ggml_argsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_argsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_argsort(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_sort_order order)
     * }
     */
    public static FunctionDescriptor ggml_argsort$descriptor() {
        return ggml_argsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_argsort(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_sort_order order)
     * }
     */
    public static MethodHandle ggml_argsort$handle() {
        return ggml_argsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_argsort(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_sort_order order)
     * }
     */
    public static MemorySegment ggml_argsort$address() {
        return ggml_argsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_argsort(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_sort_order order)
     * }
     */
    public static MemorySegment ggml_argsort(MemorySegment ctx, MemorySegment a, int order) {
        var mh$ = ggml_argsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_argsort", ctx, a, order);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, order);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_arange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_arange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_arange(struct ggml_context *ctx, float start, float stop, float step)
     * }
     */
    public static FunctionDescriptor ggml_arange$descriptor() {
        return ggml_arange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_arange(struct ggml_context *ctx, float start, float stop, float step)
     * }
     */
    public static MethodHandle ggml_arange$handle() {
        return ggml_arange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_arange(struct ggml_context *ctx, float start, float stop, float step)
     * }
     */
    public static MemorySegment ggml_arange$address() {
        return ggml_arange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_arange(struct ggml_context *ctx, float start, float stop, float step)
     * }
     */
    public static MemorySegment ggml_arange(MemorySegment ctx, float start, float stop, float step) {
        var mh$ = ggml_arange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_arange", ctx, start, stop, step);
            }
            return (MemorySegment)mh$.invokeExact(ctx, start, stop, step);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_top_k {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_top_k");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_top_k(struct ggml_context *ctx, struct ggml_tensor *a, int k)
     * }
     */
    public static FunctionDescriptor ggml_top_k$descriptor() {
        return ggml_top_k.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_top_k(struct ggml_context *ctx, struct ggml_tensor *a, int k)
     * }
     */
    public static MethodHandle ggml_top_k$handle() {
        return ggml_top_k.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_top_k(struct ggml_context *ctx, struct ggml_tensor *a, int k)
     * }
     */
    public static MemorySegment ggml_top_k$address() {
        return ggml_top_k.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_top_k(struct ggml_context *ctx, struct ggml_tensor *a, int k)
     * }
     */
    public static MemorySegment ggml_top_k(MemorySegment ctx, MemorySegment a, int k) {
        var mh$ = ggml_top_k.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_top_k", ctx, a, k);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_flash_attn_ext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_flash_attn_ext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_flash_attn_ext(struct ggml_context *ctx, struct ggml_tensor *q, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *mask, float scale, float max_bias, float logit_softcap)
     * }
     */
    public static FunctionDescriptor ggml_flash_attn_ext$descriptor() {
        return ggml_flash_attn_ext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_flash_attn_ext(struct ggml_context *ctx, struct ggml_tensor *q, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *mask, float scale, float max_bias, float logit_softcap)
     * }
     */
    public static MethodHandle ggml_flash_attn_ext$handle() {
        return ggml_flash_attn_ext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_flash_attn_ext(struct ggml_context *ctx, struct ggml_tensor *q, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *mask, float scale, float max_bias, float logit_softcap)
     * }
     */
    public static MemorySegment ggml_flash_attn_ext$address() {
        return ggml_flash_attn_ext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_flash_attn_ext(struct ggml_context *ctx, struct ggml_tensor *q, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *mask, float scale, float max_bias, float logit_softcap)
     * }
     */
    public static MemorySegment ggml_flash_attn_ext(MemorySegment ctx, MemorySegment q, MemorySegment k, MemorySegment v, MemorySegment mask, float scale, float max_bias, float logit_softcap) {
        var mh$ = ggml_flash_attn_ext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_flash_attn_ext", ctx, q, k, v, mask, scale, max_bias, logit_softcap);
            }
            return (MemorySegment)mh$.invokeExact(ctx, q, k, v, mask, scale, max_bias, logit_softcap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_flash_attn_ext_set_prec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_flash_attn_ext_set_prec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_flash_attn_ext_set_prec(struct ggml_tensor *a, enum ggml_prec prec)
     * }
     */
    public static FunctionDescriptor ggml_flash_attn_ext_set_prec$descriptor() {
        return ggml_flash_attn_ext_set_prec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_flash_attn_ext_set_prec(struct ggml_tensor *a, enum ggml_prec prec)
     * }
     */
    public static MethodHandle ggml_flash_attn_ext_set_prec$handle() {
        return ggml_flash_attn_ext_set_prec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_flash_attn_ext_set_prec(struct ggml_tensor *a, enum ggml_prec prec)
     * }
     */
    public static MemorySegment ggml_flash_attn_ext_set_prec$address() {
        return ggml_flash_attn_ext_set_prec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_flash_attn_ext_set_prec(struct ggml_tensor *a, enum ggml_prec prec)
     * }
     */
    public static void ggml_flash_attn_ext_set_prec(MemorySegment a, int prec) {
        var mh$ = ggml_flash_attn_ext_set_prec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_flash_attn_ext_set_prec", a, prec);
            }
            mh$.invokeExact(a, prec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_flash_attn_ext_get_prec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_flash_attn_ext_get_prec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_prec ggml_flash_attn_ext_get_prec(const struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_flash_attn_ext_get_prec$descriptor() {
        return ggml_flash_attn_ext_get_prec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_prec ggml_flash_attn_ext_get_prec(const struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_flash_attn_ext_get_prec$handle() {
        return ggml_flash_attn_ext_get_prec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_prec ggml_flash_attn_ext_get_prec(const struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_flash_attn_ext_get_prec$address() {
        return ggml_flash_attn_ext_get_prec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_prec ggml_flash_attn_ext_get_prec(const struct ggml_tensor *a)
     * }
     */
    public static int ggml_flash_attn_ext_get_prec(MemorySegment a) {
        var mh$ = ggml_flash_attn_ext_get_prec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_flash_attn_ext_get_prec", a);
            }
            return (int)mh$.invokeExact(a);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_flash_attn_ext_add_sinks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_flash_attn_ext_add_sinks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_flash_attn_ext_add_sinks(struct ggml_tensor *a, struct ggml_tensor *sinks)
     * }
     */
    public static FunctionDescriptor ggml_flash_attn_ext_add_sinks$descriptor() {
        return ggml_flash_attn_ext_add_sinks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_flash_attn_ext_add_sinks(struct ggml_tensor *a, struct ggml_tensor *sinks)
     * }
     */
    public static MethodHandle ggml_flash_attn_ext_add_sinks$handle() {
        return ggml_flash_attn_ext_add_sinks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_flash_attn_ext_add_sinks(struct ggml_tensor *a, struct ggml_tensor *sinks)
     * }
     */
    public static MemorySegment ggml_flash_attn_ext_add_sinks$address() {
        return ggml_flash_attn_ext_add_sinks.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_flash_attn_ext_add_sinks(struct ggml_tensor *a, struct ggml_tensor *sinks)
     * }
     */
    public static void ggml_flash_attn_ext_add_sinks(MemorySegment a, MemorySegment sinks) {
        var mh$ = ggml_flash_attn_ext_add_sinks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_flash_attn_ext_add_sinks", a, sinks);
            }
            mh$.invokeExact(a, sinks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_flash_attn_back {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_BOOL
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_flash_attn_back");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_flash_attn_back(struct ggml_context *ctx, struct ggml_tensor *q, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *d, bool masked)
     * }
     */
    public static FunctionDescriptor ggml_flash_attn_back$descriptor() {
        return ggml_flash_attn_back.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_flash_attn_back(struct ggml_context *ctx, struct ggml_tensor *q, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *d, bool masked)
     * }
     */
    public static MethodHandle ggml_flash_attn_back$handle() {
        return ggml_flash_attn_back.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_flash_attn_back(struct ggml_context *ctx, struct ggml_tensor *q, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *d, bool masked)
     * }
     */
    public static MemorySegment ggml_flash_attn_back$address() {
        return ggml_flash_attn_back.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_flash_attn_back(struct ggml_context *ctx, struct ggml_tensor *q, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *d, bool masked)
     * }
     */
    public static MemorySegment ggml_flash_attn_back(MemorySegment ctx, MemorySegment q, MemorySegment k, MemorySegment v, MemorySegment d, boolean masked) {
        var mh$ = ggml_flash_attn_back.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_flash_attn_back", ctx, q, k, v, d, masked);
            }
            return (MemorySegment)mh$.invokeExact(ctx, q, k, v, d, masked);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_ssm_conv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_ssm_conv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_ssm_conv(struct ggml_context *ctx, struct ggml_tensor *sx, struct ggml_tensor *c)
     * }
     */
    public static FunctionDescriptor ggml_ssm_conv$descriptor() {
        return ggml_ssm_conv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_ssm_conv(struct ggml_context *ctx, struct ggml_tensor *sx, struct ggml_tensor *c)
     * }
     */
    public static MethodHandle ggml_ssm_conv$handle() {
        return ggml_ssm_conv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_ssm_conv(struct ggml_context *ctx, struct ggml_tensor *sx, struct ggml_tensor *c)
     * }
     */
    public static MemorySegment ggml_ssm_conv$address() {
        return ggml_ssm_conv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_ssm_conv(struct ggml_context *ctx, struct ggml_tensor *sx, struct ggml_tensor *c)
     * }
     */
    public static MemorySegment ggml_ssm_conv(MemorySegment ctx, MemorySegment sx, MemorySegment c) {
        var mh$ = ggml_ssm_conv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_ssm_conv", ctx, sx, c);
            }
            return (MemorySegment)mh$.invokeExact(ctx, sx, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_ssm_scan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_ssm_scan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_ssm_scan(struct ggml_context *ctx, struct ggml_tensor *s, struct ggml_tensor *x, struct ggml_tensor *dt, struct ggml_tensor *A, struct ggml_tensor *B, struct ggml_tensor *C, struct ggml_tensor *ids)
     * }
     */
    public static FunctionDescriptor ggml_ssm_scan$descriptor() {
        return ggml_ssm_scan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_ssm_scan(struct ggml_context *ctx, struct ggml_tensor *s, struct ggml_tensor *x, struct ggml_tensor *dt, struct ggml_tensor *A, struct ggml_tensor *B, struct ggml_tensor *C, struct ggml_tensor *ids)
     * }
     */
    public static MethodHandle ggml_ssm_scan$handle() {
        return ggml_ssm_scan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_ssm_scan(struct ggml_context *ctx, struct ggml_tensor *s, struct ggml_tensor *x, struct ggml_tensor *dt, struct ggml_tensor *A, struct ggml_tensor *B, struct ggml_tensor *C, struct ggml_tensor *ids)
     * }
     */
    public static MemorySegment ggml_ssm_scan$address() {
        return ggml_ssm_scan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_ssm_scan(struct ggml_context *ctx, struct ggml_tensor *s, struct ggml_tensor *x, struct ggml_tensor *dt, struct ggml_tensor *A, struct ggml_tensor *B, struct ggml_tensor *C, struct ggml_tensor *ids)
     * }
     */
    public static MemorySegment ggml_ssm_scan(MemorySegment ctx, MemorySegment s, MemorySegment x, MemorySegment dt, MemorySegment A, MemorySegment B, MemorySegment C, MemorySegment ids) {
        var mh$ = ggml_ssm_scan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_ssm_scan", ctx, s, x, dt, A, B, C, ids);
            }
            return (MemorySegment)mh$.invokeExact(ctx, s, x, dt, A, B, C, ids);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_win_part {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_win_part");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_win_part(struct ggml_context *ctx, struct ggml_tensor *a, int w)
     * }
     */
    public static FunctionDescriptor ggml_win_part$descriptor() {
        return ggml_win_part.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_win_part(struct ggml_context *ctx, struct ggml_tensor *a, int w)
     * }
     */
    public static MethodHandle ggml_win_part$handle() {
        return ggml_win_part.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_win_part(struct ggml_context *ctx, struct ggml_tensor *a, int w)
     * }
     */
    public static MemorySegment ggml_win_part$address() {
        return ggml_win_part.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_win_part(struct ggml_context *ctx, struct ggml_tensor *a, int w)
     * }
     */
    public static MemorySegment ggml_win_part(MemorySegment ctx, MemorySegment a, int w) {
        var mh$ = ggml_win_part.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_win_part", ctx, a, w);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_win_unpart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_win_unpart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_win_unpart(struct ggml_context *ctx, struct ggml_tensor *a, int w0, int h0, int w)
     * }
     */
    public static FunctionDescriptor ggml_win_unpart$descriptor() {
        return ggml_win_unpart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_win_unpart(struct ggml_context *ctx, struct ggml_tensor *a, int w0, int h0, int w)
     * }
     */
    public static MethodHandle ggml_win_unpart$handle() {
        return ggml_win_unpart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_win_unpart(struct ggml_context *ctx, struct ggml_tensor *a, int w0, int h0, int w)
     * }
     */
    public static MemorySegment ggml_win_unpart$address() {
        return ggml_win_unpart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_win_unpart(struct ggml_context *ctx, struct ggml_tensor *a, int w0, int h0, int w)
     * }
     */
    public static MemorySegment ggml_win_unpart(MemorySegment ctx, MemorySegment a, int w0, int h0, int w) {
        var mh$ = ggml_win_unpart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_win_unpart", ctx, a, w0, h0, w);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, w0, h0, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_unary {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_unary");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_unary(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_unary_op op)
     * }
     */
    public static FunctionDescriptor ggml_unary$descriptor() {
        return ggml_unary.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_unary(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_unary_op op)
     * }
     */
    public static MethodHandle ggml_unary$handle() {
        return ggml_unary.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_unary(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_unary_op op)
     * }
     */
    public static MemorySegment ggml_unary$address() {
        return ggml_unary.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_unary(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_unary_op op)
     * }
     */
    public static MemorySegment ggml_unary(MemorySegment ctx, MemorySegment a, int op) {
        var mh$ = ggml_unary.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_unary", ctx, a, op);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_unary_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_unary_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_unary_inplace(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_unary_op op)
     * }
     */
    public static FunctionDescriptor ggml_unary_inplace$descriptor() {
        return ggml_unary_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_unary_inplace(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_unary_op op)
     * }
     */
    public static MethodHandle ggml_unary_inplace$handle() {
        return ggml_unary_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_unary_inplace(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_unary_op op)
     * }
     */
    public static MemorySegment ggml_unary_inplace$address() {
        return ggml_unary_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_unary_inplace(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_unary_op op)
     * }
     */
    public static MemorySegment ggml_unary_inplace(MemorySegment ctx, MemorySegment a, int op) {
        var mh$ = ggml_unary_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_unary_inplace", ctx, a, op);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_rel_pos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_rel_pos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_rel_pos(struct ggml_context *ctx, struct ggml_tensor *a, int qh, int kh)
     * }
     */
    public static FunctionDescriptor ggml_get_rel_pos$descriptor() {
        return ggml_get_rel_pos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_rel_pos(struct ggml_context *ctx, struct ggml_tensor *a, int qh, int kh)
     * }
     */
    public static MethodHandle ggml_get_rel_pos$handle() {
        return ggml_get_rel_pos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_rel_pos(struct ggml_context *ctx, struct ggml_tensor *a, int qh, int kh)
     * }
     */
    public static MemorySegment ggml_get_rel_pos$address() {
        return ggml_get_rel_pos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_rel_pos(struct ggml_context *ctx, struct ggml_tensor *a, int qh, int kh)
     * }
     */
    public static MemorySegment ggml_get_rel_pos(MemorySegment ctx, MemorySegment a, int qh, int kh) {
        var mh$ = ggml_get_rel_pos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_rel_pos", ctx, a, qh, kh);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, qh, kh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_add_rel_pos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_add_rel_pos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_rel_pos(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *pw, struct ggml_tensor *ph)
     * }
     */
    public static FunctionDescriptor ggml_add_rel_pos$descriptor() {
        return ggml_add_rel_pos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_rel_pos(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *pw, struct ggml_tensor *ph)
     * }
     */
    public static MethodHandle ggml_add_rel_pos$handle() {
        return ggml_add_rel_pos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_rel_pos(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *pw, struct ggml_tensor *ph)
     * }
     */
    public static MemorySegment ggml_add_rel_pos$address() {
        return ggml_add_rel_pos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_rel_pos(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *pw, struct ggml_tensor *ph)
     * }
     */
    public static MemorySegment ggml_add_rel_pos(MemorySegment ctx, MemorySegment a, MemorySegment pw, MemorySegment ph) {
        var mh$ = ggml_add_rel_pos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_add_rel_pos", ctx, a, pw, ph);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, pw, ph);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_add_rel_pos_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_add_rel_pos_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_rel_pos_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *pw, struct ggml_tensor *ph)
     * }
     */
    public static FunctionDescriptor ggml_add_rel_pos_inplace$descriptor() {
        return ggml_add_rel_pos_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_rel_pos_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *pw, struct ggml_tensor *ph)
     * }
     */
    public static MethodHandle ggml_add_rel_pos_inplace$handle() {
        return ggml_add_rel_pos_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_rel_pos_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *pw, struct ggml_tensor *ph)
     * }
     */
    public static MemorySegment ggml_add_rel_pos_inplace$address() {
        return ggml_add_rel_pos_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_rel_pos_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *pw, struct ggml_tensor *ph)
     * }
     */
    public static MemorySegment ggml_add_rel_pos_inplace(MemorySegment ctx, MemorySegment a, MemorySegment pw, MemorySegment ph) {
        var mh$ = ggml_add_rel_pos_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_add_rel_pos_inplace", ctx, a, pw, ph);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, pw, ph);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_rwkv_wkv6 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_rwkv_wkv6");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rwkv_wkv6(struct ggml_context *ctx, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *r, struct ggml_tensor *tf, struct ggml_tensor *td, struct ggml_tensor *state)
     * }
     */
    public static FunctionDescriptor ggml_rwkv_wkv6$descriptor() {
        return ggml_rwkv_wkv6.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rwkv_wkv6(struct ggml_context *ctx, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *r, struct ggml_tensor *tf, struct ggml_tensor *td, struct ggml_tensor *state)
     * }
     */
    public static MethodHandle ggml_rwkv_wkv6$handle() {
        return ggml_rwkv_wkv6.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rwkv_wkv6(struct ggml_context *ctx, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *r, struct ggml_tensor *tf, struct ggml_tensor *td, struct ggml_tensor *state)
     * }
     */
    public static MemorySegment ggml_rwkv_wkv6$address() {
        return ggml_rwkv_wkv6.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rwkv_wkv6(struct ggml_context *ctx, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *r, struct ggml_tensor *tf, struct ggml_tensor *td, struct ggml_tensor *state)
     * }
     */
    public static MemorySegment ggml_rwkv_wkv6(MemorySegment ctx, MemorySegment k, MemorySegment v, MemorySegment r, MemorySegment tf, MemorySegment td, MemorySegment state) {
        var mh$ = ggml_rwkv_wkv6.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_rwkv_wkv6", ctx, k, v, r, tf, td, state);
            }
            return (MemorySegment)mh$.invokeExact(ctx, k, v, r, tf, td, state);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_gated_linear_attn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_gated_linear_attn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gated_linear_attn(struct ggml_context *ctx, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *q, struct ggml_tensor *g, struct ggml_tensor *state, float scale)
     * }
     */
    public static FunctionDescriptor ggml_gated_linear_attn$descriptor() {
        return ggml_gated_linear_attn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gated_linear_attn(struct ggml_context *ctx, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *q, struct ggml_tensor *g, struct ggml_tensor *state, float scale)
     * }
     */
    public static MethodHandle ggml_gated_linear_attn$handle() {
        return ggml_gated_linear_attn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gated_linear_attn(struct ggml_context *ctx, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *q, struct ggml_tensor *g, struct ggml_tensor *state, float scale)
     * }
     */
    public static MemorySegment ggml_gated_linear_attn$address() {
        return ggml_gated_linear_attn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gated_linear_attn(struct ggml_context *ctx, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *q, struct ggml_tensor *g, struct ggml_tensor *state, float scale)
     * }
     */
    public static MemorySegment ggml_gated_linear_attn(MemorySegment ctx, MemorySegment k, MemorySegment v, MemorySegment q, MemorySegment g, MemorySegment state, float scale) {
        var mh$ = ggml_gated_linear_attn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_gated_linear_attn", ctx, k, v, q, g, state, scale);
            }
            return (MemorySegment)mh$.invokeExact(ctx, k, v, q, g, state, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_rwkv_wkv7 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_rwkv_wkv7");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rwkv_wkv7(struct ggml_context *ctx, struct ggml_tensor *r, struct ggml_tensor *w, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *state)
     * }
     */
    public static FunctionDescriptor ggml_rwkv_wkv7$descriptor() {
        return ggml_rwkv_wkv7.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rwkv_wkv7(struct ggml_context *ctx, struct ggml_tensor *r, struct ggml_tensor *w, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *state)
     * }
     */
    public static MethodHandle ggml_rwkv_wkv7$handle() {
        return ggml_rwkv_wkv7.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rwkv_wkv7(struct ggml_context *ctx, struct ggml_tensor *r, struct ggml_tensor *w, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *state)
     * }
     */
    public static MemorySegment ggml_rwkv_wkv7$address() {
        return ggml_rwkv_wkv7.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rwkv_wkv7(struct ggml_context *ctx, struct ggml_tensor *r, struct ggml_tensor *w, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *state)
     * }
     */
    public static MemorySegment ggml_rwkv_wkv7(MemorySegment ctx, MemorySegment r, MemorySegment w, MemorySegment k, MemorySegment v, MemorySegment a, MemorySegment b, MemorySegment state) {
        var mh$ = ggml_rwkv_wkv7.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_rwkv_wkv7", ctx, r, w, k, v, a, b, state);
            }
            return (MemorySegment)mh$.invokeExact(ctx, r, w, k, v, a, b, state);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_map_custom1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_map_custom1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom1(struct ggml_context *ctx, struct ggml_tensor *a, ggml_custom1_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static FunctionDescriptor ggml_map_custom1$descriptor() {
        return ggml_map_custom1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom1(struct ggml_context *ctx, struct ggml_tensor *a, ggml_custom1_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MethodHandle ggml_map_custom1$handle() {
        return ggml_map_custom1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom1(struct ggml_context *ctx, struct ggml_tensor *a, ggml_custom1_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_map_custom1$address() {
        return ggml_map_custom1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom1(struct ggml_context *ctx, struct ggml_tensor *a, ggml_custom1_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_map_custom1(MemorySegment ctx, MemorySegment a, MemorySegment fun, int n_tasks, MemorySegment userdata) {
        var mh$ = ggml_map_custom1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_map_custom1", ctx, a, fun, n_tasks, userdata);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, fun, n_tasks, userdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_map_custom1_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_map_custom1_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom1_inplace(struct ggml_context *ctx, struct ggml_tensor *a, ggml_custom1_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static FunctionDescriptor ggml_map_custom1_inplace$descriptor() {
        return ggml_map_custom1_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom1_inplace(struct ggml_context *ctx, struct ggml_tensor *a, ggml_custom1_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MethodHandle ggml_map_custom1_inplace$handle() {
        return ggml_map_custom1_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom1_inplace(struct ggml_context *ctx, struct ggml_tensor *a, ggml_custom1_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_map_custom1_inplace$address() {
        return ggml_map_custom1_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom1_inplace(struct ggml_context *ctx, struct ggml_tensor *a, ggml_custom1_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_map_custom1_inplace(MemorySegment ctx, MemorySegment a, MemorySegment fun, int n_tasks, MemorySegment userdata) {
        var mh$ = ggml_map_custom1_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_map_custom1_inplace", ctx, a, fun, n_tasks, userdata);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, fun, n_tasks, userdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_map_custom2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_map_custom2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom2(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, ggml_custom2_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static FunctionDescriptor ggml_map_custom2$descriptor() {
        return ggml_map_custom2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom2(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, ggml_custom2_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MethodHandle ggml_map_custom2$handle() {
        return ggml_map_custom2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom2(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, ggml_custom2_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_map_custom2$address() {
        return ggml_map_custom2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom2(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, ggml_custom2_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_map_custom2(MemorySegment ctx, MemorySegment a, MemorySegment b, MemorySegment fun, int n_tasks, MemorySegment userdata) {
        var mh$ = ggml_map_custom2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_map_custom2", ctx, a, b, fun, n_tasks, userdata);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, fun, n_tasks, userdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_map_custom2_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_map_custom2_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom2_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, ggml_custom2_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static FunctionDescriptor ggml_map_custom2_inplace$descriptor() {
        return ggml_map_custom2_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom2_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, ggml_custom2_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MethodHandle ggml_map_custom2_inplace$handle() {
        return ggml_map_custom2_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom2_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, ggml_custom2_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_map_custom2_inplace$address() {
        return ggml_map_custom2_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom2_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, ggml_custom2_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_map_custom2_inplace(MemorySegment ctx, MemorySegment a, MemorySegment b, MemorySegment fun, int n_tasks, MemorySegment userdata) {
        var mh$ = ggml_map_custom2_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_map_custom2_inplace", ctx, a, b, fun, n_tasks, userdata);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, fun, n_tasks, userdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_map_custom3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_map_custom3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom3(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, ggml_custom3_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static FunctionDescriptor ggml_map_custom3$descriptor() {
        return ggml_map_custom3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom3(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, ggml_custom3_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MethodHandle ggml_map_custom3$handle() {
        return ggml_map_custom3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom3(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, ggml_custom3_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_map_custom3$address() {
        return ggml_map_custom3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom3(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, ggml_custom3_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_map_custom3(MemorySegment ctx, MemorySegment a, MemorySegment b, MemorySegment c, MemorySegment fun, int n_tasks, MemorySegment userdata) {
        var mh$ = ggml_map_custom3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_map_custom3", ctx, a, b, c, fun, n_tasks, userdata);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, c, fun, n_tasks, userdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_map_custom3_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_map_custom3_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom3_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, ggml_custom3_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static FunctionDescriptor ggml_map_custom3_inplace$descriptor() {
        return ggml_map_custom3_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom3_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, ggml_custom3_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MethodHandle ggml_map_custom3_inplace$handle() {
        return ggml_map_custom3_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom3_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, ggml_custom3_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_map_custom3_inplace$address() {
        return ggml_map_custom3_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom3_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, ggml_custom3_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_map_custom3_inplace(MemorySegment ctx, MemorySegment a, MemorySegment b, MemorySegment c, MemorySegment fun, int n_tasks, MemorySegment userdata) {
        var mh$ = ggml_map_custom3_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_map_custom3_inplace", ctx, a, b, c, fun, n_tasks, userdata);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, c, fun, n_tasks, userdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_custom_4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_custom_4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_custom_4d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3, struct ggml_tensor **args, int n_args, ggml_custom_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static FunctionDescriptor ggml_custom_4d$descriptor() {
        return ggml_custom_4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_custom_4d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3, struct ggml_tensor **args, int n_args, ggml_custom_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MethodHandle ggml_custom_4d$handle() {
        return ggml_custom_4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_custom_4d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3, struct ggml_tensor **args, int n_args, ggml_custom_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_custom_4d$address() {
        return ggml_custom_4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_custom_4d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3, struct ggml_tensor **args, int n_args, ggml_custom_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_custom_4d(MemorySegment ctx, int type, long ne0, long ne1, long ne2, long ne3, MemorySegment args, int n_args, MemorySegment fun, int n_tasks, MemorySegment userdata) {
        var mh$ = ggml_custom_4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_custom_4d", ctx, type, ne0, ne1, ne2, ne3, args, n_args, fun, n_tasks, userdata);
            }
            return (MemorySegment)mh$.invokeExact(ctx, type, ne0, ne1, ne2, ne3, args, n_args, fun, n_tasks, userdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_custom_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_custom_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_custom_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor **args, int n_args, ggml_custom_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static FunctionDescriptor ggml_custom_inplace$descriptor() {
        return ggml_custom_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_custom_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor **args, int n_args, ggml_custom_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MethodHandle ggml_custom_inplace$handle() {
        return ggml_custom_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_custom_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor **args, int n_args, ggml_custom_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_custom_inplace$address() {
        return ggml_custom_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_custom_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor **args, int n_args, ggml_custom_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_custom_inplace(MemorySegment ctx, MemorySegment a, MemorySegment args, int n_args, MemorySegment fun, int n_tasks, MemorySegment userdata) {
        var mh$ = ggml_custom_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_custom_inplace", ctx, a, args, n_args, fun, n_tasks, userdata);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, args, n_args, fun, n_tasks, userdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cross_entropy_loss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cross_entropy_loss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cross_entropy_loss(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_cross_entropy_loss$descriptor() {
        return ggml_cross_entropy_loss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cross_entropy_loss(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_cross_entropy_loss$handle() {
        return ggml_cross_entropy_loss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cross_entropy_loss(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_cross_entropy_loss$address() {
        return ggml_cross_entropy_loss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cross_entropy_loss(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_cross_entropy_loss(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_cross_entropy_loss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cross_entropy_loss", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cross_entropy_loss_back {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_cross_entropy_loss_back");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cross_entropy_loss_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c)
     * }
     */
    public static FunctionDescriptor ggml_cross_entropy_loss_back$descriptor() {
        return ggml_cross_entropy_loss_back.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cross_entropy_loss_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c)
     * }
     */
    public static MethodHandle ggml_cross_entropy_loss_back$handle() {
        return ggml_cross_entropy_loss_back.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cross_entropy_loss_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c)
     * }
     */
    public static MemorySegment ggml_cross_entropy_loss_back$address() {
        return ggml_cross_entropy_loss_back.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cross_entropy_loss_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c)
     * }
     */
    public static MemorySegment ggml_cross_entropy_loss_back(MemorySegment ctx, MemorySegment a, MemorySegment b, MemorySegment c) {
        var mh$ = ggml_cross_entropy_loss_back.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cross_entropy_loss_back", ctx, a, b, c);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_opt_step_adamw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_opt_step_adamw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_step_adamw(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *grad, struct ggml_tensor *m, struct ggml_tensor *v, struct ggml_tensor *adamw_params)
     * }
     */
    public static FunctionDescriptor ggml_opt_step_adamw$descriptor() {
        return ggml_opt_step_adamw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_step_adamw(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *grad, struct ggml_tensor *m, struct ggml_tensor *v, struct ggml_tensor *adamw_params)
     * }
     */
    public static MethodHandle ggml_opt_step_adamw$handle() {
        return ggml_opt_step_adamw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_step_adamw(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *grad, struct ggml_tensor *m, struct ggml_tensor *v, struct ggml_tensor *adamw_params)
     * }
     */
    public static MemorySegment ggml_opt_step_adamw$address() {
        return ggml_opt_step_adamw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_step_adamw(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *grad, struct ggml_tensor *m, struct ggml_tensor *v, struct ggml_tensor *adamw_params)
     * }
     */
    public static MemorySegment ggml_opt_step_adamw(MemorySegment ctx, MemorySegment a, MemorySegment grad, MemorySegment m, MemorySegment v, MemorySegment adamw_params) {
        var mh$ = ggml_opt_step_adamw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_opt_step_adamw", ctx, a, grad, m, v, adamw_params);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, grad, m, v, adamw_params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_opt_step_sgd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_opt_step_sgd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_step_sgd(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *grad, struct ggml_tensor *sgd_params)
     * }
     */
    public static FunctionDescriptor ggml_opt_step_sgd$descriptor() {
        return ggml_opt_step_sgd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_step_sgd(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *grad, struct ggml_tensor *sgd_params)
     * }
     */
    public static MethodHandle ggml_opt_step_sgd$handle() {
        return ggml_opt_step_sgd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_step_sgd(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *grad, struct ggml_tensor *sgd_params)
     * }
     */
    public static MemorySegment ggml_opt_step_sgd$address() {
        return ggml_opt_step_sgd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_step_sgd(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *grad, struct ggml_tensor *sgd_params)
     * }
     */
    public static MemorySegment ggml_opt_step_sgd(MemorySegment ctx, MemorySegment a, MemorySegment grad, MemorySegment sgd_params) {
        var mh$ = ggml_opt_step_sgd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_opt_step_sgd", ctx, a, grad, sgd_params);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, grad, sgd_params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_build_forward_expand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_build_forward_expand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_build_forward_expand(struct ggml_cgraph *cgraph, struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_build_forward_expand$descriptor() {
        return ggml_build_forward_expand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_build_forward_expand(struct ggml_cgraph *cgraph, struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_build_forward_expand$handle() {
        return ggml_build_forward_expand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_build_forward_expand(struct ggml_cgraph *cgraph, struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_build_forward_expand$address() {
        return ggml_build_forward_expand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_build_forward_expand(struct ggml_cgraph *cgraph, struct ggml_tensor *tensor)
     * }
     */
    public static void ggml_build_forward_expand(MemorySegment cgraph, MemorySegment tensor) {
        var mh$ = ggml_build_forward_expand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_build_forward_expand", cgraph, tensor);
            }
            mh$.invokeExact(cgraph, tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_build_backward_expand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_build_backward_expand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_build_backward_expand(struct ggml_context *ctx, struct ggml_cgraph *cgraph, struct ggml_tensor **grad_accs)
     * }
     */
    public static FunctionDescriptor ggml_build_backward_expand$descriptor() {
        return ggml_build_backward_expand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_build_backward_expand(struct ggml_context *ctx, struct ggml_cgraph *cgraph, struct ggml_tensor **grad_accs)
     * }
     */
    public static MethodHandle ggml_build_backward_expand$handle() {
        return ggml_build_backward_expand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_build_backward_expand(struct ggml_context *ctx, struct ggml_cgraph *cgraph, struct ggml_tensor **grad_accs)
     * }
     */
    public static MemorySegment ggml_build_backward_expand$address() {
        return ggml_build_backward_expand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_build_backward_expand(struct ggml_context *ctx, struct ggml_cgraph *cgraph, struct ggml_tensor **grad_accs)
     * }
     */
    public static void ggml_build_backward_expand(MemorySegment ctx, MemorySegment cgraph, MemorySegment grad_accs) {
        var mh$ = ggml_build_backward_expand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_build_backward_expand", ctx, cgraph, grad_accs);
            }
            mh$.invokeExact(ctx, cgraph, grad_accs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_new_graph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_new_graph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_cgraph *ggml_new_graph(struct ggml_context *ctx)
     * }
     */
    public static FunctionDescriptor ggml_new_graph$descriptor() {
        return ggml_new_graph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_cgraph *ggml_new_graph(struct ggml_context *ctx)
     * }
     */
    public static MethodHandle ggml_new_graph$handle() {
        return ggml_new_graph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_cgraph *ggml_new_graph(struct ggml_context *ctx)
     * }
     */
    public static MemorySegment ggml_new_graph$address() {
        return ggml_new_graph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_cgraph *ggml_new_graph(struct ggml_context *ctx)
     * }
     */
    public static MemorySegment ggml_new_graph(MemorySegment ctx) {
        var mh$ = ggml_new_graph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_new_graph", ctx);
            }
            return (MemorySegment)mh$.invokeExact(ctx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_new_graph_custom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG,
            WhisperCpp.C_BOOL
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_new_graph_custom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_cgraph *ggml_new_graph_custom(struct ggml_context *ctx, size_t size, bool grads)
     * }
     */
    public static FunctionDescriptor ggml_new_graph_custom$descriptor() {
        return ggml_new_graph_custom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_cgraph *ggml_new_graph_custom(struct ggml_context *ctx, size_t size, bool grads)
     * }
     */
    public static MethodHandle ggml_new_graph_custom$handle() {
        return ggml_new_graph_custom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_cgraph *ggml_new_graph_custom(struct ggml_context *ctx, size_t size, bool grads)
     * }
     */
    public static MemorySegment ggml_new_graph_custom$address() {
        return ggml_new_graph_custom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_cgraph *ggml_new_graph_custom(struct ggml_context *ctx, size_t size, bool grads)
     * }
     */
    public static MemorySegment ggml_new_graph_custom(MemorySegment ctx, long size, boolean grads) {
        var mh$ = ggml_new_graph_custom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_new_graph_custom", ctx, size, grads);
            }
            return (MemorySegment)mh$.invokeExact(ctx, size, grads);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_dup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_BOOL
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_graph_dup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_cgraph *ggml_graph_dup(struct ggml_context *ctx, struct ggml_cgraph *cgraph, bool force_grads)
     * }
     */
    public static FunctionDescriptor ggml_graph_dup$descriptor() {
        return ggml_graph_dup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_cgraph *ggml_graph_dup(struct ggml_context *ctx, struct ggml_cgraph *cgraph, bool force_grads)
     * }
     */
    public static MethodHandle ggml_graph_dup$handle() {
        return ggml_graph_dup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_cgraph *ggml_graph_dup(struct ggml_context *ctx, struct ggml_cgraph *cgraph, bool force_grads)
     * }
     */
    public static MemorySegment ggml_graph_dup$address() {
        return ggml_graph_dup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_cgraph *ggml_graph_dup(struct ggml_context *ctx, struct ggml_cgraph *cgraph, bool force_grads)
     * }
     */
    public static MemorySegment ggml_graph_dup(MemorySegment ctx, MemorySegment cgraph, boolean force_grads) {
        var mh$ = ggml_graph_dup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_dup", ctx, cgraph, force_grads);
            }
            return (MemorySegment)mh$.invokeExact(ctx, cgraph, force_grads);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_cpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_graph_cpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_graph_cpy(struct ggml_cgraph *src, struct ggml_cgraph *dst)
     * }
     */
    public static FunctionDescriptor ggml_graph_cpy$descriptor() {
        return ggml_graph_cpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_graph_cpy(struct ggml_cgraph *src, struct ggml_cgraph *dst)
     * }
     */
    public static MethodHandle ggml_graph_cpy$handle() {
        return ggml_graph_cpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_graph_cpy(struct ggml_cgraph *src, struct ggml_cgraph *dst)
     * }
     */
    public static MemorySegment ggml_graph_cpy$address() {
        return ggml_graph_cpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_graph_cpy(struct ggml_cgraph *src, struct ggml_cgraph *dst)
     * }
     */
    public static void ggml_graph_cpy(MemorySegment src, MemorySegment dst) {
        var mh$ = ggml_graph_cpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_cpy", src, dst);
            }
            mh$.invokeExact(src, dst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_graph_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_graph_reset(struct ggml_cgraph *cgraph)
     * }
     */
    public static FunctionDescriptor ggml_graph_reset$descriptor() {
        return ggml_graph_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_graph_reset(struct ggml_cgraph *cgraph)
     * }
     */
    public static MethodHandle ggml_graph_reset$handle() {
        return ggml_graph_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_graph_reset(struct ggml_cgraph *cgraph)
     * }
     */
    public static MemorySegment ggml_graph_reset$address() {
        return ggml_graph_reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_graph_reset(struct ggml_cgraph *cgraph)
     * }
     */
    public static void ggml_graph_reset(MemorySegment cgraph) {
        var mh$ = ggml_graph_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_reset", cgraph);
            }
            mh$.invokeExact(cgraph);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_graph_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_graph_clear(struct ggml_cgraph *cgraph)
     * }
     */
    public static FunctionDescriptor ggml_graph_clear$descriptor() {
        return ggml_graph_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_graph_clear(struct ggml_cgraph *cgraph)
     * }
     */
    public static MethodHandle ggml_graph_clear$handle() {
        return ggml_graph_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_graph_clear(struct ggml_cgraph *cgraph)
     * }
     */
    public static MemorySegment ggml_graph_clear$address() {
        return ggml_graph_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_graph_clear(struct ggml_cgraph *cgraph)
     * }
     */
    public static void ggml_graph_clear(MemorySegment cgraph) {
        var mh$ = ggml_graph_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_clear", cgraph);
            }
            mh$.invokeExact(cgraph);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_graph_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_graph_size(struct ggml_cgraph *cgraph)
     * }
     */
    public static FunctionDescriptor ggml_graph_size$descriptor() {
        return ggml_graph_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_graph_size(struct ggml_cgraph *cgraph)
     * }
     */
    public static MethodHandle ggml_graph_size$handle() {
        return ggml_graph_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_graph_size(struct ggml_cgraph *cgraph)
     * }
     */
    public static MemorySegment ggml_graph_size$address() {
        return ggml_graph_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_graph_size(struct ggml_cgraph *cgraph)
     * }
     */
    public static int ggml_graph_size(MemorySegment cgraph) {
        var mh$ = ggml_graph_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_size", cgraph);
            }
            return (int)mh$.invokeExact(cgraph);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_node {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_graph_node");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_node(struct ggml_cgraph *cgraph, int i)
     * }
     */
    public static FunctionDescriptor ggml_graph_node$descriptor() {
        return ggml_graph_node.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_node(struct ggml_cgraph *cgraph, int i)
     * }
     */
    public static MethodHandle ggml_graph_node$handle() {
        return ggml_graph_node.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_node(struct ggml_cgraph *cgraph, int i)
     * }
     */
    public static MemorySegment ggml_graph_node$address() {
        return ggml_graph_node.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_node(struct ggml_cgraph *cgraph, int i)
     * }
     */
    public static MemorySegment ggml_graph_node(MemorySegment cgraph, int i) {
        var mh$ = ggml_graph_node.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_node", cgraph, i);
            }
            return (MemorySegment)mh$.invokeExact(cgraph, i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_nodes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_graph_nodes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor **ggml_graph_nodes(struct ggml_cgraph *cgraph)
     * }
     */
    public static FunctionDescriptor ggml_graph_nodes$descriptor() {
        return ggml_graph_nodes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor **ggml_graph_nodes(struct ggml_cgraph *cgraph)
     * }
     */
    public static MethodHandle ggml_graph_nodes$handle() {
        return ggml_graph_nodes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor **ggml_graph_nodes(struct ggml_cgraph *cgraph)
     * }
     */
    public static MemorySegment ggml_graph_nodes$address() {
        return ggml_graph_nodes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor **ggml_graph_nodes(struct ggml_cgraph *cgraph)
     * }
     */
    public static MemorySegment ggml_graph_nodes(MemorySegment cgraph) {
        var mh$ = ggml_graph_nodes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_nodes", cgraph);
            }
            return (MemorySegment)mh$.invokeExact(cgraph);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_n_nodes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_graph_n_nodes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_graph_n_nodes(struct ggml_cgraph *cgraph)
     * }
     */
    public static FunctionDescriptor ggml_graph_n_nodes$descriptor() {
        return ggml_graph_n_nodes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_graph_n_nodes(struct ggml_cgraph *cgraph)
     * }
     */
    public static MethodHandle ggml_graph_n_nodes$handle() {
        return ggml_graph_n_nodes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_graph_n_nodes(struct ggml_cgraph *cgraph)
     * }
     */
    public static MemorySegment ggml_graph_n_nodes$address() {
        return ggml_graph_n_nodes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_graph_n_nodes(struct ggml_cgraph *cgraph)
     * }
     */
    public static int ggml_graph_n_nodes(MemorySegment cgraph) {
        var mh$ = ggml_graph_n_nodes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_n_nodes", cgraph);
            }
            return (int)mh$.invokeExact(cgraph);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_add_node {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_graph_add_node");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_graph_add_node(struct ggml_cgraph *cgraph, struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_graph_add_node$descriptor() {
        return ggml_graph_add_node.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_graph_add_node(struct ggml_cgraph *cgraph, struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_graph_add_node$handle() {
        return ggml_graph_add_node.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_graph_add_node(struct ggml_cgraph *cgraph, struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_graph_add_node$address() {
        return ggml_graph_add_node.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_graph_add_node(struct ggml_cgraph *cgraph, struct ggml_tensor *tensor)
     * }
     */
    public static void ggml_graph_add_node(MemorySegment cgraph, MemorySegment tensor) {
        var mh$ = ggml_graph_add_node.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_add_node", cgraph, tensor);
            }
            mh$.invokeExact(cgraph, tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_overhead {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_graph_overhead");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_graph_overhead()
     * }
     */
    public static FunctionDescriptor ggml_graph_overhead$descriptor() {
        return ggml_graph_overhead.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_graph_overhead()
     * }
     */
    public static MethodHandle ggml_graph_overhead$handle() {
        return ggml_graph_overhead.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_graph_overhead()
     * }
     */
    public static MemorySegment ggml_graph_overhead$address() {
        return ggml_graph_overhead.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_graph_overhead()
     * }
     */
    public static long ggml_graph_overhead() {
        var mh$ = ggml_graph_overhead.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_overhead");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_overhead_custom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_BOOL
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_graph_overhead_custom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_graph_overhead_custom(size_t size, bool grads)
     * }
     */
    public static FunctionDescriptor ggml_graph_overhead_custom$descriptor() {
        return ggml_graph_overhead_custom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_graph_overhead_custom(size_t size, bool grads)
     * }
     */
    public static MethodHandle ggml_graph_overhead_custom$handle() {
        return ggml_graph_overhead_custom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_graph_overhead_custom(size_t size, bool grads)
     * }
     */
    public static MemorySegment ggml_graph_overhead_custom$address() {
        return ggml_graph_overhead_custom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_graph_overhead_custom(size_t size, bool grads)
     * }
     */
    public static long ggml_graph_overhead_custom(long size, boolean grads) {
        var mh$ = ggml_graph_overhead_custom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_overhead_custom", size, grads);
            }
            return (long)mh$.invokeExact(size, grads);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_get_tensor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_graph_get_tensor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_get_tensor(const struct ggml_cgraph *cgraph, const char *name)
     * }
     */
    public static FunctionDescriptor ggml_graph_get_tensor$descriptor() {
        return ggml_graph_get_tensor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_get_tensor(const struct ggml_cgraph *cgraph, const char *name)
     * }
     */
    public static MethodHandle ggml_graph_get_tensor$handle() {
        return ggml_graph_get_tensor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_get_tensor(const struct ggml_cgraph *cgraph, const char *name)
     * }
     */
    public static MemorySegment ggml_graph_get_tensor$address() {
        return ggml_graph_get_tensor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_get_tensor(const struct ggml_cgraph *cgraph, const char *name)
     * }
     */
    public static MemorySegment ggml_graph_get_tensor(MemorySegment cgraph, MemorySegment name) {
        var mh$ = ggml_graph_get_tensor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_get_tensor", cgraph, name);
            }
            return (MemorySegment)mh$.invokeExact(cgraph, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_get_grad {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_graph_get_grad");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_get_grad(const struct ggml_cgraph *cgraph, const struct ggml_tensor *node)
     * }
     */
    public static FunctionDescriptor ggml_graph_get_grad$descriptor() {
        return ggml_graph_get_grad.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_get_grad(const struct ggml_cgraph *cgraph, const struct ggml_tensor *node)
     * }
     */
    public static MethodHandle ggml_graph_get_grad$handle() {
        return ggml_graph_get_grad.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_get_grad(const struct ggml_cgraph *cgraph, const struct ggml_tensor *node)
     * }
     */
    public static MemorySegment ggml_graph_get_grad$address() {
        return ggml_graph_get_grad.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_get_grad(const struct ggml_cgraph *cgraph, const struct ggml_tensor *node)
     * }
     */
    public static MemorySegment ggml_graph_get_grad(MemorySegment cgraph, MemorySegment node) {
        var mh$ = ggml_graph_get_grad.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_get_grad", cgraph, node);
            }
            return (MemorySegment)mh$.invokeExact(cgraph, node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_get_grad_acc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_graph_get_grad_acc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_get_grad_acc(const struct ggml_cgraph *cgraph, const struct ggml_tensor *node)
     * }
     */
    public static FunctionDescriptor ggml_graph_get_grad_acc$descriptor() {
        return ggml_graph_get_grad_acc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_get_grad_acc(const struct ggml_cgraph *cgraph, const struct ggml_tensor *node)
     * }
     */
    public static MethodHandle ggml_graph_get_grad_acc$handle() {
        return ggml_graph_get_grad_acc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_get_grad_acc(const struct ggml_cgraph *cgraph, const struct ggml_tensor *node)
     * }
     */
    public static MemorySegment ggml_graph_get_grad_acc$address() {
        return ggml_graph_get_grad_acc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_get_grad_acc(const struct ggml_cgraph *cgraph, const struct ggml_tensor *node)
     * }
     */
    public static MemorySegment ggml_graph_get_grad_acc(MemorySegment cgraph, MemorySegment node) {
        var mh$ = ggml_graph_get_grad_acc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_get_grad_acc", cgraph, node);
            }
            return (MemorySegment)mh$.invokeExact(cgraph, node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_graph_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_graph_print(const struct ggml_cgraph *cgraph)
     * }
     */
    public static FunctionDescriptor ggml_graph_print$descriptor() {
        return ggml_graph_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_graph_print(const struct ggml_cgraph *cgraph)
     * }
     */
    public static MethodHandle ggml_graph_print$handle() {
        return ggml_graph_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_graph_print(const struct ggml_cgraph *cgraph)
     * }
     */
    public static MemorySegment ggml_graph_print$address() {
        return ggml_graph_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_graph_print(const struct ggml_cgraph *cgraph)
     * }
     */
    public static void ggml_graph_print(MemorySegment cgraph) {
        var mh$ = ggml_graph_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_print", cgraph);
            }
            mh$.invokeExact(cgraph);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_dump_dot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_graph_dump_dot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_graph_dump_dot(const struct ggml_cgraph *gb, const struct ggml_cgraph *gf, const char *filename)
     * }
     */
    public static FunctionDescriptor ggml_graph_dump_dot$descriptor() {
        return ggml_graph_dump_dot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_graph_dump_dot(const struct ggml_cgraph *gb, const struct ggml_cgraph *gf, const char *filename)
     * }
     */
    public static MethodHandle ggml_graph_dump_dot$handle() {
        return ggml_graph_dump_dot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_graph_dump_dot(const struct ggml_cgraph *gb, const struct ggml_cgraph *gf, const char *filename)
     * }
     */
    public static MemorySegment ggml_graph_dump_dot$address() {
        return ggml_graph_dump_dot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_graph_dump_dot(const struct ggml_cgraph *gb, const struct ggml_cgraph *gf, const char *filename)
     * }
     */
    public static void ggml_graph_dump_dot(MemorySegment gb, MemorySegment gf, MemorySegment filename) {
        var mh$ = ggml_graph_dump_dot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_dump_dot", gb, gf, filename);
            }
            mh$.invokeExact(gb, gf, filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_log_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_log_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_log_set(ggml_log_callback log_callback, void *user_data)
     * }
     */
    public static FunctionDescriptor ggml_log_set$descriptor() {
        return ggml_log_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_log_set(ggml_log_callback log_callback, void *user_data)
     * }
     */
    public static MethodHandle ggml_log_set$handle() {
        return ggml_log_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_log_set(ggml_log_callback log_callback, void *user_data)
     * }
     */
    public static MemorySegment ggml_log_set$address() {
        return ggml_log_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_log_set(ggml_log_callback log_callback, void *user_data)
     * }
     */
    public static void ggml_log_set(MemorySegment log_callback, MemorySegment user_data) {
        var mh$ = ggml_log_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_log_set", log_callback, user_data);
            }
            mh$.invokeExact(log_callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_zero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set_zero");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_zero(struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_set_zero$descriptor() {
        return ggml_set_zero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_zero(struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_set_zero$handle() {
        return ggml_set_zero.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_zero(struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_set_zero$address() {
        return ggml_set_zero.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_zero(struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_set_zero(MemorySegment tensor) {
        var mh$ = ggml_set_zero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_zero", tensor);
            }
            return (MemorySegment)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_quantize_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_quantize_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_quantize_init(enum ggml_type type)
     * }
     */
    public static FunctionDescriptor ggml_quantize_init$descriptor() {
        return ggml_quantize_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_quantize_init(enum ggml_type type)
     * }
     */
    public static MethodHandle ggml_quantize_init$handle() {
        return ggml_quantize_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_quantize_init(enum ggml_type type)
     * }
     */
    public static MemorySegment ggml_quantize_init$address() {
        return ggml_quantize_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_quantize_init(enum ggml_type type)
     * }
     */
    public static void ggml_quantize_init(int type) {
        var mh$ = ggml_quantize_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_quantize_init", type);
            }
            mh$.invokeExact(type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_quantize_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_quantize_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_quantize_free()
     * }
     */
    public static FunctionDescriptor ggml_quantize_free$descriptor() {
        return ggml_quantize_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_quantize_free()
     * }
     */
    public static MethodHandle ggml_quantize_free$handle() {
        return ggml_quantize_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_quantize_free()
     * }
     */
    public static MemorySegment ggml_quantize_free$address() {
        return ggml_quantize_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_quantize_free()
     * }
     */
    public static void ggml_quantize_free() {
        var mh$ = ggml_quantize_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_quantize_free");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_quantize_requires_imatrix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_quantize_requires_imatrix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_quantize_requires_imatrix(enum ggml_type type)
     * }
     */
    public static FunctionDescriptor ggml_quantize_requires_imatrix$descriptor() {
        return ggml_quantize_requires_imatrix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_quantize_requires_imatrix(enum ggml_type type)
     * }
     */
    public static MethodHandle ggml_quantize_requires_imatrix$handle() {
        return ggml_quantize_requires_imatrix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_quantize_requires_imatrix(enum ggml_type type)
     * }
     */
    public static MemorySegment ggml_quantize_requires_imatrix$address() {
        return ggml_quantize_requires_imatrix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_quantize_requires_imatrix(enum ggml_type type)
     * }
     */
    public static boolean ggml_quantize_requires_imatrix(int type) {
        var mh$ = ggml_quantize_requires_imatrix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_quantize_requires_imatrix", type);
            }
            return (boolean)mh$.invokeExact(type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_quantize_chunk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_quantize_chunk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_quantize_chunk(enum ggml_type type, const float *src, void *dst, int64_t start, int64_t nrows, int64_t n_per_row, const float *imatrix)
     * }
     */
    public static FunctionDescriptor ggml_quantize_chunk$descriptor() {
        return ggml_quantize_chunk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_quantize_chunk(enum ggml_type type, const float *src, void *dst, int64_t start, int64_t nrows, int64_t n_per_row, const float *imatrix)
     * }
     */
    public static MethodHandle ggml_quantize_chunk$handle() {
        return ggml_quantize_chunk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_quantize_chunk(enum ggml_type type, const float *src, void *dst, int64_t start, int64_t nrows, int64_t n_per_row, const float *imatrix)
     * }
     */
    public static MemorySegment ggml_quantize_chunk$address() {
        return ggml_quantize_chunk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_quantize_chunk(enum ggml_type type, const float *src, void *dst, int64_t start, int64_t nrows, int64_t n_per_row, const float *imatrix)
     * }
     */
    public static long ggml_quantize_chunk(int type, MemorySegment src, MemorySegment dst, long start, long nrows, long n_per_row, MemorySegment imatrix) {
        var mh$ = ggml_quantize_chunk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_quantize_chunk", type, src, dst, start, nrows, n_per_row, imatrix);
            }
            return (long)mh$.invokeExact(type, src, dst, start, nrows, n_per_row, imatrix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_type_traits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_type_traits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const struct ggml_type_traits *ggml_get_type_traits(enum ggml_type type)
     * }
     */
    public static FunctionDescriptor ggml_get_type_traits$descriptor() {
        return ggml_get_type_traits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const struct ggml_type_traits *ggml_get_type_traits(enum ggml_type type)
     * }
     */
    public static MethodHandle ggml_get_type_traits$handle() {
        return ggml_get_type_traits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const struct ggml_type_traits *ggml_get_type_traits(enum ggml_type type)
     * }
     */
    public static MemorySegment ggml_get_type_traits$address() {
        return ggml_get_type_traits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const struct ggml_type_traits *ggml_get_type_traits(enum ggml_type type)
     * }
     */
    public static MemorySegment ggml_get_type_traits(int type) {
        var mh$ = ggml_get_type_traits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_type_traits", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GGML_SCHED_PRIO_LOW = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum ggml_sched_priority.GGML_SCHED_PRIO_LOW = -1
     * }
     */
    public static int GGML_SCHED_PRIO_LOW() {
        return GGML_SCHED_PRIO_LOW;
    }
    private static final int GGML_SCHED_PRIO_NORMAL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ggml_sched_priority.GGML_SCHED_PRIO_NORMAL = 0
     * }
     */
    public static int GGML_SCHED_PRIO_NORMAL() {
        return GGML_SCHED_PRIO_NORMAL;
    }
    private static final int GGML_SCHED_PRIO_MEDIUM = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ggml_sched_priority.GGML_SCHED_PRIO_MEDIUM = 1
     * }
     */
    public static int GGML_SCHED_PRIO_MEDIUM() {
        return GGML_SCHED_PRIO_MEDIUM;
    }
    private static final int GGML_SCHED_PRIO_HIGH = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ggml_sched_priority.GGML_SCHED_PRIO_HIGH = 2
     * }
     */
    public static int GGML_SCHED_PRIO_HIGH() {
        return GGML_SCHED_PRIO_HIGH;
    }
    private static final int GGML_SCHED_PRIO_REALTIME = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ggml_sched_priority.GGML_SCHED_PRIO_REALTIME = 3
     * }
     */
    public static int GGML_SCHED_PRIO_REALTIME() {
        return GGML_SCHED_PRIO_REALTIME;
    }
    /**
     * {@snippet lang=c :
     * typedef struct ggml_threadpool *ggml_threadpool_t
     * }
     */
    public static final AddressLayout ggml_threadpool_t = WhisperCpp.C_POINTER;

    private static class ggml_threadpool_params_default {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ggml_threadpool_params.layout(),
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_threadpool_params_default");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_threadpool_params ggml_threadpool_params_default(int n_threads)
     * }
     */
    public static FunctionDescriptor ggml_threadpool_params_default$descriptor() {
        return ggml_threadpool_params_default.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_threadpool_params ggml_threadpool_params_default(int n_threads)
     * }
     */
    public static MethodHandle ggml_threadpool_params_default$handle() {
        return ggml_threadpool_params_default.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_threadpool_params ggml_threadpool_params_default(int n_threads)
     * }
     */
    public static MemorySegment ggml_threadpool_params_default$address() {
        return ggml_threadpool_params_default.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_threadpool_params ggml_threadpool_params_default(int n_threads)
     * }
     */
    public static MemorySegment ggml_threadpool_params_default(SegmentAllocator allocator, int n_threads) {
        var mh$ = ggml_threadpool_params_default.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_threadpool_params_default", allocator, n_threads);
            }
            return (MemorySegment)mh$.invokeExact(allocator, n_threads);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_threadpool_params_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_threadpool_params_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_threadpool_params_init(struct ggml_threadpool_params *p, int n_threads)
     * }
     */
    public static FunctionDescriptor ggml_threadpool_params_init$descriptor() {
        return ggml_threadpool_params_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_threadpool_params_init(struct ggml_threadpool_params *p, int n_threads)
     * }
     */
    public static MethodHandle ggml_threadpool_params_init$handle() {
        return ggml_threadpool_params_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_threadpool_params_init(struct ggml_threadpool_params *p, int n_threads)
     * }
     */
    public static MemorySegment ggml_threadpool_params_init$address() {
        return ggml_threadpool_params_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_threadpool_params_init(struct ggml_threadpool_params *p, int n_threads)
     * }
     */
    public static void ggml_threadpool_params_init(MemorySegment p, int n_threads) {
        var mh$ = ggml_threadpool_params_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_threadpool_params_init", p, n_threads);
            }
            mh$.invokeExact(p, n_threads);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_threadpool_params_match {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_threadpool_params_match");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_threadpool_params_match(const struct ggml_threadpool_params *p0, const struct ggml_threadpool_params *p1)
     * }
     */
    public static FunctionDescriptor ggml_threadpool_params_match$descriptor() {
        return ggml_threadpool_params_match.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_threadpool_params_match(const struct ggml_threadpool_params *p0, const struct ggml_threadpool_params *p1)
     * }
     */
    public static MethodHandle ggml_threadpool_params_match$handle() {
        return ggml_threadpool_params_match.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_threadpool_params_match(const struct ggml_threadpool_params *p0, const struct ggml_threadpool_params *p1)
     * }
     */
    public static MemorySegment ggml_threadpool_params_match$address() {
        return ggml_threadpool_params_match.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_threadpool_params_match(const struct ggml_threadpool_params *p0, const struct ggml_threadpool_params *p1)
     * }
     */
    public static boolean ggml_threadpool_params_match(MemorySegment p0, MemorySegment p1) {
        var mh$ = ggml_threadpool_params_match.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_threadpool_params_match", p0, p1);
            }
            return (boolean)mh$.invokeExact(p0, p1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct ggml_backend_buffer_type *ggml_backend_buffer_type_t
     * }
     */
    public static final AddressLayout ggml_backend_buffer_type_t = WhisperCpp.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct ggml_backend_buffer *ggml_backend_buffer_t
     * }
     */
    public static final AddressLayout ggml_backend_buffer_t = WhisperCpp.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct ggml_backend *ggml_backend_t
     * }
     */
    public static final AddressLayout ggml_backend_t = WhisperCpp.C_POINTER;

    private static class ggml_tallocr_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ggml_tallocr.layout(),
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_tallocr_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tallocr ggml_tallocr_new(ggml_backend_buffer_t buffer)
     * }
     */
    public static FunctionDescriptor ggml_tallocr_new$descriptor() {
        return ggml_tallocr_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tallocr ggml_tallocr_new(ggml_backend_buffer_t buffer)
     * }
     */
    public static MethodHandle ggml_tallocr_new$handle() {
        return ggml_tallocr_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tallocr ggml_tallocr_new(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_tallocr_new$address() {
        return ggml_tallocr_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tallocr ggml_tallocr_new(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_tallocr_new(SegmentAllocator allocator, MemorySegment buffer) {
        var mh$ = ggml_tallocr_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_tallocr_new", allocator, buffer);
            }
            return (MemorySegment)mh$.invokeExact(allocator, buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_tallocr_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_tallocr_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_tallocr_alloc(struct ggml_tallocr *talloc, struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_tallocr_alloc$descriptor() {
        return ggml_tallocr_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_tallocr_alloc(struct ggml_tallocr *talloc, struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_tallocr_alloc$handle() {
        return ggml_tallocr_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_tallocr_alloc(struct ggml_tallocr *talloc, struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_tallocr_alloc$address() {
        return ggml_tallocr_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_status ggml_tallocr_alloc(struct ggml_tallocr *talloc, struct ggml_tensor *tensor)
     * }
     */
    public static int ggml_tallocr_alloc(MemorySegment talloc, MemorySegment tensor) {
        var mh$ = ggml_tallocr_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_tallocr_alloc", talloc, tensor);
            }
            return (int)mh$.invokeExact(talloc, tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct ggml_gallocr *ggml_gallocr_t
     * }
     */
    public static final AddressLayout ggml_gallocr_t = WhisperCpp.C_POINTER;

    private static class ggml_gallocr_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_gallocr_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_gallocr_t ggml_gallocr_new(ggml_backend_buffer_type_t buft)
     * }
     */
    public static FunctionDescriptor ggml_gallocr_new$descriptor() {
        return ggml_gallocr_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_gallocr_t ggml_gallocr_new(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MethodHandle ggml_gallocr_new$handle() {
        return ggml_gallocr_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_gallocr_t ggml_gallocr_new(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MemorySegment ggml_gallocr_new$address() {
        return ggml_gallocr_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_gallocr_t ggml_gallocr_new(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MemorySegment ggml_gallocr_new(MemorySegment buft) {
        var mh$ = ggml_gallocr_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_gallocr_new", buft);
            }
            return (MemorySegment)mh$.invokeExact(buft);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_gallocr_new_n {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_gallocr_new_n");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_gallocr_t ggml_gallocr_new_n(ggml_backend_buffer_type_t *bufts, int n_bufs)
     * }
     */
    public static FunctionDescriptor ggml_gallocr_new_n$descriptor() {
        return ggml_gallocr_new_n.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_gallocr_t ggml_gallocr_new_n(ggml_backend_buffer_type_t *bufts, int n_bufs)
     * }
     */
    public static MethodHandle ggml_gallocr_new_n$handle() {
        return ggml_gallocr_new_n.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_gallocr_t ggml_gallocr_new_n(ggml_backend_buffer_type_t *bufts, int n_bufs)
     * }
     */
    public static MemorySegment ggml_gallocr_new_n$address() {
        return ggml_gallocr_new_n.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_gallocr_t ggml_gallocr_new_n(ggml_backend_buffer_type_t *bufts, int n_bufs)
     * }
     */
    public static MemorySegment ggml_gallocr_new_n(MemorySegment bufts, int n_bufs) {
        var mh$ = ggml_gallocr_new_n.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_gallocr_new_n", bufts, n_bufs);
            }
            return (MemorySegment)mh$.invokeExact(bufts, n_bufs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_gallocr_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_gallocr_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_gallocr_free(ggml_gallocr_t galloc)
     * }
     */
    public static FunctionDescriptor ggml_gallocr_free$descriptor() {
        return ggml_gallocr_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_gallocr_free(ggml_gallocr_t galloc)
     * }
     */
    public static MethodHandle ggml_gallocr_free$handle() {
        return ggml_gallocr_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_gallocr_free(ggml_gallocr_t galloc)
     * }
     */
    public static MemorySegment ggml_gallocr_free$address() {
        return ggml_gallocr_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_gallocr_free(ggml_gallocr_t galloc)
     * }
     */
    public static void ggml_gallocr_free(MemorySegment galloc) {
        var mh$ = ggml_gallocr_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_gallocr_free", galloc);
            }
            mh$.invokeExact(galloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_gallocr_reserve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_gallocr_reserve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_gallocr_reserve(ggml_gallocr_t galloc, struct ggml_cgraph *graph)
     * }
     */
    public static FunctionDescriptor ggml_gallocr_reserve$descriptor() {
        return ggml_gallocr_reserve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_gallocr_reserve(ggml_gallocr_t galloc, struct ggml_cgraph *graph)
     * }
     */
    public static MethodHandle ggml_gallocr_reserve$handle() {
        return ggml_gallocr_reserve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_gallocr_reserve(ggml_gallocr_t galloc, struct ggml_cgraph *graph)
     * }
     */
    public static MemorySegment ggml_gallocr_reserve$address() {
        return ggml_gallocr_reserve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_gallocr_reserve(ggml_gallocr_t galloc, struct ggml_cgraph *graph)
     * }
     */
    public static boolean ggml_gallocr_reserve(MemorySegment galloc, MemorySegment graph) {
        var mh$ = ggml_gallocr_reserve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_gallocr_reserve", galloc, graph);
            }
            return (boolean)mh$.invokeExact(galloc, graph);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_gallocr_reserve_n {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_gallocr_reserve_n");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_gallocr_reserve_n(ggml_gallocr_t galloc, struct ggml_cgraph *graph, const int *node_buffer_ids, const int *leaf_buffer_ids)
     * }
     */
    public static FunctionDescriptor ggml_gallocr_reserve_n$descriptor() {
        return ggml_gallocr_reserve_n.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_gallocr_reserve_n(ggml_gallocr_t galloc, struct ggml_cgraph *graph, const int *node_buffer_ids, const int *leaf_buffer_ids)
     * }
     */
    public static MethodHandle ggml_gallocr_reserve_n$handle() {
        return ggml_gallocr_reserve_n.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_gallocr_reserve_n(ggml_gallocr_t galloc, struct ggml_cgraph *graph, const int *node_buffer_ids, const int *leaf_buffer_ids)
     * }
     */
    public static MemorySegment ggml_gallocr_reserve_n$address() {
        return ggml_gallocr_reserve_n.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_gallocr_reserve_n(ggml_gallocr_t galloc, struct ggml_cgraph *graph, const int *node_buffer_ids, const int *leaf_buffer_ids)
     * }
     */
    public static boolean ggml_gallocr_reserve_n(MemorySegment galloc, MemorySegment graph, MemorySegment node_buffer_ids, MemorySegment leaf_buffer_ids) {
        var mh$ = ggml_gallocr_reserve_n.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_gallocr_reserve_n", galloc, graph, node_buffer_ids, leaf_buffer_ids);
            }
            return (boolean)mh$.invokeExact(galloc, graph, node_buffer_ids, leaf_buffer_ids);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_gallocr_alloc_graph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_gallocr_alloc_graph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_gallocr_alloc_graph(ggml_gallocr_t galloc, struct ggml_cgraph *graph)
     * }
     */
    public static FunctionDescriptor ggml_gallocr_alloc_graph$descriptor() {
        return ggml_gallocr_alloc_graph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_gallocr_alloc_graph(ggml_gallocr_t galloc, struct ggml_cgraph *graph)
     * }
     */
    public static MethodHandle ggml_gallocr_alloc_graph$handle() {
        return ggml_gallocr_alloc_graph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_gallocr_alloc_graph(ggml_gallocr_t galloc, struct ggml_cgraph *graph)
     * }
     */
    public static MemorySegment ggml_gallocr_alloc_graph$address() {
        return ggml_gallocr_alloc_graph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_gallocr_alloc_graph(ggml_gallocr_t galloc, struct ggml_cgraph *graph)
     * }
     */
    public static boolean ggml_gallocr_alloc_graph(MemorySegment galloc, MemorySegment graph) {
        var mh$ = ggml_gallocr_alloc_graph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_gallocr_alloc_graph", galloc, graph);
            }
            return (boolean)mh$.invokeExact(galloc, graph);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_gallocr_get_buffer_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_gallocr_get_buffer_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_gallocr_get_buffer_size(ggml_gallocr_t galloc, int buffer_id)
     * }
     */
    public static FunctionDescriptor ggml_gallocr_get_buffer_size$descriptor() {
        return ggml_gallocr_get_buffer_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_gallocr_get_buffer_size(ggml_gallocr_t galloc, int buffer_id)
     * }
     */
    public static MethodHandle ggml_gallocr_get_buffer_size$handle() {
        return ggml_gallocr_get_buffer_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_gallocr_get_buffer_size(ggml_gallocr_t galloc, int buffer_id)
     * }
     */
    public static MemorySegment ggml_gallocr_get_buffer_size$address() {
        return ggml_gallocr_get_buffer_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_gallocr_get_buffer_size(ggml_gallocr_t galloc, int buffer_id)
     * }
     */
    public static long ggml_gallocr_get_buffer_size(MemorySegment galloc, int buffer_id) {
        var mh$ = ggml_gallocr_get_buffer_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_gallocr_get_buffer_size", galloc, buffer_id);
            }
            return (long)mh$.invokeExact(galloc, buffer_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_alloc_ctx_tensors_from_buft {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_alloc_ctx_tensors_from_buft");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_backend_buffer *ggml_backend_alloc_ctx_tensors_from_buft(struct ggml_context *ctx, ggml_backend_buffer_type_t buft)
     * }
     */
    public static FunctionDescriptor ggml_backend_alloc_ctx_tensors_from_buft$descriptor() {
        return ggml_backend_alloc_ctx_tensors_from_buft.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_backend_buffer *ggml_backend_alloc_ctx_tensors_from_buft(struct ggml_context *ctx, ggml_backend_buffer_type_t buft)
     * }
     */
    public static MethodHandle ggml_backend_alloc_ctx_tensors_from_buft$handle() {
        return ggml_backend_alloc_ctx_tensors_from_buft.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_backend_buffer *ggml_backend_alloc_ctx_tensors_from_buft(struct ggml_context *ctx, ggml_backend_buffer_type_t buft)
     * }
     */
    public static MemorySegment ggml_backend_alloc_ctx_tensors_from_buft$address() {
        return ggml_backend_alloc_ctx_tensors_from_buft.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_backend_buffer *ggml_backend_alloc_ctx_tensors_from_buft(struct ggml_context *ctx, ggml_backend_buffer_type_t buft)
     * }
     */
    public static MemorySegment ggml_backend_alloc_ctx_tensors_from_buft(MemorySegment ctx, MemorySegment buft) {
        var mh$ = ggml_backend_alloc_ctx_tensors_from_buft.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_alloc_ctx_tensors_from_buft", ctx, buft);
            }
            return (MemorySegment)mh$.invokeExact(ctx, buft);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_alloc_ctx_tensors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_alloc_ctx_tensors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_backend_buffer *ggml_backend_alloc_ctx_tensors(struct ggml_context *ctx, ggml_backend_t backend)
     * }
     */
    public static FunctionDescriptor ggml_backend_alloc_ctx_tensors$descriptor() {
        return ggml_backend_alloc_ctx_tensors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_backend_buffer *ggml_backend_alloc_ctx_tensors(struct ggml_context *ctx, ggml_backend_t backend)
     * }
     */
    public static MethodHandle ggml_backend_alloc_ctx_tensors$handle() {
        return ggml_backend_alloc_ctx_tensors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_backend_buffer *ggml_backend_alloc_ctx_tensors(struct ggml_context *ctx, ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_alloc_ctx_tensors$address() {
        return ggml_backend_alloc_ctx_tensors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_backend_buffer *ggml_backend_alloc_ctx_tensors(struct ggml_context *ctx, ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_alloc_ctx_tensors(MemorySegment ctx, MemorySegment backend) {
        var mh$ = ggml_backend_alloc_ctx_tensors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_alloc_ctx_tensors", ctx, backend);
            }
            return (MemorySegment)mh$.invokeExact(ctx, backend);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct ggml_backend_event *ggml_backend_event_t
     * }
     */
    public static final AddressLayout ggml_backend_event_t = WhisperCpp.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef void *ggml_backend_graph_plan_t
     * }
     */
    public static final AddressLayout ggml_backend_graph_plan_t = WhisperCpp.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct ggml_backend_reg *ggml_backend_reg_t
     * }
     */
    public static final AddressLayout ggml_backend_reg_t = WhisperCpp.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct ggml_backend_device *ggml_backend_dev_t
     * }
     */
    public static final AddressLayout ggml_backend_dev_t = WhisperCpp.C_POINTER;

    private static class ggml_backend_buft_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buft_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_buft_name(ggml_backend_buffer_type_t buft)
     * }
     */
    public static FunctionDescriptor ggml_backend_buft_name$descriptor() {
        return ggml_backend_buft_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_buft_name(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MethodHandle ggml_backend_buft_name$handle() {
        return ggml_backend_buft_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_buft_name(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MemorySegment ggml_backend_buft_name$address() {
        return ggml_backend_buft_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ggml_backend_buft_name(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MemorySegment ggml_backend_buft_name(MemorySegment buft) {
        var mh$ = ggml_backend_buft_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buft_name", buft);
            }
            return (MemorySegment)mh$.invokeExact(buft);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buft_alloc_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buft_alloc_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_buft_alloc_buffer(ggml_backend_buffer_type_t buft, size_t size)
     * }
     */
    public static FunctionDescriptor ggml_backend_buft_alloc_buffer$descriptor() {
        return ggml_backend_buft_alloc_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_buft_alloc_buffer(ggml_backend_buffer_type_t buft, size_t size)
     * }
     */
    public static MethodHandle ggml_backend_buft_alloc_buffer$handle() {
        return ggml_backend_buft_alloc_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_buft_alloc_buffer(ggml_backend_buffer_type_t buft, size_t size)
     * }
     */
    public static MemorySegment ggml_backend_buft_alloc_buffer$address() {
        return ggml_backend_buft_alloc_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_buft_alloc_buffer(ggml_backend_buffer_type_t buft, size_t size)
     * }
     */
    public static MemorySegment ggml_backend_buft_alloc_buffer(MemorySegment buft, long size) {
        var mh$ = ggml_backend_buft_alloc_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buft_alloc_buffer", buft, size);
            }
            return (MemorySegment)mh$.invokeExact(buft, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buft_get_alignment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buft_get_alignment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buft_get_alignment(ggml_backend_buffer_type_t buft)
     * }
     */
    public static FunctionDescriptor ggml_backend_buft_get_alignment$descriptor() {
        return ggml_backend_buft_get_alignment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buft_get_alignment(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MethodHandle ggml_backend_buft_get_alignment$handle() {
        return ggml_backend_buft_get_alignment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buft_get_alignment(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MemorySegment ggml_backend_buft_get_alignment$address() {
        return ggml_backend_buft_get_alignment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_backend_buft_get_alignment(ggml_backend_buffer_type_t buft)
     * }
     */
    public static long ggml_backend_buft_get_alignment(MemorySegment buft) {
        var mh$ = ggml_backend_buft_get_alignment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buft_get_alignment", buft);
            }
            return (long)mh$.invokeExact(buft);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buft_get_max_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buft_get_max_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buft_get_max_size(ggml_backend_buffer_type_t buft)
     * }
     */
    public static FunctionDescriptor ggml_backend_buft_get_max_size$descriptor() {
        return ggml_backend_buft_get_max_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buft_get_max_size(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MethodHandle ggml_backend_buft_get_max_size$handle() {
        return ggml_backend_buft_get_max_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buft_get_max_size(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MemorySegment ggml_backend_buft_get_max_size$address() {
        return ggml_backend_buft_get_max_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_backend_buft_get_max_size(ggml_backend_buffer_type_t buft)
     * }
     */
    public static long ggml_backend_buft_get_max_size(MemorySegment buft) {
        var mh$ = ggml_backend_buft_get_max_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buft_get_max_size", buft);
            }
            return (long)mh$.invokeExact(buft);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buft_get_alloc_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buft_get_alloc_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buft_get_alloc_size(ggml_backend_buffer_type_t buft, const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_backend_buft_get_alloc_size$descriptor() {
        return ggml_backend_buft_get_alloc_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buft_get_alloc_size(ggml_backend_buffer_type_t buft, const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_backend_buft_get_alloc_size$handle() {
        return ggml_backend_buft_get_alloc_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buft_get_alloc_size(ggml_backend_buffer_type_t buft, const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_backend_buft_get_alloc_size$address() {
        return ggml_backend_buft_get_alloc_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_backend_buft_get_alloc_size(ggml_backend_buffer_type_t buft, const struct ggml_tensor *tensor)
     * }
     */
    public static long ggml_backend_buft_get_alloc_size(MemorySegment buft, MemorySegment tensor) {
        var mh$ = ggml_backend_buft_get_alloc_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buft_get_alloc_size", buft, tensor);
            }
            return (long)mh$.invokeExact(buft, tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buft_is_host {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buft_is_host");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_backend_buft_is_host(ggml_backend_buffer_type_t buft)
     * }
     */
    public static FunctionDescriptor ggml_backend_buft_is_host$descriptor() {
        return ggml_backend_buft_is_host.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_backend_buft_is_host(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MethodHandle ggml_backend_buft_is_host$handle() {
        return ggml_backend_buft_is_host.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_backend_buft_is_host(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MemorySegment ggml_backend_buft_is_host$address() {
        return ggml_backend_buft_is_host.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_backend_buft_is_host(ggml_backend_buffer_type_t buft)
     * }
     */
    public static boolean ggml_backend_buft_is_host(MemorySegment buft) {
        var mh$ = ggml_backend_buft_is_host.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buft_is_host", buft);
            }
            return (boolean)mh$.invokeExact(buft);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buft_get_device {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buft_get_device");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_buft_get_device(ggml_backend_buffer_type_t buft)
     * }
     */
    public static FunctionDescriptor ggml_backend_buft_get_device$descriptor() {
        return ggml_backend_buft_get_device.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_buft_get_device(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MethodHandle ggml_backend_buft_get_device$handle() {
        return ggml_backend_buft_get_device.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_buft_get_device(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MemorySegment ggml_backend_buft_get_device$address() {
        return ggml_backend_buft_get_device.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_buft_get_device(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MemorySegment ggml_backend_buft_get_device(MemorySegment buft) {
        var mh$ = ggml_backend_buft_get_device.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buft_get_device", buft);
            }
            return (MemorySegment)mh$.invokeExact(buft);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GGML_BACKEND_BUFFER_USAGE_ANY = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ggml_backend_buffer_usage.GGML_BACKEND_BUFFER_USAGE_ANY = 0
     * }
     */
    public static int GGML_BACKEND_BUFFER_USAGE_ANY() {
        return GGML_BACKEND_BUFFER_USAGE_ANY;
    }
    private static final int GGML_BACKEND_BUFFER_USAGE_WEIGHTS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ggml_backend_buffer_usage.GGML_BACKEND_BUFFER_USAGE_WEIGHTS = 1
     * }
     */
    public static int GGML_BACKEND_BUFFER_USAGE_WEIGHTS() {
        return GGML_BACKEND_BUFFER_USAGE_WEIGHTS;
    }
    private static final int GGML_BACKEND_BUFFER_USAGE_COMPUTE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ggml_backend_buffer_usage.GGML_BACKEND_BUFFER_USAGE_COMPUTE = 2
     * }
     */
    public static int GGML_BACKEND_BUFFER_USAGE_COMPUTE() {
        return GGML_BACKEND_BUFFER_USAGE_COMPUTE;
    }

    private static class ggml_backend_buffer_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buffer_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_buffer_name(ggml_backend_buffer_t buffer)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_name$descriptor() {
        return ggml_backend_buffer_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_buffer_name(ggml_backend_buffer_t buffer)
     * }
     */
    public static MethodHandle ggml_backend_buffer_name$handle() {
        return ggml_backend_buffer_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_buffer_name(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_backend_buffer_name$address() {
        return ggml_backend_buffer_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ggml_backend_buffer_name(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_backend_buffer_name(MemorySegment buffer) {
        var mh$ = ggml_backend_buffer_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_name", buffer);
            }
            return (MemorySegment)mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buffer_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buffer_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_free(ggml_backend_buffer_t buffer)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_free$descriptor() {
        return ggml_backend_buffer_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_free(ggml_backend_buffer_t buffer)
     * }
     */
    public static MethodHandle ggml_backend_buffer_free$handle() {
        return ggml_backend_buffer_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_free(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_backend_buffer_free$address() {
        return ggml_backend_buffer_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_free(ggml_backend_buffer_t buffer)
     * }
     */
    public static void ggml_backend_buffer_free(MemorySegment buffer) {
        var mh$ = ggml_backend_buffer_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_free", buffer);
            }
            mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buffer_get_base {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buffer_get_base");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *ggml_backend_buffer_get_base(ggml_backend_buffer_t buffer)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_get_base$descriptor() {
        return ggml_backend_buffer_get_base.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *ggml_backend_buffer_get_base(ggml_backend_buffer_t buffer)
     * }
     */
    public static MethodHandle ggml_backend_buffer_get_base$handle() {
        return ggml_backend_buffer_get_base.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *ggml_backend_buffer_get_base(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_backend_buffer_get_base$address() {
        return ggml_backend_buffer_get_base.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *ggml_backend_buffer_get_base(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_backend_buffer_get_base(MemorySegment buffer) {
        var mh$ = ggml_backend_buffer_get_base.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_get_base", buffer);
            }
            return (MemorySegment)mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buffer_get_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buffer_get_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_size(ggml_backend_buffer_t buffer)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_get_size$descriptor() {
        return ggml_backend_buffer_get_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_size(ggml_backend_buffer_t buffer)
     * }
     */
    public static MethodHandle ggml_backend_buffer_get_size$handle() {
        return ggml_backend_buffer_get_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_size(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_backend_buffer_get_size$address() {
        return ggml_backend_buffer_get_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_size(ggml_backend_buffer_t buffer)
     * }
     */
    public static long ggml_backend_buffer_get_size(MemorySegment buffer) {
        var mh$ = ggml_backend_buffer_get_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_get_size", buffer);
            }
            return (long)mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buffer_init_tensor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buffer_init_tensor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_buffer_init_tensor(ggml_backend_buffer_t buffer, struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_init_tensor$descriptor() {
        return ggml_backend_buffer_init_tensor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_buffer_init_tensor(ggml_backend_buffer_t buffer, struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_backend_buffer_init_tensor$handle() {
        return ggml_backend_buffer_init_tensor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_buffer_init_tensor(ggml_backend_buffer_t buffer, struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_backend_buffer_init_tensor$address() {
        return ggml_backend_buffer_init_tensor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_buffer_init_tensor(ggml_backend_buffer_t buffer, struct ggml_tensor *tensor)
     * }
     */
    public static int ggml_backend_buffer_init_tensor(MemorySegment buffer, MemorySegment tensor) {
        var mh$ = ggml_backend_buffer_init_tensor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_init_tensor", buffer, tensor);
            }
            return (int)mh$.invokeExact(buffer, tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buffer_get_alignment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buffer_get_alignment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_alignment(ggml_backend_buffer_t buffer)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_get_alignment$descriptor() {
        return ggml_backend_buffer_get_alignment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_alignment(ggml_backend_buffer_t buffer)
     * }
     */
    public static MethodHandle ggml_backend_buffer_get_alignment$handle() {
        return ggml_backend_buffer_get_alignment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_alignment(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_backend_buffer_get_alignment$address() {
        return ggml_backend_buffer_get_alignment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_alignment(ggml_backend_buffer_t buffer)
     * }
     */
    public static long ggml_backend_buffer_get_alignment(MemorySegment buffer) {
        var mh$ = ggml_backend_buffer_get_alignment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_get_alignment", buffer);
            }
            return (long)mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buffer_get_max_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buffer_get_max_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_max_size(ggml_backend_buffer_t buffer)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_get_max_size$descriptor() {
        return ggml_backend_buffer_get_max_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_max_size(ggml_backend_buffer_t buffer)
     * }
     */
    public static MethodHandle ggml_backend_buffer_get_max_size$handle() {
        return ggml_backend_buffer_get_max_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_max_size(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_backend_buffer_get_max_size$address() {
        return ggml_backend_buffer_get_max_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_max_size(ggml_backend_buffer_t buffer)
     * }
     */
    public static long ggml_backend_buffer_get_max_size(MemorySegment buffer) {
        var mh$ = ggml_backend_buffer_get_max_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_get_max_size", buffer);
            }
            return (long)mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buffer_get_alloc_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buffer_get_alloc_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_alloc_size(ggml_backend_buffer_t buffer, const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_get_alloc_size$descriptor() {
        return ggml_backend_buffer_get_alloc_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_alloc_size(ggml_backend_buffer_t buffer, const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_backend_buffer_get_alloc_size$handle() {
        return ggml_backend_buffer_get_alloc_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_alloc_size(ggml_backend_buffer_t buffer, const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_backend_buffer_get_alloc_size$address() {
        return ggml_backend_buffer_get_alloc_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_alloc_size(ggml_backend_buffer_t buffer, const struct ggml_tensor *tensor)
     * }
     */
    public static long ggml_backend_buffer_get_alloc_size(MemorySegment buffer, MemorySegment tensor) {
        var mh$ = ggml_backend_buffer_get_alloc_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_get_alloc_size", buffer, tensor);
            }
            return (long)mh$.invokeExact(buffer, tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buffer_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_CHAR
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buffer_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_clear(ggml_backend_buffer_t buffer, uint8_t value)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_clear$descriptor() {
        return ggml_backend_buffer_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_clear(ggml_backend_buffer_t buffer, uint8_t value)
     * }
     */
    public static MethodHandle ggml_backend_buffer_clear$handle() {
        return ggml_backend_buffer_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_clear(ggml_backend_buffer_t buffer, uint8_t value)
     * }
     */
    public static MemorySegment ggml_backend_buffer_clear$address() {
        return ggml_backend_buffer_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_clear(ggml_backend_buffer_t buffer, uint8_t value)
     * }
     */
    public static void ggml_backend_buffer_clear(MemorySegment buffer, byte value) {
        var mh$ = ggml_backend_buffer_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_clear", buffer, value);
            }
            mh$.invokeExact(buffer, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buffer_is_host {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buffer_is_host");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_backend_buffer_is_host(ggml_backend_buffer_t buffer)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_is_host$descriptor() {
        return ggml_backend_buffer_is_host.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_backend_buffer_is_host(ggml_backend_buffer_t buffer)
     * }
     */
    public static MethodHandle ggml_backend_buffer_is_host$handle() {
        return ggml_backend_buffer_is_host.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_backend_buffer_is_host(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_backend_buffer_is_host$address() {
        return ggml_backend_buffer_is_host.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_backend_buffer_is_host(ggml_backend_buffer_t buffer)
     * }
     */
    public static boolean ggml_backend_buffer_is_host(MemorySegment buffer) {
        var mh$ = ggml_backend_buffer_is_host.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_is_host", buffer);
            }
            return (boolean)mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buffer_set_usage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buffer_set_usage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_set_usage(ggml_backend_buffer_t buffer, enum ggml_backend_buffer_usage usage)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_set_usage$descriptor() {
        return ggml_backend_buffer_set_usage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_set_usage(ggml_backend_buffer_t buffer, enum ggml_backend_buffer_usage usage)
     * }
     */
    public static MethodHandle ggml_backend_buffer_set_usage$handle() {
        return ggml_backend_buffer_set_usage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_set_usage(ggml_backend_buffer_t buffer, enum ggml_backend_buffer_usage usage)
     * }
     */
    public static MemorySegment ggml_backend_buffer_set_usage$address() {
        return ggml_backend_buffer_set_usage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_set_usage(ggml_backend_buffer_t buffer, enum ggml_backend_buffer_usage usage)
     * }
     */
    public static void ggml_backend_buffer_set_usage(MemorySegment buffer, int usage) {
        var mh$ = ggml_backend_buffer_set_usage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_set_usage", buffer, usage);
            }
            mh$.invokeExact(buffer, usage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buffer_get_usage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buffer_get_usage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_backend_buffer_usage ggml_backend_buffer_get_usage(ggml_backend_buffer_t buffer)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_get_usage$descriptor() {
        return ggml_backend_buffer_get_usage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_backend_buffer_usage ggml_backend_buffer_get_usage(ggml_backend_buffer_t buffer)
     * }
     */
    public static MethodHandle ggml_backend_buffer_get_usage$handle() {
        return ggml_backend_buffer_get_usage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_backend_buffer_usage ggml_backend_buffer_get_usage(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_backend_buffer_get_usage$address() {
        return ggml_backend_buffer_get_usage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_backend_buffer_usage ggml_backend_buffer_get_usage(ggml_backend_buffer_t buffer)
     * }
     */
    public static int ggml_backend_buffer_get_usage(MemorySegment buffer) {
        var mh$ = ggml_backend_buffer_get_usage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_get_usage", buffer);
            }
            return (int)mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buffer_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buffer_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_buffer_get_type(ggml_backend_buffer_t buffer)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_get_type$descriptor() {
        return ggml_backend_buffer_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_buffer_get_type(ggml_backend_buffer_t buffer)
     * }
     */
    public static MethodHandle ggml_backend_buffer_get_type$handle() {
        return ggml_backend_buffer_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_buffer_get_type(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_backend_buffer_get_type$address() {
        return ggml_backend_buffer_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_buffer_get_type(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_backend_buffer_get_type(MemorySegment buffer) {
        var mh$ = ggml_backend_buffer_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_get_type", buffer);
            }
            return (MemorySegment)mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buffer_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_buffer_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_reset(ggml_backend_buffer_t buffer)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_reset$descriptor() {
        return ggml_backend_buffer_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_reset(ggml_backend_buffer_t buffer)
     * }
     */
    public static MethodHandle ggml_backend_buffer_reset$handle() {
        return ggml_backend_buffer_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_reset(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_backend_buffer_reset$address() {
        return ggml_backend_buffer_reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_reset(ggml_backend_buffer_t buffer)
     * }
     */
    public static void ggml_backend_buffer_reset(MemorySegment buffer) {
        var mh$ = ggml_backend_buffer_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_reset", buffer);
            }
            mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_tensor_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_tensor_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_copy(struct ggml_tensor *src, struct ggml_tensor *dst)
     * }
     */
    public static FunctionDescriptor ggml_backend_tensor_copy$descriptor() {
        return ggml_backend_tensor_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_copy(struct ggml_tensor *src, struct ggml_tensor *dst)
     * }
     */
    public static MethodHandle ggml_backend_tensor_copy$handle() {
        return ggml_backend_tensor_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_copy(struct ggml_tensor *src, struct ggml_tensor *dst)
     * }
     */
    public static MemorySegment ggml_backend_tensor_copy$address() {
        return ggml_backend_tensor_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_copy(struct ggml_tensor *src, struct ggml_tensor *dst)
     * }
     */
    public static void ggml_backend_tensor_copy(MemorySegment src, MemorySegment dst) {
        var mh$ = ggml_backend_tensor_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_tensor_copy", src, dst);
            }
            mh$.invokeExact(src, dst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_guid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_guid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_guid_t ggml_backend_guid(ggml_backend_t backend)
     * }
     */
    public static FunctionDescriptor ggml_backend_guid$descriptor() {
        return ggml_backend_guid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_guid_t ggml_backend_guid(ggml_backend_t backend)
     * }
     */
    public static MethodHandle ggml_backend_guid$handle() {
        return ggml_backend_guid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_guid_t ggml_backend_guid(ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_guid$address() {
        return ggml_backend_guid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_guid_t ggml_backend_guid(ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_guid(MemorySegment backend) {
        var mh$ = ggml_backend_guid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_guid", backend);
            }
            return (MemorySegment)mh$.invokeExact(backend);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_name(ggml_backend_t backend)
     * }
     */
    public static FunctionDescriptor ggml_backend_name$descriptor() {
        return ggml_backend_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_name(ggml_backend_t backend)
     * }
     */
    public static MethodHandle ggml_backend_name$handle() {
        return ggml_backend_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_name(ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_name$address() {
        return ggml_backend_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ggml_backend_name(ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_name(MemorySegment backend) {
        var mh$ = ggml_backend_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_name", backend);
            }
            return (MemorySegment)mh$.invokeExact(backend);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_free(ggml_backend_t backend)
     * }
     */
    public static FunctionDescriptor ggml_backend_free$descriptor() {
        return ggml_backend_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_free(ggml_backend_t backend)
     * }
     */
    public static MethodHandle ggml_backend_free$handle() {
        return ggml_backend_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_free(ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_free$address() {
        return ggml_backend_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_free(ggml_backend_t backend)
     * }
     */
    public static void ggml_backend_free(MemorySegment backend) {
        var mh$ = ggml_backend_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_free", backend);
            }
            mh$.invokeExact(backend);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_get_default_buffer_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_get_default_buffer_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_get_default_buffer_type(ggml_backend_t backend)
     * }
     */
    public static FunctionDescriptor ggml_backend_get_default_buffer_type$descriptor() {
        return ggml_backend_get_default_buffer_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_get_default_buffer_type(ggml_backend_t backend)
     * }
     */
    public static MethodHandle ggml_backend_get_default_buffer_type$handle() {
        return ggml_backend_get_default_buffer_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_get_default_buffer_type(ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_get_default_buffer_type$address() {
        return ggml_backend_get_default_buffer_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_get_default_buffer_type(ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_get_default_buffer_type(MemorySegment backend) {
        var mh$ = ggml_backend_get_default_buffer_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_get_default_buffer_type", backend);
            }
            return (MemorySegment)mh$.invokeExact(backend);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_alloc_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_alloc_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_alloc_buffer(ggml_backend_t backend, size_t size)
     * }
     */
    public static FunctionDescriptor ggml_backend_alloc_buffer$descriptor() {
        return ggml_backend_alloc_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_alloc_buffer(ggml_backend_t backend, size_t size)
     * }
     */
    public static MethodHandle ggml_backend_alloc_buffer$handle() {
        return ggml_backend_alloc_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_alloc_buffer(ggml_backend_t backend, size_t size)
     * }
     */
    public static MemorySegment ggml_backend_alloc_buffer$address() {
        return ggml_backend_alloc_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_alloc_buffer(ggml_backend_t backend, size_t size)
     * }
     */
    public static MemorySegment ggml_backend_alloc_buffer(MemorySegment backend, long size) {
        var mh$ = ggml_backend_alloc_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_alloc_buffer", backend, size);
            }
            return (MemorySegment)mh$.invokeExact(backend, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_get_alignment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_get_alignment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_get_alignment(ggml_backend_t backend)
     * }
     */
    public static FunctionDescriptor ggml_backend_get_alignment$descriptor() {
        return ggml_backend_get_alignment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_get_alignment(ggml_backend_t backend)
     * }
     */
    public static MethodHandle ggml_backend_get_alignment$handle() {
        return ggml_backend_get_alignment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_get_alignment(ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_get_alignment$address() {
        return ggml_backend_get_alignment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_backend_get_alignment(ggml_backend_t backend)
     * }
     */
    public static long ggml_backend_get_alignment(MemorySegment backend) {
        var mh$ = ggml_backend_get_alignment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_get_alignment", backend);
            }
            return (long)mh$.invokeExact(backend);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_get_max_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_get_max_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_get_max_size(ggml_backend_t backend)
     * }
     */
    public static FunctionDescriptor ggml_backend_get_max_size$descriptor() {
        return ggml_backend_get_max_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_get_max_size(ggml_backend_t backend)
     * }
     */
    public static MethodHandle ggml_backend_get_max_size$handle() {
        return ggml_backend_get_max_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_get_max_size(ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_get_max_size$address() {
        return ggml_backend_get_max_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_backend_get_max_size(ggml_backend_t backend)
     * }
     */
    public static long ggml_backend_get_max_size(MemorySegment backend) {
        var mh$ = ggml_backend_get_max_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_get_max_size", backend);
            }
            return (long)mh$.invokeExact(backend);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_tensor_set_async {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_tensor_set_async");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_set_async(ggml_backend_t backend, struct ggml_tensor *tensor, const void *data, size_t offset, size_t size)
     * }
     */
    public static FunctionDescriptor ggml_backend_tensor_set_async$descriptor() {
        return ggml_backend_tensor_set_async.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_set_async(ggml_backend_t backend, struct ggml_tensor *tensor, const void *data, size_t offset, size_t size)
     * }
     */
    public static MethodHandle ggml_backend_tensor_set_async$handle() {
        return ggml_backend_tensor_set_async.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_set_async(ggml_backend_t backend, struct ggml_tensor *tensor, const void *data, size_t offset, size_t size)
     * }
     */
    public static MemorySegment ggml_backend_tensor_set_async$address() {
        return ggml_backend_tensor_set_async.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_set_async(ggml_backend_t backend, struct ggml_tensor *tensor, const void *data, size_t offset, size_t size)
     * }
     */
    public static void ggml_backend_tensor_set_async(MemorySegment backend, MemorySegment tensor, MemorySegment data, long offset, long size) {
        var mh$ = ggml_backend_tensor_set_async.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_tensor_set_async", backend, tensor, data, offset, size);
            }
            mh$.invokeExact(backend, tensor, data, offset, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_tensor_get_async {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_tensor_get_async");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_get_async(ggml_backend_t backend, const struct ggml_tensor *tensor, void *data, size_t offset, size_t size)
     * }
     */
    public static FunctionDescriptor ggml_backend_tensor_get_async$descriptor() {
        return ggml_backend_tensor_get_async.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_get_async(ggml_backend_t backend, const struct ggml_tensor *tensor, void *data, size_t offset, size_t size)
     * }
     */
    public static MethodHandle ggml_backend_tensor_get_async$handle() {
        return ggml_backend_tensor_get_async.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_get_async(ggml_backend_t backend, const struct ggml_tensor *tensor, void *data, size_t offset, size_t size)
     * }
     */
    public static MemorySegment ggml_backend_tensor_get_async$address() {
        return ggml_backend_tensor_get_async.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_get_async(ggml_backend_t backend, const struct ggml_tensor *tensor, void *data, size_t offset, size_t size)
     * }
     */
    public static void ggml_backend_tensor_get_async(MemorySegment backend, MemorySegment tensor, MemorySegment data, long offset, long size) {
        var mh$ = ggml_backend_tensor_get_async.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_tensor_get_async", backend, tensor, data, offset, size);
            }
            mh$.invokeExact(backend, tensor, data, offset, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_tensor_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_tensor_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_set(struct ggml_tensor *tensor, const void *data, size_t offset, size_t size)
     * }
     */
    public static FunctionDescriptor ggml_backend_tensor_set$descriptor() {
        return ggml_backend_tensor_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_set(struct ggml_tensor *tensor, const void *data, size_t offset, size_t size)
     * }
     */
    public static MethodHandle ggml_backend_tensor_set$handle() {
        return ggml_backend_tensor_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_set(struct ggml_tensor *tensor, const void *data, size_t offset, size_t size)
     * }
     */
    public static MemorySegment ggml_backend_tensor_set$address() {
        return ggml_backend_tensor_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_set(struct ggml_tensor *tensor, const void *data, size_t offset, size_t size)
     * }
     */
    public static void ggml_backend_tensor_set(MemorySegment tensor, MemorySegment data, long offset, long size) {
        var mh$ = ggml_backend_tensor_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_tensor_set", tensor, data, offset, size);
            }
            mh$.invokeExact(tensor, data, offset, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_tensor_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_tensor_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_get(const struct ggml_tensor *tensor, void *data, size_t offset, size_t size)
     * }
     */
    public static FunctionDescriptor ggml_backend_tensor_get$descriptor() {
        return ggml_backend_tensor_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_get(const struct ggml_tensor *tensor, void *data, size_t offset, size_t size)
     * }
     */
    public static MethodHandle ggml_backend_tensor_get$handle() {
        return ggml_backend_tensor_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_get(const struct ggml_tensor *tensor, void *data, size_t offset, size_t size)
     * }
     */
    public static MemorySegment ggml_backend_tensor_get$address() {
        return ggml_backend_tensor_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_get(const struct ggml_tensor *tensor, void *data, size_t offset, size_t size)
     * }
     */
    public static void ggml_backend_tensor_get(MemorySegment tensor, MemorySegment data, long offset, long size) {
        var mh$ = ggml_backend_tensor_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_tensor_get", tensor, data, offset, size);
            }
            mh$.invokeExact(tensor, data, offset, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_tensor_memset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_CHAR,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_tensor_memset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_memset(struct ggml_tensor *tensor, uint8_t value, size_t offset, size_t size)
     * }
     */
    public static FunctionDescriptor ggml_backend_tensor_memset$descriptor() {
        return ggml_backend_tensor_memset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_memset(struct ggml_tensor *tensor, uint8_t value, size_t offset, size_t size)
     * }
     */
    public static MethodHandle ggml_backend_tensor_memset$handle() {
        return ggml_backend_tensor_memset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_memset(struct ggml_tensor *tensor, uint8_t value, size_t offset, size_t size)
     * }
     */
    public static MemorySegment ggml_backend_tensor_memset$address() {
        return ggml_backend_tensor_memset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_memset(struct ggml_tensor *tensor, uint8_t value, size_t offset, size_t size)
     * }
     */
    public static void ggml_backend_tensor_memset(MemorySegment tensor, byte value, long offset, long size) {
        var mh$ = ggml_backend_tensor_memset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_tensor_memset", tensor, value, offset, size);
            }
            mh$.invokeExact(tensor, value, offset, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_synchronize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_synchronize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_synchronize(ggml_backend_t backend)
     * }
     */
    public static FunctionDescriptor ggml_backend_synchronize$descriptor() {
        return ggml_backend_synchronize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_synchronize(ggml_backend_t backend)
     * }
     */
    public static MethodHandle ggml_backend_synchronize$handle() {
        return ggml_backend_synchronize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_synchronize(ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_synchronize$address() {
        return ggml_backend_synchronize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_synchronize(ggml_backend_t backend)
     * }
     */
    public static void ggml_backend_synchronize(MemorySegment backend) {
        var mh$ = ggml_backend_synchronize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_synchronize", backend);
            }
            mh$.invokeExact(backend);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_graph_plan_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_graph_plan_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_graph_plan_t ggml_backend_graph_plan_create(ggml_backend_t backend, struct ggml_cgraph *cgraph)
     * }
     */
    public static FunctionDescriptor ggml_backend_graph_plan_create$descriptor() {
        return ggml_backend_graph_plan_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_graph_plan_t ggml_backend_graph_plan_create(ggml_backend_t backend, struct ggml_cgraph *cgraph)
     * }
     */
    public static MethodHandle ggml_backend_graph_plan_create$handle() {
        return ggml_backend_graph_plan_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_graph_plan_t ggml_backend_graph_plan_create(ggml_backend_t backend, struct ggml_cgraph *cgraph)
     * }
     */
    public static MemorySegment ggml_backend_graph_plan_create$address() {
        return ggml_backend_graph_plan_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_graph_plan_t ggml_backend_graph_plan_create(ggml_backend_t backend, struct ggml_cgraph *cgraph)
     * }
     */
    public static MemorySegment ggml_backend_graph_plan_create(MemorySegment backend, MemorySegment cgraph) {
        var mh$ = ggml_backend_graph_plan_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_graph_plan_create", backend, cgraph);
            }
            return (MemorySegment)mh$.invokeExact(backend, cgraph);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_graph_plan_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_graph_plan_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_graph_plan_free(ggml_backend_t backend, ggml_backend_graph_plan_t plan)
     * }
     */
    public static FunctionDescriptor ggml_backend_graph_plan_free$descriptor() {
        return ggml_backend_graph_plan_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_graph_plan_free(ggml_backend_t backend, ggml_backend_graph_plan_t plan)
     * }
     */
    public static MethodHandle ggml_backend_graph_plan_free$handle() {
        return ggml_backend_graph_plan_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_graph_plan_free(ggml_backend_t backend, ggml_backend_graph_plan_t plan)
     * }
     */
    public static MemorySegment ggml_backend_graph_plan_free$address() {
        return ggml_backend_graph_plan_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_graph_plan_free(ggml_backend_t backend, ggml_backend_graph_plan_t plan)
     * }
     */
    public static void ggml_backend_graph_plan_free(MemorySegment backend, MemorySegment plan) {
        var mh$ = ggml_backend_graph_plan_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_graph_plan_free", backend, plan);
            }
            mh$.invokeExact(backend, plan);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_graph_plan_compute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_graph_plan_compute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_graph_plan_compute(ggml_backend_t backend, ggml_backend_graph_plan_t plan)
     * }
     */
    public static FunctionDescriptor ggml_backend_graph_plan_compute$descriptor() {
        return ggml_backend_graph_plan_compute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_graph_plan_compute(ggml_backend_t backend, ggml_backend_graph_plan_t plan)
     * }
     */
    public static MethodHandle ggml_backend_graph_plan_compute$handle() {
        return ggml_backend_graph_plan_compute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_graph_plan_compute(ggml_backend_t backend, ggml_backend_graph_plan_t plan)
     * }
     */
    public static MemorySegment ggml_backend_graph_plan_compute$address() {
        return ggml_backend_graph_plan_compute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_graph_plan_compute(ggml_backend_t backend, ggml_backend_graph_plan_t plan)
     * }
     */
    public static int ggml_backend_graph_plan_compute(MemorySegment backend, MemorySegment plan) {
        var mh$ = ggml_backend_graph_plan_compute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_graph_plan_compute", backend, plan);
            }
            return (int)mh$.invokeExact(backend, plan);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_graph_compute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_graph_compute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_graph_compute(ggml_backend_t backend, struct ggml_cgraph *cgraph)
     * }
     */
    public static FunctionDescriptor ggml_backend_graph_compute$descriptor() {
        return ggml_backend_graph_compute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_graph_compute(ggml_backend_t backend, struct ggml_cgraph *cgraph)
     * }
     */
    public static MethodHandle ggml_backend_graph_compute$handle() {
        return ggml_backend_graph_compute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_graph_compute(ggml_backend_t backend, struct ggml_cgraph *cgraph)
     * }
     */
    public static MemorySegment ggml_backend_graph_compute$address() {
        return ggml_backend_graph_compute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_graph_compute(ggml_backend_t backend, struct ggml_cgraph *cgraph)
     * }
     */
    public static int ggml_backend_graph_compute(MemorySegment backend, MemorySegment cgraph) {
        var mh$ = ggml_backend_graph_compute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_graph_compute", backend, cgraph);
            }
            return (int)mh$.invokeExact(backend, cgraph);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_graph_compute_async {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_graph_compute_async");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_graph_compute_async(ggml_backend_t backend, struct ggml_cgraph *cgraph)
     * }
     */
    public static FunctionDescriptor ggml_backend_graph_compute_async$descriptor() {
        return ggml_backend_graph_compute_async.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_graph_compute_async(ggml_backend_t backend, struct ggml_cgraph *cgraph)
     * }
     */
    public static MethodHandle ggml_backend_graph_compute_async$handle() {
        return ggml_backend_graph_compute_async.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_graph_compute_async(ggml_backend_t backend, struct ggml_cgraph *cgraph)
     * }
     */
    public static MemorySegment ggml_backend_graph_compute_async$address() {
        return ggml_backend_graph_compute_async.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_graph_compute_async(ggml_backend_t backend, struct ggml_cgraph *cgraph)
     * }
     */
    public static int ggml_backend_graph_compute_async(MemorySegment backend, MemorySegment cgraph) {
        var mh$ = ggml_backend_graph_compute_async.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_graph_compute_async", backend, cgraph);
            }
            return (int)mh$.invokeExact(backend, cgraph);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_supports_op {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_supports_op");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_backend_supports_op(ggml_backend_t backend, const struct ggml_tensor *op)
     * }
     */
    public static FunctionDescriptor ggml_backend_supports_op$descriptor() {
        return ggml_backend_supports_op.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_backend_supports_op(ggml_backend_t backend, const struct ggml_tensor *op)
     * }
     */
    public static MethodHandle ggml_backend_supports_op$handle() {
        return ggml_backend_supports_op.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_backend_supports_op(ggml_backend_t backend, const struct ggml_tensor *op)
     * }
     */
    public static MemorySegment ggml_backend_supports_op$address() {
        return ggml_backend_supports_op.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_backend_supports_op(ggml_backend_t backend, const struct ggml_tensor *op)
     * }
     */
    public static boolean ggml_backend_supports_op(MemorySegment backend, MemorySegment op) {
        var mh$ = ggml_backend_supports_op.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_supports_op", backend, op);
            }
            return (boolean)mh$.invokeExact(backend, op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_supports_buft {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_supports_buft");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_backend_supports_buft(ggml_backend_t backend, ggml_backend_buffer_type_t buft)
     * }
     */
    public static FunctionDescriptor ggml_backend_supports_buft$descriptor() {
        return ggml_backend_supports_buft.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_backend_supports_buft(ggml_backend_t backend, ggml_backend_buffer_type_t buft)
     * }
     */
    public static MethodHandle ggml_backend_supports_buft$handle() {
        return ggml_backend_supports_buft.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_backend_supports_buft(ggml_backend_t backend, ggml_backend_buffer_type_t buft)
     * }
     */
    public static MemorySegment ggml_backend_supports_buft$address() {
        return ggml_backend_supports_buft.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_backend_supports_buft(ggml_backend_t backend, ggml_backend_buffer_type_t buft)
     * }
     */
    public static boolean ggml_backend_supports_buft(MemorySegment backend, MemorySegment buft) {
        var mh$ = ggml_backend_supports_buft.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_supports_buft", backend, buft);
            }
            return (boolean)mh$.invokeExact(backend, buft);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_offload_op {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_offload_op");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_backend_offload_op(ggml_backend_t backend, const struct ggml_tensor *op)
     * }
     */
    public static FunctionDescriptor ggml_backend_offload_op$descriptor() {
        return ggml_backend_offload_op.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_backend_offload_op(ggml_backend_t backend, const struct ggml_tensor *op)
     * }
     */
    public static MethodHandle ggml_backend_offload_op$handle() {
        return ggml_backend_offload_op.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_backend_offload_op(ggml_backend_t backend, const struct ggml_tensor *op)
     * }
     */
    public static MemorySegment ggml_backend_offload_op$address() {
        return ggml_backend_offload_op.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_backend_offload_op(ggml_backend_t backend, const struct ggml_tensor *op)
     * }
     */
    public static boolean ggml_backend_offload_op(MemorySegment backend, MemorySegment op) {
        var mh$ = ggml_backend_offload_op.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_offload_op", backend, op);
            }
            return (boolean)mh$.invokeExact(backend, op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_tensor_copy_async {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_tensor_copy_async");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_copy_async(ggml_backend_t backend_src, ggml_backend_t backend_dst, struct ggml_tensor *src, struct ggml_tensor *dst)
     * }
     */
    public static FunctionDescriptor ggml_backend_tensor_copy_async$descriptor() {
        return ggml_backend_tensor_copy_async.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_copy_async(ggml_backend_t backend_src, ggml_backend_t backend_dst, struct ggml_tensor *src, struct ggml_tensor *dst)
     * }
     */
    public static MethodHandle ggml_backend_tensor_copy_async$handle() {
        return ggml_backend_tensor_copy_async.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_copy_async(ggml_backend_t backend_src, ggml_backend_t backend_dst, struct ggml_tensor *src, struct ggml_tensor *dst)
     * }
     */
    public static MemorySegment ggml_backend_tensor_copy_async$address() {
        return ggml_backend_tensor_copy_async.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_copy_async(ggml_backend_t backend_src, ggml_backend_t backend_dst, struct ggml_tensor *src, struct ggml_tensor *dst)
     * }
     */
    public static void ggml_backend_tensor_copy_async(MemorySegment backend_src, MemorySegment backend_dst, MemorySegment src, MemorySegment dst) {
        var mh$ = ggml_backend_tensor_copy_async.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_tensor_copy_async", backend_src, backend_dst, src, dst);
            }
            mh$.invokeExact(backend_src, backend_dst, src, dst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_get_device {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_get_device");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_get_device(ggml_backend_t backend)
     * }
     */
    public static FunctionDescriptor ggml_backend_get_device$descriptor() {
        return ggml_backend_get_device.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_get_device(ggml_backend_t backend)
     * }
     */
    public static MethodHandle ggml_backend_get_device$handle() {
        return ggml_backend_get_device.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_get_device(ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_get_device$address() {
        return ggml_backend_get_device.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_get_device(ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_get_device(MemorySegment backend) {
        var mh$ = ggml_backend_get_device.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_get_device", backend);
            }
            return (MemorySegment)mh$.invokeExact(backend);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_event_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_event_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_event_t ggml_backend_event_new(ggml_backend_dev_t device)
     * }
     */
    public static FunctionDescriptor ggml_backend_event_new$descriptor() {
        return ggml_backend_event_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_event_t ggml_backend_event_new(ggml_backend_dev_t device)
     * }
     */
    public static MethodHandle ggml_backend_event_new$handle() {
        return ggml_backend_event_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_event_t ggml_backend_event_new(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_event_new$address() {
        return ggml_backend_event_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_event_t ggml_backend_event_new(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_event_new(MemorySegment device) {
        var mh$ = ggml_backend_event_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_event_new", device);
            }
            return (MemorySegment)mh$.invokeExact(device);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_event_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_event_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_event_free(ggml_backend_event_t event)
     * }
     */
    public static FunctionDescriptor ggml_backend_event_free$descriptor() {
        return ggml_backend_event_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_event_free(ggml_backend_event_t event)
     * }
     */
    public static MethodHandle ggml_backend_event_free$handle() {
        return ggml_backend_event_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_event_free(ggml_backend_event_t event)
     * }
     */
    public static MemorySegment ggml_backend_event_free$address() {
        return ggml_backend_event_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_event_free(ggml_backend_event_t event)
     * }
     */
    public static void ggml_backend_event_free(MemorySegment event) {
        var mh$ = ggml_backend_event_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_event_free", event);
            }
            mh$.invokeExact(event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_event_record {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_event_record");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_event_record(ggml_backend_event_t event, ggml_backend_t backend)
     * }
     */
    public static FunctionDescriptor ggml_backend_event_record$descriptor() {
        return ggml_backend_event_record.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_event_record(ggml_backend_event_t event, ggml_backend_t backend)
     * }
     */
    public static MethodHandle ggml_backend_event_record$handle() {
        return ggml_backend_event_record.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_event_record(ggml_backend_event_t event, ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_event_record$address() {
        return ggml_backend_event_record.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_event_record(ggml_backend_event_t event, ggml_backend_t backend)
     * }
     */
    public static void ggml_backend_event_record(MemorySegment event, MemorySegment backend) {
        var mh$ = ggml_backend_event_record.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_event_record", event, backend);
            }
            mh$.invokeExact(event, backend);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_event_synchronize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_event_synchronize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_event_synchronize(ggml_backend_event_t event)
     * }
     */
    public static FunctionDescriptor ggml_backend_event_synchronize$descriptor() {
        return ggml_backend_event_synchronize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_event_synchronize(ggml_backend_event_t event)
     * }
     */
    public static MethodHandle ggml_backend_event_synchronize$handle() {
        return ggml_backend_event_synchronize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_event_synchronize(ggml_backend_event_t event)
     * }
     */
    public static MemorySegment ggml_backend_event_synchronize$address() {
        return ggml_backend_event_synchronize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_event_synchronize(ggml_backend_event_t event)
     * }
     */
    public static void ggml_backend_event_synchronize(MemorySegment event) {
        var mh$ = ggml_backend_event_synchronize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_event_synchronize", event);
            }
            mh$.invokeExact(event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_event_wait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_event_wait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_event_wait(ggml_backend_t backend, ggml_backend_event_t event)
     * }
     */
    public static FunctionDescriptor ggml_backend_event_wait$descriptor() {
        return ggml_backend_event_wait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_event_wait(ggml_backend_t backend, ggml_backend_event_t event)
     * }
     */
    public static MethodHandle ggml_backend_event_wait$handle() {
        return ggml_backend_event_wait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_event_wait(ggml_backend_t backend, ggml_backend_event_t event)
     * }
     */
    public static MemorySegment ggml_backend_event_wait$address() {
        return ggml_backend_event_wait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_event_wait(ggml_backend_t backend, ggml_backend_event_t event)
     * }
     */
    public static void ggml_backend_event_wait(MemorySegment backend, MemorySegment event) {
        var mh$ = ggml_backend_event_wait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_event_wait", backend, event);
            }
            mh$.invokeExact(backend, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GGML_BACKEND_DEVICE_TYPE_CPU = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ggml_backend_dev_type.GGML_BACKEND_DEVICE_TYPE_CPU = 0
     * }
     */
    public static int GGML_BACKEND_DEVICE_TYPE_CPU() {
        return GGML_BACKEND_DEVICE_TYPE_CPU;
    }
    private static final int GGML_BACKEND_DEVICE_TYPE_GPU = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ggml_backend_dev_type.GGML_BACKEND_DEVICE_TYPE_GPU = 1
     * }
     */
    public static int GGML_BACKEND_DEVICE_TYPE_GPU() {
        return GGML_BACKEND_DEVICE_TYPE_GPU;
    }
    private static final int GGML_BACKEND_DEVICE_TYPE_ACCEL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ggml_backend_dev_type.GGML_BACKEND_DEVICE_TYPE_ACCEL = 2
     * }
     */
    public static int GGML_BACKEND_DEVICE_TYPE_ACCEL() {
        return GGML_BACKEND_DEVICE_TYPE_ACCEL;
    }

    private static class ggml_backend_dev_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_dev_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_dev_name(ggml_backend_dev_t device)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_name$descriptor() {
        return ggml_backend_dev_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_dev_name(ggml_backend_dev_t device)
     * }
     */
    public static MethodHandle ggml_backend_dev_name$handle() {
        return ggml_backend_dev_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_dev_name(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_dev_name$address() {
        return ggml_backend_dev_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ggml_backend_dev_name(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_dev_name(MemorySegment device) {
        var mh$ = ggml_backend_dev_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_name", device);
            }
            return (MemorySegment)mh$.invokeExact(device);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_description {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_dev_description");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_dev_description(ggml_backend_dev_t device)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_description$descriptor() {
        return ggml_backend_dev_description.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_dev_description(ggml_backend_dev_t device)
     * }
     */
    public static MethodHandle ggml_backend_dev_description$handle() {
        return ggml_backend_dev_description.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_dev_description(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_dev_description$address() {
        return ggml_backend_dev_description.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ggml_backend_dev_description(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_dev_description(MemorySegment device) {
        var mh$ = ggml_backend_dev_description.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_description", device);
            }
            return (MemorySegment)mh$.invokeExact(device);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_memory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_dev_memory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_dev_memory(ggml_backend_dev_t device, size_t *free, size_t *total)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_memory$descriptor() {
        return ggml_backend_dev_memory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_dev_memory(ggml_backend_dev_t device, size_t *free, size_t *total)
     * }
     */
    public static MethodHandle ggml_backend_dev_memory$handle() {
        return ggml_backend_dev_memory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_dev_memory(ggml_backend_dev_t device, size_t *free, size_t *total)
     * }
     */
    public static MemorySegment ggml_backend_dev_memory$address() {
        return ggml_backend_dev_memory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_dev_memory(ggml_backend_dev_t device, size_t *free, size_t *total)
     * }
     */
    public static void ggml_backend_dev_memory(MemorySegment device, MemorySegment free, MemorySegment total) {
        var mh$ = ggml_backend_dev_memory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_memory", device, free, total);
            }
            mh$.invokeExact(device, free, total);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_dev_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_backend_dev_type ggml_backend_dev_type(ggml_backend_dev_t device)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_type$descriptor() {
        return ggml_backend_dev_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_backend_dev_type ggml_backend_dev_type(ggml_backend_dev_t device)
     * }
     */
    public static MethodHandle ggml_backend_dev_type$handle() {
        return ggml_backend_dev_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_backend_dev_type ggml_backend_dev_type(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_dev_type$address() {
        return ggml_backend_dev_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_backend_dev_type ggml_backend_dev_type(ggml_backend_dev_t device)
     * }
     */
    public static int ggml_backend_dev_type(MemorySegment device) {
        var mh$ = ggml_backend_dev_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_type", device);
            }
            return (int)mh$.invokeExact(device);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_get_props {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_dev_get_props");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_dev_get_props(ggml_backend_dev_t device, struct ggml_backend_dev_props *props)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_get_props$descriptor() {
        return ggml_backend_dev_get_props.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_dev_get_props(ggml_backend_dev_t device, struct ggml_backend_dev_props *props)
     * }
     */
    public static MethodHandle ggml_backend_dev_get_props$handle() {
        return ggml_backend_dev_get_props.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_dev_get_props(ggml_backend_dev_t device, struct ggml_backend_dev_props *props)
     * }
     */
    public static MemorySegment ggml_backend_dev_get_props$address() {
        return ggml_backend_dev_get_props.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_dev_get_props(ggml_backend_dev_t device, struct ggml_backend_dev_props *props)
     * }
     */
    public static void ggml_backend_dev_get_props(MemorySegment device, MemorySegment props) {
        var mh$ = ggml_backend_dev_get_props.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_get_props", device, props);
            }
            mh$.invokeExact(device, props);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_backend_reg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_dev_backend_reg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_dev_backend_reg(ggml_backend_dev_t device)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_backend_reg$descriptor() {
        return ggml_backend_dev_backend_reg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_dev_backend_reg(ggml_backend_dev_t device)
     * }
     */
    public static MethodHandle ggml_backend_dev_backend_reg$handle() {
        return ggml_backend_dev_backend_reg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_dev_backend_reg(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_dev_backend_reg$address() {
        return ggml_backend_dev_backend_reg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_dev_backend_reg(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_dev_backend_reg(MemorySegment device) {
        var mh$ = ggml_backend_dev_backend_reg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_backend_reg", device);
            }
            return (MemorySegment)mh$.invokeExact(device);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_dev_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_dev_init(ggml_backend_dev_t device, const char *params)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_init$descriptor() {
        return ggml_backend_dev_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_dev_init(ggml_backend_dev_t device, const char *params)
     * }
     */
    public static MethodHandle ggml_backend_dev_init$handle() {
        return ggml_backend_dev_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_dev_init(ggml_backend_dev_t device, const char *params)
     * }
     */
    public static MemorySegment ggml_backend_dev_init$address() {
        return ggml_backend_dev_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_dev_init(ggml_backend_dev_t device, const char *params)
     * }
     */
    public static MemorySegment ggml_backend_dev_init(MemorySegment device, MemorySegment params) {
        var mh$ = ggml_backend_dev_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_init", device, params);
            }
            return (MemorySegment)mh$.invokeExact(device, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_buffer_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_dev_buffer_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_dev_buffer_type(ggml_backend_dev_t device)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_buffer_type$descriptor() {
        return ggml_backend_dev_buffer_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_dev_buffer_type(ggml_backend_dev_t device)
     * }
     */
    public static MethodHandle ggml_backend_dev_buffer_type$handle() {
        return ggml_backend_dev_buffer_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_dev_buffer_type(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_dev_buffer_type$address() {
        return ggml_backend_dev_buffer_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_dev_buffer_type(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_dev_buffer_type(MemorySegment device) {
        var mh$ = ggml_backend_dev_buffer_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_buffer_type", device);
            }
            return (MemorySegment)mh$.invokeExact(device);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_host_buffer_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_dev_host_buffer_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_dev_host_buffer_type(ggml_backend_dev_t device)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_host_buffer_type$descriptor() {
        return ggml_backend_dev_host_buffer_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_dev_host_buffer_type(ggml_backend_dev_t device)
     * }
     */
    public static MethodHandle ggml_backend_dev_host_buffer_type$handle() {
        return ggml_backend_dev_host_buffer_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_dev_host_buffer_type(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_dev_host_buffer_type$address() {
        return ggml_backend_dev_host_buffer_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_dev_host_buffer_type(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_dev_host_buffer_type(MemorySegment device) {
        var mh$ = ggml_backend_dev_host_buffer_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_host_buffer_type", device);
            }
            return (MemorySegment)mh$.invokeExact(device);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_buffer_from_host_ptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_dev_buffer_from_host_ptr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_dev_buffer_from_host_ptr(ggml_backend_dev_t device, void *ptr, size_t size, size_t max_tensor_size)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_buffer_from_host_ptr$descriptor() {
        return ggml_backend_dev_buffer_from_host_ptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_dev_buffer_from_host_ptr(ggml_backend_dev_t device, void *ptr, size_t size, size_t max_tensor_size)
     * }
     */
    public static MethodHandle ggml_backend_dev_buffer_from_host_ptr$handle() {
        return ggml_backend_dev_buffer_from_host_ptr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_dev_buffer_from_host_ptr(ggml_backend_dev_t device, void *ptr, size_t size, size_t max_tensor_size)
     * }
     */
    public static MemorySegment ggml_backend_dev_buffer_from_host_ptr$address() {
        return ggml_backend_dev_buffer_from_host_ptr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_dev_buffer_from_host_ptr(ggml_backend_dev_t device, void *ptr, size_t size, size_t max_tensor_size)
     * }
     */
    public static MemorySegment ggml_backend_dev_buffer_from_host_ptr(MemorySegment device, MemorySegment ptr, long size, long max_tensor_size) {
        var mh$ = ggml_backend_dev_buffer_from_host_ptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_buffer_from_host_ptr", device, ptr, size, max_tensor_size);
            }
            return (MemorySegment)mh$.invokeExact(device, ptr, size, max_tensor_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_supports_op {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_dev_supports_op");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_backend_dev_supports_op(ggml_backend_dev_t device, const struct ggml_tensor *op)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_supports_op$descriptor() {
        return ggml_backend_dev_supports_op.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_backend_dev_supports_op(ggml_backend_dev_t device, const struct ggml_tensor *op)
     * }
     */
    public static MethodHandle ggml_backend_dev_supports_op$handle() {
        return ggml_backend_dev_supports_op.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_backend_dev_supports_op(ggml_backend_dev_t device, const struct ggml_tensor *op)
     * }
     */
    public static MemorySegment ggml_backend_dev_supports_op$address() {
        return ggml_backend_dev_supports_op.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_backend_dev_supports_op(ggml_backend_dev_t device, const struct ggml_tensor *op)
     * }
     */
    public static boolean ggml_backend_dev_supports_op(MemorySegment device, MemorySegment op) {
        var mh$ = ggml_backend_dev_supports_op.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_supports_op", device, op);
            }
            return (boolean)mh$.invokeExact(device, op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_supports_buft {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_dev_supports_buft");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_backend_dev_supports_buft(ggml_backend_dev_t device, ggml_backend_buffer_type_t buft)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_supports_buft$descriptor() {
        return ggml_backend_dev_supports_buft.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_backend_dev_supports_buft(ggml_backend_dev_t device, ggml_backend_buffer_type_t buft)
     * }
     */
    public static MethodHandle ggml_backend_dev_supports_buft$handle() {
        return ggml_backend_dev_supports_buft.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_backend_dev_supports_buft(ggml_backend_dev_t device, ggml_backend_buffer_type_t buft)
     * }
     */
    public static MemorySegment ggml_backend_dev_supports_buft$address() {
        return ggml_backend_dev_supports_buft.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_backend_dev_supports_buft(ggml_backend_dev_t device, ggml_backend_buffer_type_t buft)
     * }
     */
    public static boolean ggml_backend_dev_supports_buft(MemorySegment device, MemorySegment buft) {
        var mh$ = ggml_backend_dev_supports_buft.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_supports_buft", device, buft);
            }
            return (boolean)mh$.invokeExact(device, buft);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_offload_op {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_dev_offload_op");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_backend_dev_offload_op(ggml_backend_dev_t device, const struct ggml_tensor *op)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_offload_op$descriptor() {
        return ggml_backend_dev_offload_op.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_backend_dev_offload_op(ggml_backend_dev_t device, const struct ggml_tensor *op)
     * }
     */
    public static MethodHandle ggml_backend_dev_offload_op$handle() {
        return ggml_backend_dev_offload_op.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_backend_dev_offload_op(ggml_backend_dev_t device, const struct ggml_tensor *op)
     * }
     */
    public static MemorySegment ggml_backend_dev_offload_op$address() {
        return ggml_backend_dev_offload_op.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_backend_dev_offload_op(ggml_backend_dev_t device, const struct ggml_tensor *op)
     * }
     */
    public static boolean ggml_backend_dev_offload_op(MemorySegment device, MemorySegment op) {
        var mh$ = ggml_backend_dev_offload_op.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_offload_op", device, op);
            }
            return (boolean)mh$.invokeExact(device, op);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_reg_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_reg_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_reg_name(ggml_backend_reg_t reg)
     * }
     */
    public static FunctionDescriptor ggml_backend_reg_name$descriptor() {
        return ggml_backend_reg_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_reg_name(ggml_backend_reg_t reg)
     * }
     */
    public static MethodHandle ggml_backend_reg_name$handle() {
        return ggml_backend_reg_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_reg_name(ggml_backend_reg_t reg)
     * }
     */
    public static MemorySegment ggml_backend_reg_name$address() {
        return ggml_backend_reg_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ggml_backend_reg_name(ggml_backend_reg_t reg)
     * }
     */
    public static MemorySegment ggml_backend_reg_name(MemorySegment reg) {
        var mh$ = ggml_backend_reg_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_reg_name", reg);
            }
            return (MemorySegment)mh$.invokeExact(reg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_reg_dev_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_reg_dev_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_reg_dev_count(ggml_backend_reg_t reg)
     * }
     */
    public static FunctionDescriptor ggml_backend_reg_dev_count$descriptor() {
        return ggml_backend_reg_dev_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_reg_dev_count(ggml_backend_reg_t reg)
     * }
     */
    public static MethodHandle ggml_backend_reg_dev_count$handle() {
        return ggml_backend_reg_dev_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_reg_dev_count(ggml_backend_reg_t reg)
     * }
     */
    public static MemorySegment ggml_backend_reg_dev_count$address() {
        return ggml_backend_reg_dev_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_backend_reg_dev_count(ggml_backend_reg_t reg)
     * }
     */
    public static long ggml_backend_reg_dev_count(MemorySegment reg) {
        var mh$ = ggml_backend_reg_dev_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_reg_dev_count", reg);
            }
            return (long)mh$.invokeExact(reg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_reg_dev_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_reg_dev_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_reg_dev_get(ggml_backend_reg_t reg, size_t index)
     * }
     */
    public static FunctionDescriptor ggml_backend_reg_dev_get$descriptor() {
        return ggml_backend_reg_dev_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_reg_dev_get(ggml_backend_reg_t reg, size_t index)
     * }
     */
    public static MethodHandle ggml_backend_reg_dev_get$handle() {
        return ggml_backend_reg_dev_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_reg_dev_get(ggml_backend_reg_t reg, size_t index)
     * }
     */
    public static MemorySegment ggml_backend_reg_dev_get$address() {
        return ggml_backend_reg_dev_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_reg_dev_get(ggml_backend_reg_t reg, size_t index)
     * }
     */
    public static MemorySegment ggml_backend_reg_dev_get(MemorySegment reg, long index) {
        var mh$ = ggml_backend_reg_dev_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_reg_dev_get", reg, index);
            }
            return (MemorySegment)mh$.invokeExact(reg, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_reg_get_proc_address {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_reg_get_proc_address");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *ggml_backend_reg_get_proc_address(ggml_backend_reg_t reg, const char *name)
     * }
     */
    public static FunctionDescriptor ggml_backend_reg_get_proc_address$descriptor() {
        return ggml_backend_reg_get_proc_address.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *ggml_backend_reg_get_proc_address(ggml_backend_reg_t reg, const char *name)
     * }
     */
    public static MethodHandle ggml_backend_reg_get_proc_address$handle() {
        return ggml_backend_reg_get_proc_address.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *ggml_backend_reg_get_proc_address(ggml_backend_reg_t reg, const char *name)
     * }
     */
    public static MemorySegment ggml_backend_reg_get_proc_address$address() {
        return ggml_backend_reg_get_proc_address.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *ggml_backend_reg_get_proc_address(ggml_backend_reg_t reg, const char *name)
     * }
     */
    public static MemorySegment ggml_backend_reg_get_proc_address(MemorySegment reg, MemorySegment name) {
        var mh$ = ggml_backend_reg_get_proc_address.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_reg_get_proc_address", reg, name);
            }
            return (MemorySegment)mh$.invokeExact(reg, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_device_register {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_device_register");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_device_register(ggml_backend_dev_t device)
     * }
     */
    public static FunctionDescriptor ggml_backend_device_register$descriptor() {
        return ggml_backend_device_register.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_device_register(ggml_backend_dev_t device)
     * }
     */
    public static MethodHandle ggml_backend_device_register$handle() {
        return ggml_backend_device_register.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_device_register(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_device_register$address() {
        return ggml_backend_device_register.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_device_register(ggml_backend_dev_t device)
     * }
     */
    public static void ggml_backend_device_register(MemorySegment device) {
        var mh$ = ggml_backend_device_register.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_device_register", device);
            }
            mh$.invokeExact(device);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_reg_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_reg_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_reg_count()
     * }
     */
    public static FunctionDescriptor ggml_backend_reg_count$descriptor() {
        return ggml_backend_reg_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_reg_count()
     * }
     */
    public static MethodHandle ggml_backend_reg_count$handle() {
        return ggml_backend_reg_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_reg_count()
     * }
     */
    public static MemorySegment ggml_backend_reg_count$address() {
        return ggml_backend_reg_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_backend_reg_count()
     * }
     */
    public static long ggml_backend_reg_count() {
        var mh$ = ggml_backend_reg_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_reg_count");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_reg_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_reg_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_reg_get(size_t index)
     * }
     */
    public static FunctionDescriptor ggml_backend_reg_get$descriptor() {
        return ggml_backend_reg_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_reg_get(size_t index)
     * }
     */
    public static MethodHandle ggml_backend_reg_get$handle() {
        return ggml_backend_reg_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_reg_get(size_t index)
     * }
     */
    public static MemorySegment ggml_backend_reg_get$address() {
        return ggml_backend_reg_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_reg_get(size_t index)
     * }
     */
    public static MemorySegment ggml_backend_reg_get(long index) {
        var mh$ = ggml_backend_reg_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_reg_get", index);
            }
            return (MemorySegment)mh$.invokeExact(index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_reg_by_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_reg_by_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_reg_by_name(const char *name)
     * }
     */
    public static FunctionDescriptor ggml_backend_reg_by_name$descriptor() {
        return ggml_backend_reg_by_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_reg_by_name(const char *name)
     * }
     */
    public static MethodHandle ggml_backend_reg_by_name$handle() {
        return ggml_backend_reg_by_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_reg_by_name(const char *name)
     * }
     */
    public static MemorySegment ggml_backend_reg_by_name$address() {
        return ggml_backend_reg_by_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_reg_by_name(const char *name)
     * }
     */
    public static MemorySegment ggml_backend_reg_by_name(MemorySegment name) {
        var mh$ = ggml_backend_reg_by_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_reg_by_name", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_dev_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_dev_count()
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_count$descriptor() {
        return ggml_backend_dev_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_dev_count()
     * }
     */
    public static MethodHandle ggml_backend_dev_count$handle() {
        return ggml_backend_dev_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_dev_count()
     * }
     */
    public static MemorySegment ggml_backend_dev_count$address() {
        return ggml_backend_dev_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_backend_dev_count()
     * }
     */
    public static long ggml_backend_dev_count() {
        var mh$ = ggml_backend_dev_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_count");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_dev_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_dev_get(size_t index)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_get$descriptor() {
        return ggml_backend_dev_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_dev_get(size_t index)
     * }
     */
    public static MethodHandle ggml_backend_dev_get$handle() {
        return ggml_backend_dev_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_dev_get(size_t index)
     * }
     */
    public static MemorySegment ggml_backend_dev_get$address() {
        return ggml_backend_dev_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_dev_get(size_t index)
     * }
     */
    public static MemorySegment ggml_backend_dev_get(long index) {
        var mh$ = ggml_backend_dev_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_get", index);
            }
            return (MemorySegment)mh$.invokeExact(index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_by_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_dev_by_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_dev_by_name(const char *name)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_by_name$descriptor() {
        return ggml_backend_dev_by_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_dev_by_name(const char *name)
     * }
     */
    public static MethodHandle ggml_backend_dev_by_name$handle() {
        return ggml_backend_dev_by_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_dev_by_name(const char *name)
     * }
     */
    public static MemorySegment ggml_backend_dev_by_name$address() {
        return ggml_backend_dev_by_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_dev_by_name(const char *name)
     * }
     */
    public static MemorySegment ggml_backend_dev_by_name(MemorySegment name) {
        var mh$ = ggml_backend_dev_by_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_by_name", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_by_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_dev_by_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_dev_by_type(enum ggml_backend_dev_type type)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_by_type$descriptor() {
        return ggml_backend_dev_by_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_dev_by_type(enum ggml_backend_dev_type type)
     * }
     */
    public static MethodHandle ggml_backend_dev_by_type$handle() {
        return ggml_backend_dev_by_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_dev_by_type(enum ggml_backend_dev_type type)
     * }
     */
    public static MemorySegment ggml_backend_dev_by_type$address() {
        return ggml_backend_dev_by_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_dev_by_type(enum ggml_backend_dev_type type)
     * }
     */
    public static MemorySegment ggml_backend_dev_by_type(int type) {
        var mh$ = ggml_backend_dev_by_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_by_type", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_init_by_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_init_by_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_init_by_name(const char *name, const char *params)
     * }
     */
    public static FunctionDescriptor ggml_backend_init_by_name$descriptor() {
        return ggml_backend_init_by_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_init_by_name(const char *name, const char *params)
     * }
     */
    public static MethodHandle ggml_backend_init_by_name$handle() {
        return ggml_backend_init_by_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_init_by_name(const char *name, const char *params)
     * }
     */
    public static MemorySegment ggml_backend_init_by_name$address() {
        return ggml_backend_init_by_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_init_by_name(const char *name, const char *params)
     * }
     */
    public static MemorySegment ggml_backend_init_by_name(MemorySegment name, MemorySegment params) {
        var mh$ = ggml_backend_init_by_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_init_by_name", name, params);
            }
            return (MemorySegment)mh$.invokeExact(name, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_init_by_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_init_by_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_init_by_type(enum ggml_backend_dev_type type, const char *params)
     * }
     */
    public static FunctionDescriptor ggml_backend_init_by_type$descriptor() {
        return ggml_backend_init_by_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_init_by_type(enum ggml_backend_dev_type type, const char *params)
     * }
     */
    public static MethodHandle ggml_backend_init_by_type$handle() {
        return ggml_backend_init_by_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_init_by_type(enum ggml_backend_dev_type type, const char *params)
     * }
     */
    public static MemorySegment ggml_backend_init_by_type$address() {
        return ggml_backend_init_by_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_init_by_type(enum ggml_backend_dev_type type, const char *params)
     * }
     */
    public static MemorySegment ggml_backend_init_by_type(int type, MemorySegment params) {
        var mh$ = ggml_backend_init_by_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_init_by_type", type, params);
            }
            return (MemorySegment)mh$.invokeExact(type, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_init_best {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_init_best");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_init_best()
     * }
     */
    public static FunctionDescriptor ggml_backend_init_best$descriptor() {
        return ggml_backend_init_best.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_init_best()
     * }
     */
    public static MethodHandle ggml_backend_init_best$handle() {
        return ggml_backend_init_best.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_init_best()
     * }
     */
    public static MemorySegment ggml_backend_init_best$address() {
        return ggml_backend_init_best.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_init_best()
     * }
     */
    public static MemorySegment ggml_backend_init_best() {
        var mh$ = ggml_backend_init_best.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_init_best");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_load {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_load");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_load(const char *path)
     * }
     */
    public static FunctionDescriptor ggml_backend_load$descriptor() {
        return ggml_backend_load.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_load(const char *path)
     * }
     */
    public static MethodHandle ggml_backend_load$handle() {
        return ggml_backend_load.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_load(const char *path)
     * }
     */
    public static MemorySegment ggml_backend_load$address() {
        return ggml_backend_load.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_load(const char *path)
     * }
     */
    public static MemorySegment ggml_backend_load(MemorySegment path) {
        var mh$ = ggml_backend_load.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_load", path);
            }
            return (MemorySegment)mh$.invokeExact(path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_unload {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_unload");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_unload(ggml_backend_reg_t reg)
     * }
     */
    public static FunctionDescriptor ggml_backend_unload$descriptor() {
        return ggml_backend_unload.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_unload(ggml_backend_reg_t reg)
     * }
     */
    public static MethodHandle ggml_backend_unload$handle() {
        return ggml_backend_unload.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_unload(ggml_backend_reg_t reg)
     * }
     */
    public static MemorySegment ggml_backend_unload$address() {
        return ggml_backend_unload.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_unload(ggml_backend_reg_t reg)
     * }
     */
    public static void ggml_backend_unload(MemorySegment reg) {
        var mh$ = ggml_backend_unload.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_unload", reg);
            }
            mh$.invokeExact(reg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_load_all {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_load_all");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_load_all()
     * }
     */
    public static FunctionDescriptor ggml_backend_load_all$descriptor() {
        return ggml_backend_load_all.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_load_all()
     * }
     */
    public static MethodHandle ggml_backend_load_all$handle() {
        return ggml_backend_load_all.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_load_all()
     * }
     */
    public static MemorySegment ggml_backend_load_all$address() {
        return ggml_backend_load_all.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_load_all()
     * }
     */
    public static void ggml_backend_load_all() {
        var mh$ = ggml_backend_load_all.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_load_all");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_load_all_from_path {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_load_all_from_path");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_load_all_from_path(const char *dir_path)
     * }
     */
    public static FunctionDescriptor ggml_backend_load_all_from_path$descriptor() {
        return ggml_backend_load_all_from_path.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_load_all_from_path(const char *dir_path)
     * }
     */
    public static MethodHandle ggml_backend_load_all_from_path$handle() {
        return ggml_backend_load_all_from_path.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_load_all_from_path(const char *dir_path)
     * }
     */
    public static MemorySegment ggml_backend_load_all_from_path$address() {
        return ggml_backend_load_all_from_path.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_load_all_from_path(const char *dir_path)
     * }
     */
    public static void ggml_backend_load_all_from_path(MemorySegment dir_path) {
        var mh$ = ggml_backend_load_all_from_path.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_load_all_from_path", dir_path);
            }
            mh$.invokeExact(dir_path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct ggml_backend_sched *ggml_backend_sched_t
     * }
     */
    public static final AddressLayout ggml_backend_sched_t = WhisperCpp.C_POINTER;

    private static class ggml_backend_sched_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_LONG,
            WhisperCpp.C_BOOL,
            WhisperCpp.C_BOOL
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_sched_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_sched_t ggml_backend_sched_new(ggml_backend_t *backends, ggml_backend_buffer_type_t *bufts, int n_backends, size_t graph_size, bool parallel, bool op_offload)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_new$descriptor() {
        return ggml_backend_sched_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_sched_t ggml_backend_sched_new(ggml_backend_t *backends, ggml_backend_buffer_type_t *bufts, int n_backends, size_t graph_size, bool parallel, bool op_offload)
     * }
     */
    public static MethodHandle ggml_backend_sched_new$handle() {
        return ggml_backend_sched_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_sched_t ggml_backend_sched_new(ggml_backend_t *backends, ggml_backend_buffer_type_t *bufts, int n_backends, size_t graph_size, bool parallel, bool op_offload)
     * }
     */
    public static MemorySegment ggml_backend_sched_new$address() {
        return ggml_backend_sched_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_sched_t ggml_backend_sched_new(ggml_backend_t *backends, ggml_backend_buffer_type_t *bufts, int n_backends, size_t graph_size, bool parallel, bool op_offload)
     * }
     */
    public static MemorySegment ggml_backend_sched_new(MemorySegment backends, MemorySegment bufts, int n_backends, long graph_size, boolean parallel, boolean op_offload) {
        var mh$ = ggml_backend_sched_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_new", backends, bufts, n_backends, graph_size, parallel, op_offload);
            }
            return (MemorySegment)mh$.invokeExact(backends, bufts, n_backends, graph_size, parallel, op_offload);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_sched_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_free(ggml_backend_sched_t sched)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_free$descriptor() {
        return ggml_backend_sched_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_free(ggml_backend_sched_t sched)
     * }
     */
    public static MethodHandle ggml_backend_sched_free$handle() {
        return ggml_backend_sched_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_free(ggml_backend_sched_t sched)
     * }
     */
    public static MemorySegment ggml_backend_sched_free$address() {
        return ggml_backend_sched_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_sched_free(ggml_backend_sched_t sched)
     * }
     */
    public static void ggml_backend_sched_free(MemorySegment sched) {
        var mh$ = ggml_backend_sched_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_free", sched);
            }
            mh$.invokeExact(sched);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_reserve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_sched_reserve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_backend_sched_reserve(ggml_backend_sched_t sched, struct ggml_cgraph *measure_graph)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_reserve$descriptor() {
        return ggml_backend_sched_reserve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_backend_sched_reserve(ggml_backend_sched_t sched, struct ggml_cgraph *measure_graph)
     * }
     */
    public static MethodHandle ggml_backend_sched_reserve$handle() {
        return ggml_backend_sched_reserve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_backend_sched_reserve(ggml_backend_sched_t sched, struct ggml_cgraph *measure_graph)
     * }
     */
    public static MemorySegment ggml_backend_sched_reserve$address() {
        return ggml_backend_sched_reserve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_backend_sched_reserve(ggml_backend_sched_t sched, struct ggml_cgraph *measure_graph)
     * }
     */
    public static boolean ggml_backend_sched_reserve(MemorySegment sched, MemorySegment measure_graph) {
        var mh$ = ggml_backend_sched_reserve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_reserve", sched, measure_graph);
            }
            return (boolean)mh$.invokeExact(sched, measure_graph);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_get_n_backends {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_sched_get_n_backends");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_backend_sched_get_n_backends(ggml_backend_sched_t sched)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_get_n_backends$descriptor() {
        return ggml_backend_sched_get_n_backends.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_backend_sched_get_n_backends(ggml_backend_sched_t sched)
     * }
     */
    public static MethodHandle ggml_backend_sched_get_n_backends$handle() {
        return ggml_backend_sched_get_n_backends.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_backend_sched_get_n_backends(ggml_backend_sched_t sched)
     * }
     */
    public static MemorySegment ggml_backend_sched_get_n_backends$address() {
        return ggml_backend_sched_get_n_backends.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_backend_sched_get_n_backends(ggml_backend_sched_t sched)
     * }
     */
    public static int ggml_backend_sched_get_n_backends(MemorySegment sched) {
        var mh$ = ggml_backend_sched_get_n_backends.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_get_n_backends", sched);
            }
            return (int)mh$.invokeExact(sched);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_get_backend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_sched_get_backend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_sched_get_backend(ggml_backend_sched_t sched, int i)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_get_backend$descriptor() {
        return ggml_backend_sched_get_backend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_sched_get_backend(ggml_backend_sched_t sched, int i)
     * }
     */
    public static MethodHandle ggml_backend_sched_get_backend$handle() {
        return ggml_backend_sched_get_backend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_sched_get_backend(ggml_backend_sched_t sched, int i)
     * }
     */
    public static MemorySegment ggml_backend_sched_get_backend$address() {
        return ggml_backend_sched_get_backend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_sched_get_backend(ggml_backend_sched_t sched, int i)
     * }
     */
    public static MemorySegment ggml_backend_sched_get_backend(MemorySegment sched, int i) {
        var mh$ = ggml_backend_sched_get_backend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_get_backend", sched, i);
            }
            return (MemorySegment)mh$.invokeExact(sched, i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_get_n_splits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_sched_get_n_splits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_backend_sched_get_n_splits(ggml_backend_sched_t sched)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_get_n_splits$descriptor() {
        return ggml_backend_sched_get_n_splits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_backend_sched_get_n_splits(ggml_backend_sched_t sched)
     * }
     */
    public static MethodHandle ggml_backend_sched_get_n_splits$handle() {
        return ggml_backend_sched_get_n_splits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_backend_sched_get_n_splits(ggml_backend_sched_t sched)
     * }
     */
    public static MemorySegment ggml_backend_sched_get_n_splits$address() {
        return ggml_backend_sched_get_n_splits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_backend_sched_get_n_splits(ggml_backend_sched_t sched)
     * }
     */
    public static int ggml_backend_sched_get_n_splits(MemorySegment sched) {
        var mh$ = ggml_backend_sched_get_n_splits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_get_n_splits", sched);
            }
            return (int)mh$.invokeExact(sched);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_get_n_copies {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_sched_get_n_copies");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_backend_sched_get_n_copies(ggml_backend_sched_t sched)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_get_n_copies$descriptor() {
        return ggml_backend_sched_get_n_copies.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_backend_sched_get_n_copies(ggml_backend_sched_t sched)
     * }
     */
    public static MethodHandle ggml_backend_sched_get_n_copies$handle() {
        return ggml_backend_sched_get_n_copies.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_backend_sched_get_n_copies(ggml_backend_sched_t sched)
     * }
     */
    public static MemorySegment ggml_backend_sched_get_n_copies$address() {
        return ggml_backend_sched_get_n_copies.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_backend_sched_get_n_copies(ggml_backend_sched_t sched)
     * }
     */
    public static int ggml_backend_sched_get_n_copies(MemorySegment sched) {
        var mh$ = ggml_backend_sched_get_n_copies.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_get_n_copies", sched);
            }
            return (int)mh$.invokeExact(sched);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_get_buffer_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_LONG,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_sched_get_buffer_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_sched_get_buffer_size(ggml_backend_sched_t sched, ggml_backend_t backend)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_get_buffer_size$descriptor() {
        return ggml_backend_sched_get_buffer_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_sched_get_buffer_size(ggml_backend_sched_t sched, ggml_backend_t backend)
     * }
     */
    public static MethodHandle ggml_backend_sched_get_buffer_size$handle() {
        return ggml_backend_sched_get_buffer_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_sched_get_buffer_size(ggml_backend_sched_t sched, ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_sched_get_buffer_size$address() {
        return ggml_backend_sched_get_buffer_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_backend_sched_get_buffer_size(ggml_backend_sched_t sched, ggml_backend_t backend)
     * }
     */
    public static long ggml_backend_sched_get_buffer_size(MemorySegment sched, MemorySegment backend) {
        var mh$ = ggml_backend_sched_get_buffer_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_get_buffer_size", sched, backend);
            }
            return (long)mh$.invokeExact(sched, backend);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_set_tensor_backend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_sched_set_tensor_backend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_set_tensor_backend(ggml_backend_sched_t sched, struct ggml_tensor *node, ggml_backend_t backend)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_set_tensor_backend$descriptor() {
        return ggml_backend_sched_set_tensor_backend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_set_tensor_backend(ggml_backend_sched_t sched, struct ggml_tensor *node, ggml_backend_t backend)
     * }
     */
    public static MethodHandle ggml_backend_sched_set_tensor_backend$handle() {
        return ggml_backend_sched_set_tensor_backend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_set_tensor_backend(ggml_backend_sched_t sched, struct ggml_tensor *node, ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_sched_set_tensor_backend$address() {
        return ggml_backend_sched_set_tensor_backend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_sched_set_tensor_backend(ggml_backend_sched_t sched, struct ggml_tensor *node, ggml_backend_t backend)
     * }
     */
    public static void ggml_backend_sched_set_tensor_backend(MemorySegment sched, MemorySegment node, MemorySegment backend) {
        var mh$ = ggml_backend_sched_set_tensor_backend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_set_tensor_backend", sched, node, backend);
            }
            mh$.invokeExact(sched, node, backend);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_get_tensor_backend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_sched_get_tensor_backend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_sched_get_tensor_backend(ggml_backend_sched_t sched, struct ggml_tensor *node)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_get_tensor_backend$descriptor() {
        return ggml_backend_sched_get_tensor_backend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_sched_get_tensor_backend(ggml_backend_sched_t sched, struct ggml_tensor *node)
     * }
     */
    public static MethodHandle ggml_backend_sched_get_tensor_backend$handle() {
        return ggml_backend_sched_get_tensor_backend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_sched_get_tensor_backend(ggml_backend_sched_t sched, struct ggml_tensor *node)
     * }
     */
    public static MemorySegment ggml_backend_sched_get_tensor_backend$address() {
        return ggml_backend_sched_get_tensor_backend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_sched_get_tensor_backend(ggml_backend_sched_t sched, struct ggml_tensor *node)
     * }
     */
    public static MemorySegment ggml_backend_sched_get_tensor_backend(MemorySegment sched, MemorySegment node) {
        var mh$ = ggml_backend_sched_get_tensor_backend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_get_tensor_backend", sched, node);
            }
            return (MemorySegment)mh$.invokeExact(sched, node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_alloc_graph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_sched_alloc_graph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_backend_sched_alloc_graph(ggml_backend_sched_t sched, struct ggml_cgraph *graph)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_alloc_graph$descriptor() {
        return ggml_backend_sched_alloc_graph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_backend_sched_alloc_graph(ggml_backend_sched_t sched, struct ggml_cgraph *graph)
     * }
     */
    public static MethodHandle ggml_backend_sched_alloc_graph$handle() {
        return ggml_backend_sched_alloc_graph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_backend_sched_alloc_graph(ggml_backend_sched_t sched, struct ggml_cgraph *graph)
     * }
     */
    public static MemorySegment ggml_backend_sched_alloc_graph$address() {
        return ggml_backend_sched_alloc_graph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_backend_sched_alloc_graph(ggml_backend_sched_t sched, struct ggml_cgraph *graph)
     * }
     */
    public static boolean ggml_backend_sched_alloc_graph(MemorySegment sched, MemorySegment graph) {
        var mh$ = ggml_backend_sched_alloc_graph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_alloc_graph", sched, graph);
            }
            return (boolean)mh$.invokeExact(sched, graph);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_graph_compute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_sched_graph_compute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_sched_graph_compute(ggml_backend_sched_t sched, struct ggml_cgraph *graph)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_graph_compute$descriptor() {
        return ggml_backend_sched_graph_compute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_sched_graph_compute(ggml_backend_sched_t sched, struct ggml_cgraph *graph)
     * }
     */
    public static MethodHandle ggml_backend_sched_graph_compute$handle() {
        return ggml_backend_sched_graph_compute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_sched_graph_compute(ggml_backend_sched_t sched, struct ggml_cgraph *graph)
     * }
     */
    public static MemorySegment ggml_backend_sched_graph_compute$address() {
        return ggml_backend_sched_graph_compute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_sched_graph_compute(ggml_backend_sched_t sched, struct ggml_cgraph *graph)
     * }
     */
    public static int ggml_backend_sched_graph_compute(MemorySegment sched, MemorySegment graph) {
        var mh$ = ggml_backend_sched_graph_compute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_graph_compute", sched, graph);
            }
            return (int)mh$.invokeExact(sched, graph);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_graph_compute_async {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_sched_graph_compute_async");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_sched_graph_compute_async(ggml_backend_sched_t sched, struct ggml_cgraph *graph)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_graph_compute_async$descriptor() {
        return ggml_backend_sched_graph_compute_async.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_sched_graph_compute_async(ggml_backend_sched_t sched, struct ggml_cgraph *graph)
     * }
     */
    public static MethodHandle ggml_backend_sched_graph_compute_async$handle() {
        return ggml_backend_sched_graph_compute_async.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_sched_graph_compute_async(ggml_backend_sched_t sched, struct ggml_cgraph *graph)
     * }
     */
    public static MemorySegment ggml_backend_sched_graph_compute_async$address() {
        return ggml_backend_sched_graph_compute_async.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_sched_graph_compute_async(ggml_backend_sched_t sched, struct ggml_cgraph *graph)
     * }
     */
    public static int ggml_backend_sched_graph_compute_async(MemorySegment sched, MemorySegment graph) {
        var mh$ = ggml_backend_sched_graph_compute_async.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_graph_compute_async", sched, graph);
            }
            return (int)mh$.invokeExact(sched, graph);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_synchronize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_sched_synchronize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_synchronize(ggml_backend_sched_t sched)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_synchronize$descriptor() {
        return ggml_backend_sched_synchronize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_synchronize(ggml_backend_sched_t sched)
     * }
     */
    public static MethodHandle ggml_backend_sched_synchronize$handle() {
        return ggml_backend_sched_synchronize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_synchronize(ggml_backend_sched_t sched)
     * }
     */
    public static MemorySegment ggml_backend_sched_synchronize$address() {
        return ggml_backend_sched_synchronize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_sched_synchronize(ggml_backend_sched_t sched)
     * }
     */
    public static void ggml_backend_sched_synchronize(MemorySegment sched) {
        var mh$ = ggml_backend_sched_synchronize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_synchronize", sched);
            }
            mh$.invokeExact(sched);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_sched_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_reset(ggml_backend_sched_t sched)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_reset$descriptor() {
        return ggml_backend_sched_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_reset(ggml_backend_sched_t sched)
     * }
     */
    public static MethodHandle ggml_backend_sched_reset$handle() {
        return ggml_backend_sched_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_reset(ggml_backend_sched_t sched)
     * }
     */
    public static MemorySegment ggml_backend_sched_reset$address() {
        return ggml_backend_sched_reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_sched_reset(ggml_backend_sched_t sched)
     * }
     */
    public static void ggml_backend_sched_reset(MemorySegment sched) {
        var mh$ = ggml_backend_sched_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_reset", sched);
            }
            mh$.invokeExact(sched);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_set_eval_callback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_sched_set_eval_callback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_set_eval_callback(ggml_backend_sched_t sched, ggml_backend_sched_eval_callback callback, void *user_data)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_set_eval_callback$descriptor() {
        return ggml_backend_sched_set_eval_callback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_set_eval_callback(ggml_backend_sched_t sched, ggml_backend_sched_eval_callback callback, void *user_data)
     * }
     */
    public static MethodHandle ggml_backend_sched_set_eval_callback$handle() {
        return ggml_backend_sched_set_eval_callback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_set_eval_callback(ggml_backend_sched_t sched, ggml_backend_sched_eval_callback callback, void *user_data)
     * }
     */
    public static MemorySegment ggml_backend_sched_set_eval_callback$address() {
        return ggml_backend_sched_set_eval_callback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_sched_set_eval_callback(ggml_backend_sched_t sched, ggml_backend_sched_eval_callback callback, void *user_data)
     * }
     */
    public static void ggml_backend_sched_set_eval_callback(MemorySegment sched, MemorySegment callback, MemorySegment user_data) {
        var mh$ = ggml_backend_sched_set_eval_callback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_set_eval_callback", sched, callback, user_data);
            }
            mh$.invokeExact(sched, callback, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_compare_graph_backend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_compare_graph_backend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_backend_compare_graph_backend(ggml_backend_t backend1, ggml_backend_t backend2, struct ggml_cgraph *graph, ggml_backend_eval_callback callback, void *user_data, struct ggml_tensor *test_node)
     * }
     */
    public static FunctionDescriptor ggml_backend_compare_graph_backend$descriptor() {
        return ggml_backend_compare_graph_backend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_backend_compare_graph_backend(ggml_backend_t backend1, ggml_backend_t backend2, struct ggml_cgraph *graph, ggml_backend_eval_callback callback, void *user_data, struct ggml_tensor *test_node)
     * }
     */
    public static MethodHandle ggml_backend_compare_graph_backend$handle() {
        return ggml_backend_compare_graph_backend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_backend_compare_graph_backend(ggml_backend_t backend1, ggml_backend_t backend2, struct ggml_cgraph *graph, ggml_backend_eval_callback callback, void *user_data, struct ggml_tensor *test_node)
     * }
     */
    public static MemorySegment ggml_backend_compare_graph_backend$address() {
        return ggml_backend_compare_graph_backend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_backend_compare_graph_backend(ggml_backend_t backend1, ggml_backend_t backend2, struct ggml_cgraph *graph, ggml_backend_eval_callback callback, void *user_data, struct ggml_tensor *test_node)
     * }
     */
    public static boolean ggml_backend_compare_graph_backend(MemorySegment backend1, MemorySegment backend2, MemorySegment graph, MemorySegment callback, MemorySegment user_data, MemorySegment test_node) {
        var mh$ = ggml_backend_compare_graph_backend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_compare_graph_backend", backend1, backend2, graph, callback, user_data, test_node);
            }
            return (boolean)mh$.invokeExact(backend1, backend2, graph, callback, user_data, test_node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_tensor_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_tensor_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_tensor_alloc(ggml_backend_buffer_t buffer, struct ggml_tensor *tensor, void *addr)
     * }
     */
    public static FunctionDescriptor ggml_backend_tensor_alloc$descriptor() {
        return ggml_backend_tensor_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_tensor_alloc(ggml_backend_buffer_t buffer, struct ggml_tensor *tensor, void *addr)
     * }
     */
    public static MethodHandle ggml_backend_tensor_alloc$handle() {
        return ggml_backend_tensor_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_tensor_alloc(ggml_backend_buffer_t buffer, struct ggml_tensor *tensor, void *addr)
     * }
     */
    public static MemorySegment ggml_backend_tensor_alloc$address() {
        return ggml_backend_tensor_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_tensor_alloc(ggml_backend_buffer_t buffer, struct ggml_tensor *tensor, void *addr)
     * }
     */
    public static int ggml_backend_tensor_alloc(MemorySegment buffer, MemorySegment tensor, MemorySegment addr) {
        var mh$ = ggml_backend_tensor_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_tensor_alloc", buffer, tensor, addr);
            }
            return (int)mh$.invokeExact(buffer, tensor, addr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_view_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_view_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_view_init(struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_backend_view_init$descriptor() {
        return ggml_backend_view_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_view_init(struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_backend_view_init$handle() {
        return ggml_backend_view_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_view_init(struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_backend_view_init$address() {
        return ggml_backend_view_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_view_init(struct ggml_tensor *tensor)
     * }
     */
    public static int ggml_backend_view_init(MemorySegment tensor) {
        var mh$ = ggml_backend_view_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_view_init", tensor);
            }
            return (int)mh$.invokeExact(tensor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_cpu_buffer_from_ptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_LONG
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_cpu_buffer_from_ptr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_cpu_buffer_from_ptr(void *ptr, size_t size)
     * }
     */
    public static FunctionDescriptor ggml_backend_cpu_buffer_from_ptr$descriptor() {
        return ggml_backend_cpu_buffer_from_ptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_cpu_buffer_from_ptr(void *ptr, size_t size)
     * }
     */
    public static MethodHandle ggml_backend_cpu_buffer_from_ptr$handle() {
        return ggml_backend_cpu_buffer_from_ptr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_cpu_buffer_from_ptr(void *ptr, size_t size)
     * }
     */
    public static MemorySegment ggml_backend_cpu_buffer_from_ptr$address() {
        return ggml_backend_cpu_buffer_from_ptr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_cpu_buffer_from_ptr(void *ptr, size_t size)
     * }
     */
    public static MemorySegment ggml_backend_cpu_buffer_from_ptr(MemorySegment ptr, long size) {
        var mh$ = ggml_backend_cpu_buffer_from_ptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_cpu_buffer_from_ptr", ptr, size);
            }
            return (MemorySegment)mh$.invokeExact(ptr, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_cpu_buffer_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_backend_cpu_buffer_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_cpu_buffer_type()
     * }
     */
    public static FunctionDescriptor ggml_backend_cpu_buffer_type$descriptor() {
        return ggml_backend_cpu_buffer_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_cpu_buffer_type()
     * }
     */
    public static MethodHandle ggml_backend_cpu_buffer_type$handle() {
        return ggml_backend_cpu_buffer_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_cpu_buffer_type()
     * }
     */
    public static MemorySegment ggml_backend_cpu_buffer_type$address() {
        return ggml_backend_cpu_buffer_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_cpu_buffer_type()
     * }
     */
    public static MemorySegment ggml_backend_cpu_buffer_type() {
        var mh$ = ggml_backend_cpu_buffer_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_cpu_buffer_type");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GGML_NUMA_STRATEGY_DISABLED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ggml_numa_strategy.GGML_NUMA_STRATEGY_DISABLED = 0
     * }
     */
    public static int GGML_NUMA_STRATEGY_DISABLED() {
        return GGML_NUMA_STRATEGY_DISABLED;
    }
    private static final int GGML_NUMA_STRATEGY_DISTRIBUTE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ggml_numa_strategy.GGML_NUMA_STRATEGY_DISTRIBUTE = 1
     * }
     */
    public static int GGML_NUMA_STRATEGY_DISTRIBUTE() {
        return GGML_NUMA_STRATEGY_DISTRIBUTE;
    }
    private static final int GGML_NUMA_STRATEGY_ISOLATE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ggml_numa_strategy.GGML_NUMA_STRATEGY_ISOLATE = 2
     * }
     */
    public static int GGML_NUMA_STRATEGY_ISOLATE() {
        return GGML_NUMA_STRATEGY_ISOLATE;
    }
    private static final int GGML_NUMA_STRATEGY_NUMACTL = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ggml_numa_strategy.GGML_NUMA_STRATEGY_NUMACTL = 3
     * }
     */
    public static int GGML_NUMA_STRATEGY_NUMACTL() {
        return GGML_NUMA_STRATEGY_NUMACTL;
    }
    private static final int GGML_NUMA_STRATEGY_MIRROR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ggml_numa_strategy.GGML_NUMA_STRATEGY_MIRROR = 4
     * }
     */
    public static int GGML_NUMA_STRATEGY_MIRROR() {
        return GGML_NUMA_STRATEGY_MIRROR;
    }
    private static final int GGML_NUMA_STRATEGY_COUNT = (int)5L;
    /**
     * {@snippet lang=c :
     * enum ggml_numa_strategy.GGML_NUMA_STRATEGY_COUNT = 5
     * }
     */
    public static int GGML_NUMA_STRATEGY_COUNT() {
        return GGML_NUMA_STRATEGY_COUNT;
    }

    private static class ggml_numa_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_numa_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_numa_init(enum ggml_numa_strategy numa)
     * }
     */
    public static FunctionDescriptor ggml_numa_init$descriptor() {
        return ggml_numa_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_numa_init(enum ggml_numa_strategy numa)
     * }
     */
    public static MethodHandle ggml_numa_init$handle() {
        return ggml_numa_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_numa_init(enum ggml_numa_strategy numa)
     * }
     */
    public static MemorySegment ggml_numa_init$address() {
        return ggml_numa_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_numa_init(enum ggml_numa_strategy numa)
     * }
     */
    public static void ggml_numa_init(int numa) {
        var mh$ = ggml_numa_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_numa_init", numa);
            }
            mh$.invokeExact(numa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_is_numa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_BOOL    );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_is_numa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_is_numa()
     * }
     */
    public static FunctionDescriptor ggml_is_numa$descriptor() {
        return ggml_is_numa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_is_numa()
     * }
     */
    public static MethodHandle ggml_is_numa$handle() {
        return ggml_is_numa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_is_numa()
     * }
     */
    public static MemorySegment ggml_is_numa$address() {
        return ggml_is_numa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_is_numa()
     * }
     */
    public static boolean ggml_is_numa() {
        var mh$ = ggml_is_numa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_is_numa");
            }
            return (boolean)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_new_i32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_new_i32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_i32(struct ggml_context *ctx, int32_t value)
     * }
     */
    public static FunctionDescriptor ggml_new_i32$descriptor() {
        return ggml_new_i32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_i32(struct ggml_context *ctx, int32_t value)
     * }
     */
    public static MethodHandle ggml_new_i32$handle() {
        return ggml_new_i32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_i32(struct ggml_context *ctx, int32_t value)
     * }
     */
    public static MemorySegment ggml_new_i32$address() {
        return ggml_new_i32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_i32(struct ggml_context *ctx, int32_t value)
     * }
     */
    public static MemorySegment ggml_new_i32(MemorySegment ctx, int value) {
        var mh$ = ggml_new_i32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_new_i32", ctx, value);
            }
            return (MemorySegment)mh$.invokeExact(ctx, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_new_f32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_new_f32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_f32(struct ggml_context *ctx, float value)
     * }
     */
    public static FunctionDescriptor ggml_new_f32$descriptor() {
        return ggml_new_f32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_f32(struct ggml_context *ctx, float value)
     * }
     */
    public static MethodHandle ggml_new_f32$handle() {
        return ggml_new_f32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_f32(struct ggml_context *ctx, float value)
     * }
     */
    public static MemorySegment ggml_new_f32$address() {
        return ggml_new_f32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_f32(struct ggml_context *ctx, float value)
     * }
     */
    public static MemorySegment ggml_new_f32(MemorySegment ctx, float value) {
        var mh$ = ggml_new_f32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_new_f32", ctx, value);
            }
            return (MemorySegment)mh$.invokeExact(ctx, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_i32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set_i32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_i32(struct ggml_tensor *tensor, int32_t value)
     * }
     */
    public static FunctionDescriptor ggml_set_i32$descriptor() {
        return ggml_set_i32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_i32(struct ggml_tensor *tensor, int32_t value)
     * }
     */
    public static MethodHandle ggml_set_i32$handle() {
        return ggml_set_i32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_i32(struct ggml_tensor *tensor, int32_t value)
     * }
     */
    public static MemorySegment ggml_set_i32$address() {
        return ggml_set_i32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_i32(struct ggml_tensor *tensor, int32_t value)
     * }
     */
    public static MemorySegment ggml_set_i32(MemorySegment tensor, int value) {
        var mh$ = ggml_set_i32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_i32", tensor, value);
            }
            return (MemorySegment)mh$.invokeExact(tensor, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_f32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set_f32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_f32(struct ggml_tensor *tensor, float value)
     * }
     */
    public static FunctionDescriptor ggml_set_f32$descriptor() {
        return ggml_set_f32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_f32(struct ggml_tensor *tensor, float value)
     * }
     */
    public static MethodHandle ggml_set_f32$handle() {
        return ggml_set_f32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_f32(struct ggml_tensor *tensor, float value)
     * }
     */
    public static MemorySegment ggml_set_f32$address() {
        return ggml_set_f32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_f32(struct ggml_tensor *tensor, float value)
     * }
     */
    public static MemorySegment ggml_set_f32(MemorySegment tensor, float value) {
        var mh$ = ggml_set_f32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_f32", tensor, value);
            }
            return (MemorySegment)mh$.invokeExact(tensor, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_i32_1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_i32_1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int32_t ggml_get_i32_1d(const struct ggml_tensor *tensor, int i)
     * }
     */
    public static FunctionDescriptor ggml_get_i32_1d$descriptor() {
        return ggml_get_i32_1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int32_t ggml_get_i32_1d(const struct ggml_tensor *tensor, int i)
     * }
     */
    public static MethodHandle ggml_get_i32_1d$handle() {
        return ggml_get_i32_1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int32_t ggml_get_i32_1d(const struct ggml_tensor *tensor, int i)
     * }
     */
    public static MemorySegment ggml_get_i32_1d$address() {
        return ggml_get_i32_1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int32_t ggml_get_i32_1d(const struct ggml_tensor *tensor, int i)
     * }
     */
    public static int ggml_get_i32_1d(MemorySegment tensor, int i) {
        var mh$ = ggml_get_i32_1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_i32_1d", tensor, i);
            }
            return (int)mh$.invokeExact(tensor, i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_i32_1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set_i32_1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_set_i32_1d(const struct ggml_tensor *tensor, int i, int32_t value)
     * }
     */
    public static FunctionDescriptor ggml_set_i32_1d$descriptor() {
        return ggml_set_i32_1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_set_i32_1d(const struct ggml_tensor *tensor, int i, int32_t value)
     * }
     */
    public static MethodHandle ggml_set_i32_1d$handle() {
        return ggml_set_i32_1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_set_i32_1d(const struct ggml_tensor *tensor, int i, int32_t value)
     * }
     */
    public static MemorySegment ggml_set_i32_1d$address() {
        return ggml_set_i32_1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_set_i32_1d(const struct ggml_tensor *tensor, int i, int32_t value)
     * }
     */
    public static void ggml_set_i32_1d(MemorySegment tensor, int i, int value) {
        var mh$ = ggml_set_i32_1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_i32_1d", tensor, i, value);
            }
            mh$.invokeExact(tensor, i, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_i32_nd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_i32_nd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int32_t ggml_get_i32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3)
     * }
     */
    public static FunctionDescriptor ggml_get_i32_nd$descriptor() {
        return ggml_get_i32_nd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int32_t ggml_get_i32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3)
     * }
     */
    public static MethodHandle ggml_get_i32_nd$handle() {
        return ggml_get_i32_nd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int32_t ggml_get_i32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3)
     * }
     */
    public static MemorySegment ggml_get_i32_nd$address() {
        return ggml_get_i32_nd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int32_t ggml_get_i32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3)
     * }
     */
    public static int ggml_get_i32_nd(MemorySegment tensor, int i0, int i1, int i2, int i3) {
        var mh$ = ggml_get_i32_nd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_i32_nd", tensor, i0, i1, i2, i3);
            }
            return (int)mh$.invokeExact(tensor, i0, i1, i2, i3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_i32_nd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set_i32_nd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_set_i32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3, int32_t value)
     * }
     */
    public static FunctionDescriptor ggml_set_i32_nd$descriptor() {
        return ggml_set_i32_nd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_set_i32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3, int32_t value)
     * }
     */
    public static MethodHandle ggml_set_i32_nd$handle() {
        return ggml_set_i32_nd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_set_i32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3, int32_t value)
     * }
     */
    public static MemorySegment ggml_set_i32_nd$address() {
        return ggml_set_i32_nd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_set_i32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3, int32_t value)
     * }
     */
    public static void ggml_set_i32_nd(MemorySegment tensor, int i0, int i1, int i2, int i3, int value) {
        var mh$ = ggml_set_i32_nd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_i32_nd", tensor, i0, i1, i2, i3, value);
            }
            mh$.invokeExact(tensor, i0, i1, i2, i3, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_f32_1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_f32_1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float ggml_get_f32_1d(const struct ggml_tensor *tensor, int i)
     * }
     */
    public static FunctionDescriptor ggml_get_f32_1d$descriptor() {
        return ggml_get_f32_1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float ggml_get_f32_1d(const struct ggml_tensor *tensor, int i)
     * }
     */
    public static MethodHandle ggml_get_f32_1d$handle() {
        return ggml_get_f32_1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float ggml_get_f32_1d(const struct ggml_tensor *tensor, int i)
     * }
     */
    public static MemorySegment ggml_get_f32_1d$address() {
        return ggml_get_f32_1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float ggml_get_f32_1d(const struct ggml_tensor *tensor, int i)
     * }
     */
    public static float ggml_get_f32_1d(MemorySegment tensor, int i) {
        var mh$ = ggml_get_f32_1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_f32_1d", tensor, i);
            }
            return (float)mh$.invokeExact(tensor, i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_f32_1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set_f32_1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_set_f32_1d(const struct ggml_tensor *tensor, int i, float value)
     * }
     */
    public static FunctionDescriptor ggml_set_f32_1d$descriptor() {
        return ggml_set_f32_1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_set_f32_1d(const struct ggml_tensor *tensor, int i, float value)
     * }
     */
    public static MethodHandle ggml_set_f32_1d$handle() {
        return ggml_set_f32_1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_set_f32_1d(const struct ggml_tensor *tensor, int i, float value)
     * }
     */
    public static MemorySegment ggml_set_f32_1d$address() {
        return ggml_set_f32_1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_set_f32_1d(const struct ggml_tensor *tensor, int i, float value)
     * }
     */
    public static void ggml_set_f32_1d(MemorySegment tensor, int i, float value) {
        var mh$ = ggml_set_f32_1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_f32_1d", tensor, i, value);
            }
            mh$.invokeExact(tensor, i, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_f32_nd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_FLOAT,
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_get_f32_nd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float ggml_get_f32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3)
     * }
     */
    public static FunctionDescriptor ggml_get_f32_nd$descriptor() {
        return ggml_get_f32_nd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float ggml_get_f32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3)
     * }
     */
    public static MethodHandle ggml_get_f32_nd$handle() {
        return ggml_get_f32_nd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float ggml_get_f32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3)
     * }
     */
    public static MemorySegment ggml_get_f32_nd$address() {
        return ggml_get_f32_nd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float ggml_get_f32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3)
     * }
     */
    public static float ggml_get_f32_nd(MemorySegment tensor, int i0, int i1, int i2, int i3) {
        var mh$ = ggml_get_f32_nd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_f32_nd", tensor, i0, i1, i2, i3);
            }
            return (float)mh$.invokeExact(tensor, i0, i1, i2, i3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_f32_nd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_INT,
            WhisperCpp.C_FLOAT
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_set_f32_nd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_set_f32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3, float value)
     * }
     */
    public static FunctionDescriptor ggml_set_f32_nd$descriptor() {
        return ggml_set_f32_nd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_set_f32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3, float value)
     * }
     */
    public static MethodHandle ggml_set_f32_nd$handle() {
        return ggml_set_f32_nd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_set_f32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3, float value)
     * }
     */
    public static MemorySegment ggml_set_f32_nd$address() {
        return ggml_set_f32_nd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_set_f32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3, float value)
     * }
     */
    public static void ggml_set_f32_nd(MemorySegment tensor, int i0, int i1, int i2, int i3, float value) {
        var mh$ = ggml_set_f32_nd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_f32_nd", tensor, i0, i1, i2, i3, value);
            }
            mh$.invokeExact(tensor, i0, i1, i2, i3, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_threadpool_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_POINTER,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_threadpool_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_threadpool *ggml_threadpool_new(struct ggml_threadpool_params *params)
     * }
     */
    public static FunctionDescriptor ggml_threadpool_new$descriptor() {
        return ggml_threadpool_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_threadpool *ggml_threadpool_new(struct ggml_threadpool_params *params)
     * }
     */
    public static MethodHandle ggml_threadpool_new$handle() {
        return ggml_threadpool_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_threadpool *ggml_threadpool_new(struct ggml_threadpool_params *params)
     * }
     */
    public static MemorySegment ggml_threadpool_new$address() {
        return ggml_threadpool_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_threadpool *ggml_threadpool_new(struct ggml_threadpool_params *params)
     * }
     */
    public static MemorySegment ggml_threadpool_new(MemorySegment params) {
        var mh$ = ggml_threadpool_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_threadpool_new", params);
            }
            return (MemorySegment)mh$.invokeExact(params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_threadpool_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_threadpool_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_threadpool_free(struct ggml_threadpool *threadpool)
     * }
     */
    public static FunctionDescriptor ggml_threadpool_free$descriptor() {
        return ggml_threadpool_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_threadpool_free(struct ggml_threadpool *threadpool)
     * }
     */
    public static MethodHandle ggml_threadpool_free$handle() {
        return ggml_threadpool_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_threadpool_free(struct ggml_threadpool *threadpool)
     * }
     */
    public static MemorySegment ggml_threadpool_free$address() {
        return ggml_threadpool_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_threadpool_free(struct ggml_threadpool *threadpool)
     * }
     */
    public static void ggml_threadpool_free(MemorySegment threadpool) {
        var mh$ = ggml_threadpool_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_threadpool_free", threadpool);
            }
            mh$.invokeExact(threadpool);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_threadpool_get_n_threads {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            WhisperCpp.C_INT,
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_threadpool_get_n_threads");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_threadpool_get_n_threads(struct ggml_threadpool *threadpool)
     * }
     */
    public static FunctionDescriptor ggml_threadpool_get_n_threads$descriptor() {
        return ggml_threadpool_get_n_threads.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_threadpool_get_n_threads(struct ggml_threadpool *threadpool)
     * }
     */
    public static MethodHandle ggml_threadpool_get_n_threads$handle() {
        return ggml_threadpool_get_n_threads.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_threadpool_get_n_threads(struct ggml_threadpool *threadpool)
     * }
     */
    public static MemorySegment ggml_threadpool_get_n_threads$address() {
        return ggml_threadpool_get_n_threads.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_threadpool_get_n_threads(struct ggml_threadpool *threadpool)
     * }
     */
    public static int ggml_threadpool_get_n_threads(MemorySegment threadpool) {
        var mh$ = ggml_threadpool_get_n_threads.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_threadpool_get_n_threads", threadpool);
            }
            return (int)mh$.invokeExact(threadpool);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_threadpool_pause {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_threadpool_pause");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_threadpool_pause(struct ggml_threadpool *threadpool)
     * }
     */
    public static FunctionDescriptor ggml_threadpool_pause$descriptor() {
        return ggml_threadpool_pause.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_threadpool_pause(struct ggml_threadpool *threadpool)
     * }
     */
    public static MethodHandle ggml_threadpool_pause$handle() {
        return ggml_threadpool_pause.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_threadpool_pause(struct ggml_threadpool *threadpool)
     * }
     */
    public static MemorySegment ggml_threadpool_pause$address() {
        return ggml_threadpool_pause.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_threadpool_pause(struct ggml_threadpool *threadpool)
     * }
     */
    public static void ggml_threadpool_pause(MemorySegment threadpool) {
        var mh$ = ggml_threadpool_pause.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_threadpool_pause", threadpool);
            }
            mh$.invokeExact(threadpool);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_threadpool_resume {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            WhisperCpp.C_POINTER
        );

        public static final MemorySegment ADDR = WhisperCpp.findOrThrow("ggml_threadpool_resume");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_threadpool_resume(struct ggml_threadpool *threadpool)
     * }
     */
    public static FunctionDescriptor ggml_threadpool_resume$descriptor() {
        return ggml_threadpool_resume.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_threadpool_resume(struct ggml_threadpool *threadpool)
     * }
     */
    public static MethodHandle ggml_threadpool_resume$handle() {
        return ggml_threadpool_resume.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_threadpool_resume(struct ggml_threadpool *threadpool)
     * }
     */
    public static MemorySegment ggml_threadpool_resume$address() {
        return ggml_threadpool_resume.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_threadpool_resume(struct ggml_threadpool *threadpool)
     * }
     */
    public static void ggml_threadpool_resume(MemorySegment threadpool) {
        var mh$ = ggml_threadpool_resume.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_threadpool_resume", threadpool);
            }
            mh$.invokeExact(threadpool);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

